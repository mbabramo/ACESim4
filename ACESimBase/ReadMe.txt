ACESimBase Codebase Overview (AI summary)

ACESimBase is the core library of the ACESim4 project, containing the fundamental classes and logic for defining games, simulating gameplay, solving games via various algorithms, and collecting results. It is organized into several namespaces/folders, each grouping related components. Below is a detailed breakdown of every C# source file in ACESimBase (on the endogenous-disputes branch), along with brief explanations of their purpose, main classes/methods, and role in the broader application. (The ACESimBase project file ACESimBase.csproj is also present, referencing these files and dependencies like the included System.Data.SqlServerCe DLLs for optional local database support.)
GamePlay (Core Gameplay Framework)
This folder defines the core game-playing framework – how games progress through decisions and actions, tracking histories and outcomes.
ActionGroup.cs – Defines the ActionGroup class representing a collection of one or more actions that can be taken as a unit. It often corresponds to a set of simultaneous decisions or a stage in the game. This class encapsulates a group of possible actions (or a single composite action) and provides utilities to iterate or manage them in gameplay.
ActionGroupRepetition.cs – Defines ActionGroupRepetition, specifying how an ActionGroup may repeat. This is used when a series of actions (an ActionGroup) can occur multiple times. It stores repetition parameters (like number of repetitions or probability distributions) so the game engine can loop through action groups as needed.
ActionPoint.cs – Defines an ActionPoint, which marks a specific point in the game at which an action or decision is made. It typically holds a reference to its ActionGroup and helps to identify the sequence of decisions (e.g., an index or pointer in the game tree). The current ActionPoint in a Game indicates which decision is to be made next.
DefineActions.cs – Utility class containing static methods to define or enumerate all possible actions in the game. This likely includes methods that construct the list of actions or decisions available at each ActionPoint for a given game. It serves as a central place to define the game’s action structure, ensuring consistency across modules.
DirectGamePlayer.cs – Implements a direct-play mode via class DirectGamePlayer (likely implementing IDirectGamePlayer from GameSolvingSupport). This class allows directly simulating the game forward decision-by-decision using a specified strategy profile. It contains methods to run a single game or part of a game by picking actions according to strategies, without going through an iterative solver. In essence, it provides a direct simulation interface for a player or algorithm to traverse the game tree.
Game.cs – The core Game class that orchestrates gameplay​
GITHUB.COM
​
GITHUB.COM
. It ties together players’ strategies, the game definition, and game progress. Major responsibilities include initializing a new play-through (constructing GameProgress and GameModules), stepping through each decision point, and updating game state. Key fields include Progress (a GameProgress tracking state), Strategies (list of player strategy profiles), GameDefinition (rules and structure of the game), and a collection of GameModules (modular components of the game logic). The Game class methods handle advancing to the next ActionPoint, applying players’ actions, and determining when the game ends. Essentially, this class provides the base methods for playing out a game from start to finish.
GameDefinition.cs – Defines GameDefinition, which encapsulates the static description of a game: number of players, what decisions exist, how payoffs are calculated, and so on. It often holds or generates the initial game tree structure. For each specific game (e.g. litigation game, poker game), a subclass of GameDefinition provides the concrete details (via the Games directory). GameDefinition also typically provides a GameFactory (through an IGameFactory interface) to create new GameProgress or other game instances. This class is a cornerstone that bridges game-specific parameters with the generic simulation engine.
GameFullHistory.cs – Class GameFullHistory that records a complete history of game plays. It likely contains a log of all decisions, actions, and outcomes for every iteration or play-through. This can be used for debugging or analysis, especially when running many simulations. It may store sequences of GameHistory or GameHistoryStorable instances for each iteration in a larger experiment, allowing analysis of frequency of actions, outcome distribution, etc.
GameHistory.cs – Defines GameHistory, an object that tracks the sequence of actions and states within a single play-through of a game. As the game is played, GameHistory is appended with each action taken, decisions made, and possibly intermediate states. This provides a timeline of the game that just occurred. It may include references to InformationSetHistory (what each player knew at each point) and can be used to reconstruct or analyze a single play.
GameHistoryStorable.cs – A storable or serializable version of game history. GameHistoryStorable likely mirrors GameHistory but in a form that can be easily saved or reused. For example, it might compress or encode the history (e.g., as bytes or a string) so it can be stored in a database or file. The engine can create a new initialized GameHistoryStorable at game start and fill it as the game progresses​
GITHUB.COM
. This is useful for persisting outcomes of many simulations or for warm-starting algorithms with previously encountered histories.
GameModule.cs – Defines an abstract GameModule class representing a self-contained segment or logic module of a game. Complex games may be broken into modules (for example, “PretrialPhase” vs “TrialPhase” in a litigation game could be modules). Each GameModule might handle a subset of decisions or a stage of the game, making the code modular. It likely provides an interface for initialization and execution of that segment and interacts with the main Game loop via a defined API.
GameModuleProgress.cs – The GameModuleProgress class complements GameModule by tracking state specific to a module during gameplay. For each GameModule in a game, a corresponding GameModuleProgress might exist to record module-specific variables, decisions made in that module, and outcomes. This separation allows each module to maintain its own state information (e.g., one module’s progress might include whether a settlement occurred, another might include trial outcomes in a litigation game). The Game aggregates these module progresses in the overall GameProgress.
GamePlayer.cs – Likely defines a GamePlayer class (or base class) that represents a participant (player) in the game. This could store player-specific information such as their role, index, payoff, or strategy references. In many games, players might be symmetric and not require special classes; however, this class might be a placeholder for future extensions or AI behaviors. (Note: Some games define their players in separate files, e.g., *GamePlayers.cs in each game folder for specific roles.)
GameProgress.cs – Defines GameProgress, which encapsulates the dynamic state of a game in progress. This is one of the core runtime state classes: it keeps track of the current ActionPoint (which decision we’re on)​
GITHUB.COM
, whose turn it is, what actions have been taken so far, and any intermediate calculations (like utilities or signals). It may also contain flags like DecisionNeeded or PreparationPhase​
GITHUB.COM
 to control game flow. GameProgress is passed into various algorithms to evaluate game states, and it is reset or re-initialized for each new play-through. It works closely with GameDefinition and Game to coordinate state updates as decisions are made.
GameProgressLogger.cs – Implements logging for game progress. The GameProgressLogger class likely records each step of GameProgress to an output (console, file, or memory) for debugging or analysis. It might print the current state, decisions, and results as the game runs. This is useful for tracing the simulation step-by-step, especially when verifying game logic or during development of new game models.
GameProgressReportable.cs – An interface or base class (often named IGameProgressReportable in usage) that marks a GameProgress or related class as capable of producing custom result data for reports. This might define methods to extract key metrics or final outcomes from a completed game. Game-specific Progress classes (like in the Games folder) could implement this to provide data to the reporting system (e.g., who won, by how much, how many moves, etc.), which the SimpleReports module can then utilize.
IGameFactory.cs – An interface IGameFactory defining factory methods for game objects. Typically, a GameDefinition will implement this interface to create new instances of core components: new GameProgress objects, initial GameHistory, player strategies, etc. This allows the simulation framework to ask the game definition to generate fresh state or players without depending on concrete game classes. Each specific game (see Games below) has a Factory class implementing IGameFactory.
IGameName.cs – Interface that likely provides a property for a game’s name or identifier. Implemented by game classes or definitions, IGameName might simply enforce that a game or definition can supply a human-readable name (e.g., “Leduc Poker” or “Litigation Game”). This is useful for UI, logging, or when selecting games to run.
InformationSetHistory.cs – Records the information sets sequence during a game. The InformationSetHistory class tracks what each player knows at each decision point of a single play-through. For games with imperfect information, this is critical: it logs the information set index or content that was relevant when each decision was made. This allows algorithms (like CFR or others) to reconstruct the decision context and is used in regret calculations and strategy updates.
InformationSetLog.cs – Likely a structure to log information set details across many iterations. While InformationSetHistory holds data for one play, InformationSetLog might aggregate occurrences of particular information sets or decisions over multiple simulations. It could be used to gather frequencies or to debug how often certain game states occur and with what outcomes, aiding in verifying equilibrium or strategy performance.
IterationID.cs – A small struct or class IterationID that uniquely identifies a simulation iteration (or a run). This might include fields like iteration number, and possibly sub-IDs if running nested simulations. It is used to tag GameProgress or histories with the run index, ensuring that data from different iterations can be distinguished. For example, when storing results or when restarting a game from a specific checkpoint, the IterationID helps manage continuity.
PlayerInfo.cs – Contains PlayerInfo class that holds metadata or parameters for a player in the game. This could include the player’s index, name, type (e.g., human vs AI), or any role-specific settings. In some models, players might have attributes (like risk aversion, skill level, etc.) that are stored here. PlayerInfo is typically used during game setup to configure each player and may be referenced during results reporting (to attribute outcomes to player identities).
SubdivisionCalculations.cs – A utility class for subdividing numeric ranges, likely used in games that involve continuous values or piecewise functions. SubdivisionCalculations might provide methods to divide an interval into segments or to calculate intermediate values (possibly used in evidence games or for integrating continuous probability distributions into discrete approximations). For example, in the AdditiveEvidenceGame (see below), this could help subdivide evidence strength ranges for simulation. This file’s methods ensure that continuous or large ranges are handled in structured segments for analysis or decision-making.
GameSolvingAlgorithms (Solution Algorithms)
This folder contains implementations of various game-solving algorithms (especially for finding approximate equilibria or best responses). Each file typically corresponds to a specific algorithm or approach, often implementing iterative methods for two-player zero-sum games (common in game theory research).
AverageStrategySampling.cs – Implements an Average Strategy Sampling procedure. This algorithm likely iterates gameplay and samples strategies to estimate the average strategy profile. It may be related to self-play methods where the running average of play frequencies converges to a Nash equilibrium strategy. The class contains logic to gather and update average strategy probabilities over many simulation iterations.
BestResponse.cs – Provides a Best Response computation. The BestResponse class most likely computes the best-response strategy for a player given the other player’s fixed strategy. It traverses the game tree (or uses dynamic programming) to find a strategy that maximizes the player’s expected payoff against the opponent’s strategy. This is often used inside iterative algorithms (like Fictitious Play or CFR) to evaluate how far a current strategy is from equilibrium by seeing what a unilateral improvement would be.
CounterfactualRegretMinimization.cs – Implements the classic Counterfactual Regret Minimization (CFR) algorithm. CFR is a foundational iterative algorithm for approximating Nash equilibria in extensive-form games. The CounterfactualRegretMinimization class likely houses the main loop updating regret for each information set and adjusting strategy accordingly. Key methods would include traversing the game tree to accumulate regrets and then normalizing those regrets into a new strategy. This class works closely with game definitions and the information set structure to repeatedly simulate the game and refine strategies for each decision.
DeepCFR.cs – Implements Deep CFR, an advanced variant of CFR that uses function approximation (neural networks) to generalize strategy across similar states. The DeepCFR class coordinates multiple components: it generates training data from self-play, uses regression (via neural networks) to approximate the regret or strategy functions, and then iteratively refines those models. This class would rely on support classes (in GameSolvingSupport) like DeepCFRModel, DeepCFRObservation, etc. It orchestrates the overall deep learning loop – repeatedly playing games to collect observations and training the models that represent strategy (rather than storing exact regrets for every information set).
FictitiousPlay.cs – Implements Fictitious Play, a learning process where each player assumes the opponent will continue with the average of their past strategies and best-responds to that. The FictitiousPlay class likely runs iterative simulations where each iteration a player’s strategy is updated to the best response to the opponent’s cumulative average strategy. It keeps track of the frequency distributions of actions (the “belief” about the opponent) and updates until (hopefully) convergence. This algorithm is simpler but may converge slowly; the class encapsulates the logic for updating and averaging strategies each round.
GeneralizedVanilla.cs – Implements a Generalized Vanilla algorithm – likely a straightforward self-play algorithm with some custom twist or generalization. “Vanilla” might refer to a basic CFR or policy iteration. The GeneralizedVanilla class probably extends a simple solver by adding parameters or by unifying several cases (hence “generalized”). It could iterate through the game tree, updating strategies in a naive way or serve as a baseline algorithm for comparison. Accompanying utility is in GeneralizedVanillaUtilities.cs (in GameSolvingSupport) which suggests this algorithm has support functions for its calculations.
GeneticAlgorithm.cs – Applies a Genetic Algorithm to strategy search. The GeneticAlgorithm class treats strategies or strategy profiles as individuals in a population and evolves them through selection, crossover, and mutation to improve performance (e.g., higher expected payoff against others). It likely uses support classes like GeneticPopulation and GeneticPopulationMember from GameSolvingSupport to maintain populations and evaluate fitness. Over successive generations, this algorithm tries to evolve near-optimal strategies for the game.
GibsonProbing.cs – Implements Gibson probing, which is likely a specialized algorithm or heuristic method referenced in literature (possibly from researcher Matthew Gibson for equilibrium finding). The GibsonProbing class might use selective traversal of the game tree (“probing” certain branches) to estimate opponent strategies or regrets efficiently. It could be related to sparse outcome sampling or focusing on relevant portions of the game. The presence of a ModifiedGibsonProbing.cs suggests that this algorithm has a variant or improvement; the GibsonProbing class encapsulates the original method.
GreedyFictitiousSelfPlay.cs – A hybrid algorithm combining elements of fictitious play with a greedy strategy update. GreedyFictitiousSelfPlay likely runs self-play iterations but uses a greedier update rule than standard fictitious play. For example, instead of fully best-responding to the average opponent, it might update only partially or only at certain information sets (greedily improving immediate regret). This could speed up convergence or target exploitability more directly. The class would manage strategy updates in a loop, much like CFR, but with a “greedy” criterion for changes.
ModifiedGibsonProbing.cs – A variant or improved version of the Gibson probing algorithm. ModifiedGibsonProbing likely adjusts Gibson’s method for better performance or stability. It might change how branches are selected or how the probing results update the strategy. This class builds on GibsonProbing by overriding or extending certain steps. Together, the two Gibson classes allow experimentation between the original and modified approaches to gauge which yields better equilibria or faster runtime.
PlaybackOnly.cs – A solver class that performs Playback Only. PlaybackOnly likely doesn’t actively learn or update strategies; instead, it may simply play back a fixed set of strategies for evaluation or debugging. For instance, if strategies have been computed by another process (or loaded from file), this class could simulate games using those strategies to collect outcome statistics. Essentially, it runs the game without modification of strategies – useful as a baseline or to validate a given strategy profile’s performance.
PureStrategiesFinder.cs – A tool for finding pure strategy equilibria or candidates. The PureStrategiesFinder class likely systematically iterates through combinations of pure strategies (where each player chooses one action deterministically at each info set) to evaluate outcomes. It could be used in smaller games to check all strategy combinations for a Nash equilibrium (i.e., find any profile where no player can improve by deviating). It might prune the search space using dominance or rely on payoff matrices. The class outputs any pure strategy profiles that are equilibrium (or near-equilibrium) in the game.
SequenceForm.cs – Implements a Sequence Form algorithm for solving two-player extensive games via linear programming. The SequenceForm class presumably constructs the sequence-form representation of the game (a compact representation of strategies and constraints) and then uses a linear solver (like Lemke’s algorithm or simplex) to solve for a Nash equilibrium. It likely interfaces with the EFG (Extensive Form Game) representation of the game. Support classes like SequenceFormPayoffs in GameSolvingSupport store payoff matrices for sequences. If an LP solver or Lemke-Howson algorithm is integrated, this class will set up the required equations and call it to obtain equilibrium strategies.
Vanilla.cs – A basic self-play algorithm referred to as “Vanilla” (likely Vanilla CFR or Vanilla policy iteration). The Vanilla class provides a straightforward implementation of an iterative strategy solver without enhancements. For example, it may implement the simplest form of CFR (no regret matching plus, no pruning, etc.) or simple policy iteration that uniformly updates strategies. This serves as a baseline algorithm. The term “vanilla” indicates minimal adjustments – it uses the fundamental approach described by the theory, and accompanying VanillaUtilities (in support) might handle calculations like regret to strategy conversion.
ECTAAlgorithm/ (folder): This subfolder contains a collection of classes implementing a specialized equilibrium-finding algorithm, potentially using Lemke’s method (given references to “Lemke”) for computing exact solutions in extensive-form games. ECTA likely stands for an algorithm or approach described in a research context. The classes here work together to translate a game into a format solvable by a linear complementarity or Lemke–Howson algorithm and run that solver:
ColumnPrinter.cs – Utility for printing or formatting columns of data (possibly used to output matrices or intermediate calculations for debugging the ECTA algorithm). It may help in logging the payoff matrix or strategy vectors in a tabular form.
ECTAException.cs – Defines custom exceptions related to the ECTA algorithm. Errors during equilibrium computation (e.g., if the solver fails to find a solution or the game input is inconsistent) would throw an ECTAException with relevant error details.
ECTAInformationSet.cs – Represents an information set in the context of the ECTA algorithm’s game tree representation. This class likely stores information set details (such as the player, the sequence of moves leading to it, and indexing used by the solver). It might also hold references to moves (actions) available from that info set.
ECTALemke.cs – Implements the Lemke-Howson algorithm or a variant tailored to extensive form. ECTALemke is probably responsible for setting up the linear complementarity problem (LCP) that Lemke-Howson will solve to find a Nash equilibrium in a two-player game. It likely interacts with ECTAPayVector and ECTANode to pivot through bases and find equilibrium strategies.
ECTALemkeOptions.cs – Configuration class for the Lemke solver. ECTALemkeOptions might include options like maximum iterations, tolerances, or pivoting rules to use in the Lemke algorithm. It allows tuning the ECTA equilibrium solver’s behavior.
ECTAMove.cs – Represents a move (action) in the game tree for the ECTA solver. ECTAMove could store which information set it belongs to, which player (or chance) makes the move, and possibly an identifier used in building the payoff matrix. It essentially is the extensive-form move translated into the normal-form (sequence form) context.
ECTANode.cs – Represents a node in the game tree for ECTA. ECTANode might be used to build the extensive form as a tree structure: each node has moves leading out and may correspond to either a decision by a player or a chance event or a terminal outcome. This class likely includes pointers to children nodes, parent node, and possibly the information set (for player nodes).
ECTAOutcome.cs – Represents an outcome of the game in the ECTA framework. ECTAOutcome likely corresponds to a terminal node’s payoff outcome. It might hold the utility values for players at that outcome and references to the sequence of moves that led there. This information is used to construct payoff vectors for solving.
ECTAPayVector.cs – Likely a structure for payoff vectors associated with sequences. ECTAPayVector might map a combination of sequences (one per player) to the resulting payoff (the LCP solution deals in such vectors). It could be used to build the payoff matrix or to interpret the results from the Lemke algorithm.
ECTARunner.cs – Coordinates running the ECTA equilibrium finder. ECTARunner likely ties everything together: it takes a game definition, constructs the extensive-form representation (nodes, information sets, outcomes) via the other ECTA classes, and then invokes ECTALemke to solve for an equilibrium. It then interprets the solution, perhaps outputting strategies or verifying the equilibrium.
ECTATreeDefinition.cs – Prepares a tree representation of the game specifically for the ECTA algorithm. ECTATreeDefinition probably traverses an ACESim GameDefinition or uses the GameProgressTree (from support) to create ECTANode and ECTAInformationSet structures. It essentially converts the game from ACESim’s format to the format needed for the Lemke/ECTA computation (setting up data structures for moves, info sets, payoffs).
GameSolvingSupport (Supporting Structures for Algorithms)
This folder contains helper classes, data structures, and utilities that support the game-solving algorithms. Many of these classes store algorithm state (regrets, strategy data, etc.), implement generic algorithm components, or provide common functionality needed by multiple algorithms.
AcceleratedBestResponsePrep.cs – Contains logic to accelerate best-response calculations. The class likely computes and caches intermediate values to speed up repeated best response queries. For example, it might preprocess payoff contributions of certain subgames so that a best response can be found faster. This is useful in algorithms where best responses are computed frequently (like fictitious play or inner loops of CFR).
ActionProbabilityUtilities.cs – Utility methods for handling action probability distributions. This might include functions to normalize probabilities, to combine strategy profiles, or to sample actions according to a probability distribution. Algorithms use these utilities to manage and manipulate the probabilities of actions at each information set (e.g., when converting regrets to strategy probabilities or computing mixed strategy averages).
ActionStrategies.cs – Likely defines structures for strategies associated with specific actions or decisions. It could contain classes or methods that map from information sets to chosen actions (or distributions of actions). For example, it might have a representation of a strategy profile that can be easily updated or queries for “what is the probability of taking Action X at InfoSet Y?”. This helps algorithms systematically update and track strategies throughout training.
CalculateMinMax.cs – Provides methods to calculate min-max ranges or values in game trees. It might be used to compute the range of possible payoffs (min and max utility) for normalization or to verify if a strategy guarantees a certain value. In zero-sum games, such calculations relate to the security value for players. This class likely traverses the game tree to find minimum and maximum achievable payoffs for given conditions.
CalculateUtilitiesAtEachInformationSet.cs – Contains logic to compute expected utilities at each information set for a given strategy profile. Essentially, for each decision point (info set) in the game, it calculates the utility (payoff) outcome given the current strategies beyond that point. This is vital in algorithms like CFR which need the counterfactual utility of each action to compute regrets. The class likely has methods to traverse the game tree and produce a mapping from information set -> utility values. There might be a variant:
CalculateUtilitiesAtEachInformationSet_MaybeExact.cs – Similar to the above but possibly with an option for exact calculation (using rational or symbolic computation) versus approximate. CalculateUtilitiesAtEachInformationSet_MaybeExact might decide between a precise computation or a faster approximate one depending on context, ensuring that certain algorithms that require high precision (or dealing with very small probabilities/regrets) can get exact values when needed.
ChanceNode.cs – Represents a chance node in the game tree (where an outcome is determined by probability rather than by a player’s action). ChanceNode is likely a base class or structure holding the probabilities of each chance outcome and the subsequent node references. It provides methods to sample an outcome or to iterate through outcomes when calculating expectations. In game-solving, chance nodes must be handled by taking weighted averages of utilities.
ChanceNodeEqualProbabilities.cs – A specialization of ChanceNode for the common case where all outcomes are equally likely. This class simplifies calculations by assuming each branch has equal probability. It likely hardcodes the probability distribution to uniform, making it easier to generate outcomes or compute expectations quickly when chance outcomes are evenly distributed.
ChanceNodeUnequalProbabilities.cs – Complement to the above, for chance nodes where outcomes have differing probabilities. ChanceNodeUnequalProbabilities stores an explicit probability distribution array for its outcomes. It provides functionality to draw outcomes according to those weights and to incorporate these probabilities into utility calculations. The existence of these two classes (equal vs. unequal) suggests an optimization: the equal-probability case can omit storing a distribution and run slightly faster.
ConstructGameTreeInformationSetInfo.cs – A routine to construct information set metadata for the entire game tree. ConstructGameTreeInformationSetInfo likely traverses the defined game (via GameDefinition and related classes) and builds a comprehensive structure of all information sets, their relationships, and mapping to decision points. This is probably used at initialization of an algorithm to know how many information sets exist, how to index them, and maybe to set up data structures (like regret tables) of appropriate size. It may produce a list or tree of InformationSetNode objects used later by CFR and others.
DeepCFRCompoundRegressionMachinesContainer.cs – Part of the Deep CFR support, this class might contain multiple regression models (referred to as "compound regression machines"). DeepCFRCompoundRegressionMachinesContainer could manage a collection of neural network models for different parts of the strategy. In Deep CFR, typically two networks are used per player: one for the policy (strategy network) and one for the value function (regret or advantage network). If the game has various decision points, multiple models might be used. This container organizes them, possibly one model per information set or per grouping of info sets, and provides access for training and inference.
DeepCFRDirectGamePlayer.cs – Bridges Deep CFR with the direct game simulation. DeepCFRDirectGamePlayer likely implements the interface to allow the deep CFR strategy (neural network) to be used in actual gameplay. It probably queries the trained neural network(s) to decide an action at each information set during a simulation. This allows testing the learned strategy by simulating a game using the networks as players. Essentially, it wraps the networks in a form that looks like a normal DirectGamePlayer, choosing actions according to the probabilities output by the Deep CFR models.
DeepCFRIndependentVariables.cs – Defines the independent variables (features) used as input to the Deep CFR regression models. In extensive-form games, features might include the information set context (e.g., cards dealt so far, previous actions). DeepCFRIndependentVariables likely lists or computes the numerical representation of a game state fed into the neural network. It could include one-hot encodings of actions, normalized round indices, etc., to represent an information set’s state in a vector form.
DeepCFRModel.cs – Represents a single Deep CFR model, presumably a wrapper around a machine learning model (like a neural network). DeepCFRModel would handle tasks like initializing the network architecture, training it on collected data (observations of regrets or strategies), and querying it to get strategy recommendations. There might be separate instances for policy networks vs. value networks. It likely uses an underlying ML framework (possibly ML.NET, given the presence of MLNetRegression.cs in Util) to train and predict.
DeepCFRMultiModel.cs – Extends DeepCFRModel to handle multiple sub-models or outputs. DeepCFRMultiModel might be a model that predicts multiple things at once (e.g., a combined network that outputs strategy probabilities for every action). Alternatively, it could handle multiple outcomes per input (like regrets for each action). This class could manage a network whose output dimension covers all actions, in contrast to separate small models per action or per decision. It simplifies training by using one model for many decisions simultaneously.
DeepCFRMultiModelContainer.cs – A container to hold several DeepCFRMultiModel instances. If the approach uses segmentation (for instance, one multi-output network per game phase or per player), DeepCFRMultiModelContainer organizes them. It likely provides indexing to retrieve the correct model for a given information set or player. This helps Deep CFR manage complexity when dealing with large games by possibly splitting the strategy function approximation across multiple networks.
DeepCFRMultiModelMode.cs – Enumerates or configures the mode of using multiple models in Deep CFR. DeepCFRMultiModelMode could be an enum or settings class that indicates how the multiple models are structured: e.g., Single (one model for all info sets), PerDepth (one model per depth of game tree), PerPlayer (separate models for each player), etc. This allows the Deep CFR algorithm to switch between different training regimes or to log which mode is being employed.
DeepCFRObservation.cs – Defines a data structure for a training observation used in Deep CFR. DeepCFRObservation likely includes fields such as the independent variable features (game state features at a decision) and the target value (which might be a regret or a probability). These observations are collected during self-play and then fed to the DeepCFRModel for training. This class organizes the data (and possibly includes methods to merge or weight observations).
DeepCFRObservationNum.cs – Possibly a variant or specific type of observation for numeric outcomes. DeepCFRObservationNum could store numeric outcomes (like utility values or numeric regrets) from self-play trajectories. It might be used for training value networks (predicting expected value) as opposed to policy networks. Alternatively, it might track an observation with an identifier or index (hence “Num”) for efficient storage.
DeepCFRObservationOfDecision.cs – Another specialized observation type capturing the context of a particular decision. DeepCFRObservationOfDecision might link an observation to a specific decision index or information set ID. This could be used to group observations by decision for training separate models or simply to label data so the correct model knows which portion of the game the data is from.
DeepCFRPlaybackHelper.cs – Utility to facilitate playback (simulation) of games using deep CFR strategies. DeepCFRPlaybackHelper likely contains methods to run a set of simulated games where the players’ strategies are given by the trained deep CFR models. It might set up the DeepCFRDirectGamePlayer for each player and cycle through a number of games, collecting statistics (perhaps to evaluate the performance of the current model or to generate new observations for another iteration of training).
DeepCFRProbabilitiesCache.cs – Caches probability distributions from the deep CFR networks. DeepCFRProbabilitiesCache could be used to avoid repeated neural network calls for identical states. If many simulations revisit the same information set, this cache can store the last predicted strategy (action probabilities) for that info set to reuse, significantly speeding up self-play. It would need to be invalidated if the model changes during training, but during a single evaluation phase it can save computation.
DeepCFRTraversalMode.cs – Enum or configuration for how the game tree is traversed during Deep CFR. DeepCFRTraversalMode might specify whether the algorithm uses external sampling, outcome sampling, or full tree traversal to collect training data. It could include modes like “VanillaMonteCarlo”, “OutcomeSampling”, “ExternalSampling”, etc., which alter how the observations are gathered from self-play. This influences bias/variance of the training data.
EFGFileWriter.cs – A class to export the game tree to .efg format (Extensive Form Game file). EFGFileWriter takes the internal representation of a game (its nodes, information sets, probabilities, and payoffs) and writes it out in the standardized .efg format. This is likely used for interoperability or analysis – for instance, to verify the game structure or to use external equilibrium solvers. It will traverse the game tree (using classes like GameProgressTree and InformationSetNode) and produce a text file listing the extensive form in the Gambit .efg format.
EvolutionSettings.cs – Configuration class for evolutionary algorithms or any iterative improvement of strategies. EvolutionSettings likely includes parameters such as mutation rate, selection pressure, or number of generations for the genetic algorithm, or it could also cover settings for other evolving strategy processes. It centralizes all tunable settings that govern how strategies evolve over time, making it easier to experiment with different values.
ExactValue.cs – Represents a game value calculated with exact precision. ExactValue might encapsulate a payoff or probability as an exact rational number (using big integers or fractions) to avoid floating-point error. This could be used in portions of the code that require high precision, for example when verifying equilibrium conditions or in certain Lemke/linear programming contexts. There’s likely a complementary InexactValue for floating-point approximations.
FinalUtilitiesNode.cs – Represents a terminal node’s utility outcomes in the game tree (as part of solver support). FinalUtilitiesNode likely stores the final payoffs for all players when a particular end state is reached. Solvers might use this to backpropagate values or to build linear equations. It might be integrated with tree traversal classes (GameProgressTree) to mark leaf nodes and retrieve their utility vectors.
GameApproximationAlgorithm.cs – A base class or interface for any game-solving algorithm that uses iterative approximation. GameApproximationAlgorithm could declare common functionality (start/stop, iteration loop, strategy storage) that algorithms like CFR, fictitious play, etc., inherit. It may hold common data such as references to the GameDefinition, current strategy profiles, and methods to measure convergence (like exploitability). Concrete algorithms would extend this and implement the abstract steps (like how to update strategy each iteration) while sharing infrastructure.
GameNodeRelationship.cs – Represents relationships in the game tree, likely used to map between nodes, information sets, and actions. GameNodeRelationship might be a structure that links a parent node to its child nodes or connects an information set to all nodes that belong to it. It could also encode predecessor/successor relationships needed for traversals. Possibly used when constructing the GameProgressTree or when analyzing structure (e.g., to quickly find which nodes correspond to the same decision for different players).
GameNodeRelationshipsFinder.cs – A helper that scans the game and builds a collection of GameNodeRelationship instances. GameNodeRelationshipsFinder likely goes through the game tree and records relationships like “Information Set A leads via Action X to Information Set B” etc. This is useful for validation or for algorithms that need quick access to neighbors in the game graph (like the sequence form solver or any algorithm that caches transitions).
GameOptions.cs – A class collecting various game execution options. GameOptions may include flags and settings that affect how a game is played or solved, such as “use exact computations”, “enable certain optimizations”, or toggles for debug output. It could be passed into simulations or algorithms to alter their behavior without changing code. This generic GameOptions might also be subclassed or extended by specific games (for example, litigation game might have extra options, see LitigGame/Options).
GameProgressTree.cs – Represents the entire game tree in a structured form. GameProgressTree likely is a static or lazily-built tree of all possible GameProgress states (nodes) linked by possible actions. Each node in this tree would have children corresponding to each possible action (or chance outcome) from that state. This structure is immensely useful for algorithms that need to iterate over all game states systematically (like building linear programs or doing full DP solutions). It may not be fully realized for very large games due to memory, but if used, it caches the game structure.
GameProgressTreeNodeAllocation.cs – Manages memory allocation for nodes in GameProgressTree. Because game trees can be very large, GameProgressTreeNodeAllocation might implement a pool or memory reuse scheme for tree nodes. It could pre-allocate chunks of nodes or use object pooling to avoid frequent allocations when building the tree. This file suggests performance tuning to efficiently handle thousands or millions of nodes if needed.
GameProgressTreeNodeInfo.cs – Contains informational data for each node in the GameProgressTree. GameProgressTreeNodeInfo might store things like depth, information set ID, whether it’s a chance or decision node, etc., for every node in the tree. It helps algorithms quickly retrieve node metadata without recomputation. This can be crucial for indexing strategies or regrets by node or for performing DFS/BFS traversals with additional context.
GameProgressTreeNodeProbabilities.cs – Likely stores probability information for each node in the GameProgressTree when following a particular strategy profile. GameProgressTreeNodeProbabilities could be a structure mapping each node to the reach probability (the probability that the game will reach that node under the current strategies). This is vital for regret calculation and expected value computation; CFR algorithms compute reach probabilities for player and opponent at each node. This class probably has methods to compute and update those probabilities as strategies change.
GameStateTypeEnum.cs – An enumeration defining types of game states. GameStateTypeEnum might list values like Decision, Chance, Terminal, Initial, etc., categorizing the nodes in the game progress tree. It is used to easily switch on state type (for example, to handle chance nodes differently from decision nodes during tree traversal).
GeneralizedVanillaUtilities.cs – Support functions for the Generalized Vanilla algorithm (see GeneralizedVanilla.cs). GeneralizedVanillaUtilities could include math helpers to update regrets or strategies in whatever generalized way that algorithm uses. It might also track additional metrics needed by that algorithm. Essentially, it factors out some of the repetitive calculations (like regret summing, or criteria to generalize updates) from the main algorithm class to keep it cleaner.
GeneticPopulation.cs – Defines a population of strategies for the genetic algorithm. GeneticPopulation likely contains a list of GeneticPopulationMember (each representing one candidate strategy set), and methods to initialize the population, evaluate fitness of each member (perhaps by playing a tournament or against a fixed opponent), and select members for reproduction. It might also manage generation advancement (replacing old members with new offspring).
GeneticPopulationMember.cs – Represents a single individual in the genetic algorithm population. GeneticPopulationMember wraps a candidate strategy (or set of strategies for all players) and possibly its fitness score. It provides methods or fields for mutation and crossover – for example, it might have a method to produce a slightly mutated copy of itself or to merge with another member. The class would also store the strategy in a form that can be easily manipulated (perhaps as an array of numeric parameters corresponding to probabilities of actions).
HistoryNavigationInfo.cs – A helper to navigate the GameHistory. HistoryNavigationInfo likely stores pointers or indices to move backward or forward in a recorded history. For example, it might allow jumping to the last decision made, or retrieving the state before a certain action was taken. This could be used in analysis or in algorithms that “undo” and “redo” moves during a search (like depth-first traversals that backtrack in the game tree). It essentially makes the sequential GameHistory accessible in a random-access manner.
HistoryPoint.cs – Possibly a struct representing a single point in history (one decision or action). HistoryPoint could contain the information set, the action chosen, and the resulting state transition for one step in the history. By encapsulating that, it’s easier to manipulate or examine a GameHistory as a sequence of HistoryPoint rather than raw moves. It might be used in storing histories or comparing them (e.g., checking if two histories share the same sequence up to a point).
HistoryPointStorable.cs – A variant of HistoryPoint that is serializable or optimized for storage. HistoryPointStorable might compress a history point (for example, using an integer to represent the action rather than an object reference, and similarly compressing state info). This would be used when writing histories to file or storing many of them in memory for analysis. It ensures that each step in history can be saved and reconstructed efficiently as needed.
IAnyNode.cs – A generic interface for a node in any game-related tree structure (game tree, information set tree, etc.). IAnyNode likely abstracts over different node types, providing common properties like children, parent, depth, etc. Classes like InformationSetNode or game tree nodes might implement this interface so that generic algorithms can operate on “any node” without caring if it’s a chance node, decision node, etc. This promotes code reuse in tree traversals and analyses.
IDirectGamePlayer.cs – An interface defining an entity that can directly play the game step-by-step. IDirectGamePlayer likely declares a method like ChooseAction(GameProgress progress) which, given the current state of the game, returns the chosen action for the player. This interface is implemented by things such as DirectGamePlayer (which chooses via a fixed strategy) and possibly DeepCFRDirectGamePlayer (which chooses via a neural network). It allows the game simulation to be agnostic about how decisions are made – whether by fixed strategy, AI model, or on-the-fly computation – as long as it conforms to this interface.
IGameState.cs – An interface for game state objects. IGameState might be implemented by GameProgress or by lower-level state representations to expose necessary state information generically. It could define properties for querying which player’s turn it is, whether the state is terminal, retrieving available actions, etc. By coding algorithms against IGameState, the same algorithm could potentially operate on different representations of game state (useful if one wants to plug in a simplified game model for testing).
ITreeNodeProcessor.cs – An interface for classes that process nodes of a game tree. ITreeNodeProcessor likely declares methods used when walking the game tree (for example, entering a node, leaving a node, processing a leaf). Classes implementing this can be passed to a generic tree traversal routine (GameProgressTree or similar), and the traversal calls the interface methods at each node. This pattern allows implementing different operations on the tree (such as building data structures, computing values, or printing nodes) by just changing the ITreeNodeProcessor implementation.
InexactValue.cs – Complement to ExactValue, representing values with standard floating-point precision. InexactValue would wrap a double (or similar) and possibly provide methods to combine or compare with ExactValue. In contexts where performance is more critical than absolute precision, InexactValue objects would be used. The code likely uses ExactValue for verifying results or when needed, but defaults to InexactValue in iterative algorithms to keep them fast.
InformationSetLookupApproach.cs – Possibly an enum or configuration class enumerating strategies for looking up information sets. InformationSetLookupApproach might list different methods of mapping game states to information set indices (for example, hashing vs. tree traversal vs. using an explicit map). Depending on the approach chosen, the algorithm may store and retrieve information set data differently. This could be an optimization toggle for CFR: one approach might compute an ID on the fly, another might pre-index them.
InformationSetNode.cs – Represents an information set node in the context of building or analyzing the game tree. InformationSetNode likely contains data about a particular information set (which decisions belong to it, what states are part of it, etc.) and pointers to child information sets following each possible action. This essentially forms an abstract game tree at the level of information sets rather than specific states. It’s useful for algorithms like CFR that operate at the information set level – the class organizes transitions from one info set to another given an action.
InformationSetNodeCoreData.cs – Core data structure for information set nodes. InformationSetNodeCoreData might hold the minimal necessary information for each information set: e.g., player index, list of actions, parent information set, and possibly initial regrets or strategy probabilities. By separating “core data”, the code can optimize memory or speed (for example, keeping this in arrays for quick access during simulation or regret updates).
InformationSetNodesCoreData.cs – Likely a collection or manager for all InformationSetNodeCoreData. InformationSetNodesCoreData could aggregate arrays or lists of core data for every information set in the game. It provides quick indexed access (by information set ID) to the properties of each information set needed by algorithms. This is likely used in inner loops of CFR/regret algorithms for performance (avoiding object dereference overhead by working with indexable arrays of primitives).
KlermanData.cs – Contains Klerman’s dataset or parameters for the litigation game (the name suggests reference to a legal scholar or model). KlermanData probably includes empirically observed or assumed values (like probabilities, costs, or utility parameters) used in the LitigGame model. For instance, it might define default probability distributions for case strengths or other economic parameters from Mark Klerman’s research (if applicable). The litigation game can use this class to initialize scenario parameters, ensuring the simulation is grounded in real or literature-based data.
Launcher.cs – A launcher class to execute simulations or algorithms. Launcher likely provides a high-level interface to run a particular game-solving algorithm on a given game definition with specified settings. It may parse GameOptions, set up the game, and repeatedly call the solver (like CFR or DeepCFR) for a number of iterations, then collect and output results. Essentially, it’s a coordinator that can be invoked from a console application or test to kick off a full simulation experiment. It might support running multiple algorithms or multiple runs as well.
MaybeExact.cs – A utility type that can hold either an exact or inexact value. MaybeExact likely wraps either an ExactValue or an InexactValue and is used when the code can operate in two modes (exact vs. floating) depending on user settings or problem size. This avoids rewriting algorithms – they can use MaybeExact for calculations, and internally it will choose the exact rational path or the double path. It’s a form of type-erasure to unify handling of numeric precision.
ModelPredictingUtilitiesDatum.cs – Part of model-based predictions (likely for Deep CFR). ModelPredictingUtilitiesDatum might represent a single data point of predicted utilities for a particular game node or information set. It could hold the predicted value from a neural network model and the actual observed value for comparison, serving as a “datum” for measuring accuracy of the model’s predictions. This might be used to evaluate the learning progress (seeing how well the model predicts actual outcomes).
NodeAction.cs – A simple structure tying a node (game state or info set) to an action. NodeAction is likely used as a key in dictionaries or as part of history tracking, representing that “at node X, action Y was taken”. It may include the node ID and action ID, with appropriate equality/hash so it can index data (for example, regrets or strategy counts for that particular node-action pair).
NodeActionsHistory.cs – Records a history of actions for a particular node across simulations. NodeActionsHistory could store how many times each action at a given node has been taken throughout all iterations. It’s essentially accumulating frequencies at a node. This is useful for building the average strategy or for analysis of which actions are more favored. Possibly used by fictitious play or for reporting convergence (e.g., if one action’s frequency goes to 0 or 1, that might indicate stable strategy).
NodeActionsMultipleHistories.cs – Extends the above concept to handle multiple independent histories. NodeActionsMultipleHistories might keep separate action-frequency records for different runs or different scenarios. For instance, if running multiple simulations in parallel or comparing strategy profiles, this class can hold multiple NodeActionsHistory sets and facilitate combining or comparing them. It ensures that one can analyze the distribution of actions not just overall but in separate contexts (like separate players or separate algorithm variants).
PathFromPredecessorInfo.cs – Stores information about the path from a predecessor node, probably in the game tree or information set graph. PathFromPredecessorInfo might contain the previous node, the action taken, and any cumulative probability or utility up to that point. It’s likely used during traversal to carry forward important values. For example, CFR uses path probabilities: one from the player and one from the opponent. This class might carry those along as you move from one node to its child. It encapsulates the notion of “arriving via a certain action from a certain prior state” to the current node.
PostIterationUpdaterBase.cs – An abstract base for classes that perform post-iteration updates on strategies. Many iterative algorithms after each iteration will adjust their strategy or some weights. PostIterationUpdaterBase defines an interface or common functionality for this process. It might have a method like UpdateStrategies(iterationResults) that others implement. The derived classes likely correspond to specific update rules (Multiplicative Weights, Regret Matching, etc.). This base could hold references to things like current strategy probabilities and provide helper functions for the update.
PostIterationUpdater_MultiplicativeWeights.cs – A concrete post-iteration update class using the Multiplicative Weights method. PostIterationUpdater_MultiplicativeWeights implements the update rule where strategy probabilities are adjusted by multiplying by factors based on payoff feedback (and then renormalizing). This approach is known to minimize regret and is another way to reach equilibrium. The class would take input such as how each action performed (perhaps relative to the best action), then increase or decrease the probability of actions exponentially according to their performance.
PostIterationUpdater_RegretMatching.cs – Another updater implementing Regret Matching. PostIterationUpdater_RegretMatching will use the accumulated regrets to update strategy: at each information set, it sets the next strategy’s probability proportional to the positive part of accumulated regret for each action. This is the core of CFR’s strategy update. The class likely maintains a running total of regrets and when called, computes the new mixed strategy that matches those regrets. It ensures that if an action’s regret is zero or negative, its probability is not increased.
PrincipalComponentsAnalysis.cs – Provides a PCA (Principal Components Analysis) utility, likely to analyze strategy data or outcomes. PrincipalComponentsAnalysis could be used to reduce dimensionality of a set of strategy profiles or game outcome vectors to see main variance components. In the context of ACESim, maybe used to analyze the space of strategies (for example, to see if strategies cluster or if outcomes vary mostly along a few factors). This is more of an analytical tool, computing eigenvectors of covariance matrices, etc., but included for examining simulation results or for advanced strategy synthesis.
SequenceFormPayoffs.cs – A support class for sequence form representation, holding payoff information. SequenceFormPayoffs likely contains matrices or dictionaries that map sequence profiles (one sequence choice per player) to payoffs. It might store the normal-form payoff matrix in a compressed way using sequences (which correspond to particular action paths for each player). This is crucial for the SequenceForm algorithm to build the linear constraints for each sequence. Essentially, it is the data that links strategy sequences to outcome utilities.
SequenceFormPayoffsTreeInfo.cs – Additional information linking the sequence form payoffs back to the game tree. SequenceFormPayoffsTreeInfo might map each sequence (which is an abstract concept in the solver) to actual tree nodes or information sets in the GameProgressTree. This helps interpret the results: after solving the LP, one can use this info to translate the equilibrium sequences into human-readable strategies (i.e., which actions at which info sets they correspond to). It may also be used during construction to systematically generate all sequences and their payoffs by traversing the game tree.
StrategiesDeveloperBase.cs – An abstract base class for modules that develop strategies (likely heuristically or through search). StrategiesDeveloperBase could define a workflow for improving an initial strategy, e.g., through iterative deepening, local search, or other AI techniques. Subclasses might override steps to generate new candidate strategies or refine existing ones. This base might provide utilities like evaluating a strategy’s performance, cloning strategies, or common data structures. It’s a scaffold for any custom strategy optimization procedure beyond the standard algorithms.
SymmetryMapInput.cs – Handles input mapping for symmetric games. SymmetryMapInput likely defines how to transform a game state or action from one player’s perspective to another’s. In symmetric games (where players have identical roles), one can use symmetry to reduce computation by treating symmetric situations equivalently. This class might contain rules or a dictionary mapping an information set of Player 1 to the corresponding symmetric information set of Player 2, etc. It’s used to ensure the algorithm doesn’t double-count essentially identical scenarios.
SymmetryMapOutput.cs – Complementary to the above, handling mapping of strategy or results back to original player indices. SymmetryMapOutput could take a strategy or value computed under a symmetric assumption (maybe computed for a prototype player) and replicate or translate it for each actual player in the game. Essentially, after solving a symmetric game by collapsing symmetric nodes, this class helps lift the solution back to the full game description, assigning each player their appropriate part of the symmetric strategy.
UtilitiesAndCustomResultTreeCalculation.cs – A class to compute final utilities and custom results by traversing the game tree. UtilitiesAndCustomResultTreeCalculation likely goes through all terminal nodes of the game (or simulates many plays) to calculate final payoffs for each and also to gather any custom metrics defined by the game. “Custom results” might refer to game-specific outcomes beyond just utility (for example, in the litigation game: whether the case settled or who paid what costs). This class provides a general mechanism to accumulate such results for reporting. It may be used after running simulations to produce aggregated outcomes.
UtilitiesTreeCalculation.cs – A focused class to calculate expected utilities over the entire game tree given a strategy profile. UtilitiesTreeCalculation presumably does a full tree traversal, multiplying out probabilities of each branch and summing utilities, to get the expected value for each player. This might be used to evaluate a particular strategy profile’s outcome (e.g., in solving, to check if a strategy profile is an equilibrium by verifying each player’s value against deviations). It provides the ground-truth expected payoff computation by brute-force traversal.
WalkOnly.cs – Likely an algorithm that does a random walk in the game without strategy updates, possibly for exploration. WalkOnly may simply simulate a number of random games (with players selecting actions uniformly or according to a fixed distribution) to gather data. It might be used as a baseline to compare against learning algorithms, or to generate an initial set of observations for algorithms like Deep CFR. Essentially, it “walks” through the game tree randomly without any equilibrium-finding intentions, outputting results or feeding another process.
Games (Specific Game Implementations)
This folder contains subfolders for each specific game model implemented in ACESim4. Each subfolder includes classes that derive from the core framework (GamePlay) to define the rules, decisions, and outcomes of a particular game scenario. They typically follow a naming convention and structure:
GameName – main class orchestrating that game (often subclassing the generic Game or containing game-specific logic).
GameNameDecisions – enumerates or defines the decisions in the game (could be enums or static classes listing decision types).
GameNameDefinition – extends GameDefinition to specify the game’s structure (players, actions, payoffs).
GameNameFactory – implements IGameFactory, constructing initial game state, players, and progress for that game.
GameNameLauncher – utility to launch simulations for that game with preset configurations.
GameNameOptions / OptionsGenerator – defines game-specific configuration parameters and possibly generates combinations of options for experiments.
GameNamePlayers – defines the roles or player-specific parameters for that game (e.g., Plaintiff/Defendant in litigation).
GameNameProgress – extends GameProgress with additional state or logic tailored to the game’s needs.
GameNameReportDefinition – specifies what results to collect or report for that game (which may tie into SimpleReports, selecting relevant metrics).
Additional helpers unique to the game (e.g., calculators, data structures).
Each subfolder might also include data files (like .xml inputs for scenario parameters or .efg definitions). Below are details for each game:
AdditiveEvidenceGame
A game model likely involving accumulating evidence or information with additive effects (possibly modeling a legal scenario or a contest where evidence adds up).
AdditiveActionsGameActionsGenerator.cs – Contains logic to generate the actions for the Additive Evidence game. This class likely produces the list of possible actions for each decision point (e.g., how much evidence to reveal or what move to make). It may use the game’s parameters to create a range of actions. Essentially, it automates the creation of action sets for the game’s decisions, ensuring consistency with the “additive evidence” rules.
AdditiveEvidenceGame.cs – The primary class implementing the Additive Evidence Game. It orchestrates the flow of this game where evidence is accumulated over rounds. This class likely ties together the specific decision sequence (perhaps multiple rounds of providing evidence), uses AdditiveActionsGameActionsGenerator to set up actions, and contains any game-specific logic (like how evidence values are totaled and how a winner is determined based on evidence). It probably uses the framework’s Game class functionality, but may override certain behaviors if needed for this context.
AdditiveEvidenceGameDecisions.cs – Defines the set of decisions in the AdditiveEvidenceGame. For example, it might declare an enum AdditiveEvidenceDecision with values for each point a player must choose an action (e.g., “ChooseEvidencePiece” or “BetEvidencePoints”). This makes the game’s decision structure explicit. The class could also include any static mapping from decisions to action sets (perhaps leveraging the ActionsGenerator).
AdditiveEvidenceGameDefinition.cs – Game-specific definition deriving from GameDefinition. AdditiveEvidenceGameDefinition sets up the number of players (likely 2), what the roles are, the sequence of decisions (maybe alternating evidence presentation by each side), and how payoffs are calculated (e.g., who wins given the evidence totals or differences). It also implements IGameFactory to produce new GameProgress and other components. Essentially, this class encodes the rules of how evidence adds up and affects outcomes.
AdditiveEvidenceGameFactory.cs – Implements the creation of new game instances for AdditiveEvidenceGame. AdditiveEvidenceGameFactory likely creates and initializes a fresh AdditiveEvidenceGameProgress (see below) and possibly sets default strategies for players. It ties into AdditiveEvidenceGameDefinition, using it to know what needs to be initialized. This factory is used whenever the simulation needs to start a new play of the evidence game (ensuring each run is independent).
AdditiveEvidenceGameLauncher.cs – Provides a ready-to-run launcher for this game, probably with preset options. AdditiveEvidenceGameLauncher might configure an experiment (like “run 1000 simulations of AdditiveEvidenceGame with algorithm X”) and then call into the core engine. It could parse or generate different evidence game scenarios (maybe varying some parameters) and launch them. In documentation or replication of research, this class makes it easy to reproduce results for the additive evidence model.
AdditiveEvidenceGameOptions.cs – Encapsulates configuration options specific to the evidence game. AdditiveEvidenceGameOptions might include parameters like the number of rounds of evidence, points available, costs of evidence, etc. It could also contain flags to turn on/off certain rule variations. This class is used to pass user-defined settings into the game – the AdditiveEvidenceGameDefinition would read these options to tailor the game instance.
AdditiveEvidenceGameOptionsGenerator.cs – Utility to generate combinations or random instances of AdditiveEvidenceGameOptions. This class might be used to create a range of scenarios for sensitivity analysis or to try multiple configurations. It could produce a list of AdditiveEvidenceGameOptions objects that vary key parameters (for example, varying evidence strength distributions) which can then be iterated over by the launcher to simulate each scenario.
AdditiveEvidenceGamePlayers.cs – Defines the players in the evidence game, likely their roles or any role-specific parameters. AdditiveEvidenceGamePlayers might, for instance, define Player1 as “Proponent of evidence” and Player2 as “Opponent” with possibly symmetric roles. It may set up PlayerInfo for each or assign labels used in reporting. Essentially, this class clarifies who the players are and can store any differences in their capabilities or objectives if the game is asymmetric.
AdditiveEvidenceGameProgress.cs – Extends GameProgress with state variables particular to the evidence accumulation. AdditiveEvidenceGameProgress might track the current total evidence each side has presented, whose turn it is, and whether certain thresholds have been met. For example, it could have fields like EvidencePointsPlayer1 and EvidencePointsPlayer2. It ensures that as the game plays, the additive totals are updated and final outcomes can be derived from these totals.
AdditiveEvidenceGameReportDefinition.cs – Specifies what results to capture for reporting. AdditiveEvidenceGameReportDefinition might indicate that for each simulation we record metrics such as “Who won the case”, “Total evidence by each player”, “Rounds completed”, etc. It likely integrates with the SimpleReports system by defining report columns or filters relevant to this game. This helps in generating summary tables or charts after simulations.
DMSCalc.cs – A utility/calculation class that seems related to the AdditiveEvidenceGame context (possibly an acronym, e.g., DMS). DMSCalc might perform a particular formula or algorithm used in this game’s evaluation. It could stand for something like “Discrete Marginal Scale” or be named after authors if the game is based on a paper (for instance, if DMS refers to a model by certain authors). This class likely provides functions to compute outcome values or thresholds used when determining the winner from evidence totals.
LineSegment.cs – A mathematical helper class for line segment calculations, possibly used in evaluating piecewise linear outcomes. LineSegment likely represents a segment (with two end points) and can compute intersections or intermediate values. In the evidence context, it might be used if the outcome (like probability of winning) is a piecewise linear function of evidence difference. The class would then help in computing those breakpoints and values smoothly. It may store start/end points and provide interpolation methods.
(The AdditiveEvidenceGame may utilize an external data or configuration, but none is explicitly listed. All parameters seem encapsulated in the Options classes. There is no .xml or external file here, so likely all scenario config is code-driven.)
DMSReplicationGame
This game is intended to replicate a model from a DMS study (the name suggests it's reproducing results from a specific source, possibly an academic paper or experiment abbreviated as DMS). It follows a structure similar to AdditiveEvidenceGame.
DMSReplicationGame.cs – Main class for the DMS Replication game. DMSReplicationGame orchestrates the flow of this scenario, implementing the sequence of decisions and outcomes as described in the source it replicates. It likely sets up modules or logic according to that model’s rules. Because it’s a “replication,” this class ensures that the game logic faithfully mirrors the original description (which could be about litigation, bargaining, or other game).
DMSReplicationGameDecisions.cs – Defines the decision points in the game, presumably matching those in the DMS model. DMSReplicationGameDecisions might contain an enum or constants listing each decision (e.g., “Plaintiff offer”, “Defendant respond”, etc., if it’s a bargaining model). It documents the structure of the game’s decision tree.
DMSReplicationGameDefinition.cs – The game definition for the DMS game. DMSReplicationGameDefinition sets up the players, sequence of play, and payoff calculations. It ensures that the number of players and the logic (win/lose conditions, costs, etc.) are aligned with the model being replicated. It also provides the GameFactory to create initial states. Essentially, it encodes the entire game structure from the DMS model into the ACESimBase framework.
DMSReplicationGameFactory.cs – Factory to instantiate the game’s components. DMSReplicationGameFactory creates new GameProgress, initializes any special state or players needed, and returns a ready-to-run game state for simulation. It uses the definition as a blueprint. By isolating creation here, multiple independent runs of the DMS game can be started easily.
DMSReplicationGameLauncher.cs – A launcher class to run the DMS replication simulations. DMSReplicationGameLauncher likely sets up default parameters or reads from a configuration that matches the original study. It then uses ACESim’s solving algorithms or direct simulation to produce results, which can be compared to the original (to validate the replication). This might automate running the game under various algorithms or just simulate it many times for statistical output.
DMSReplicationGameOptions.cs – Encapsulates any configurable parameters for the game. DMSReplicationGameOptions might include things like cost of litigation, probability of certain events, etc., as described in the DMS model. Having them in an options class allows tweaking scenarios or exploring alternative assumptions while using the same game logic.
DMSReplicationGameOptionsGenerator.cs – Similar to other OptionsGenerator, DMSReplicationGameOptionsGenerator can produce a set of DMSReplicationGameOptions for experimentation. Perhaps if the replication involves varying a parameter to see its effect, this class could generate that range of options systematically.
DMSReplicationGamePlayers.cs – Defines the players and their roles (and any role-specific data) in this game. DMSReplicationGamePlayers might label one player as, say, “Plaintiff” and the other “Defendant” (if it’s a litigation settlement model) or whatever roles exist in the DMS scenario. It ensures consistent reference to players across the simulation and results (so outputs can say e.g., “Plaintiff win rate” rather than Player 1).
DMSReplicationGameProgress.cs – Extends GameProgress for the state of the DMS game. DMSReplicationGameProgress will track where in the sequence the game is (e.g., which decision is next), plus any accumulated information (like offers made, whether a settlement was reached, etc.). It could also track metrics needed at game end (like who wins, payoffs). This specialized Progress class implements any state transitions unique to the DMS model that the generic GameProgress can’t cover alone.
DMSReplicationGameReportDefinition.cs – Specifies what outputs are of interest for the DMS game. DMSReplicationGameReportDefinition might instruct to report metrics like settlement rate, trial outcomes, average offers, etc., depending on what the original study focused on. It likely sets up those columns in the reporting system so that after simulations one can easily extract those statistics.
(No extra data files appear in this folder; the game is self-contained with its options class. Being a replication, it likely uses hard-coded parameters from the original source via the Options.)
EFGFileGame
A game loaded from an external Extensive Form Game (.efg) file. This allows ACESim to run arbitrary games defined in that format (commonly used by the Gambit software or other game theory tools). The classes in this folder handle parsing the file and simulating the described game.
EFGFileChanceInformationSet.cs – Represents a chance node’s information set read from the .efg file. In an .efg, chance moves are given as special information sets for nature. EFGFileChanceInformationSet likely stores the probabilities and outcomes of a chance node as defined in the file. It extends a general information set structure with probability distribution data for the chance outcomes.
EFGFileGame.cs – The primary game class for an imported .efg game. EFGFileGame sets up the simulation of the extensive-form game described by an input file. It uses other classes in this folder to build the game tree: reading the file’s specification of players, moves, information sets, and outcomes. Once constructed, it behaves like any other Game: it can simulate play-throughs, etc., except the structure comes from data rather than hard-coded logic. This class likely holds references to all information sets and outcomes from the file to coordinate gameplay.
EFGFileGameDefinition.cs – A GameDefinition implementation that reads the .efg data. EFGFileGameDefinition parses the .efg file (via EFGFileReader) and populates the ACESimBase structures (players, actions, information sets, outcomes). It essentially converts file data into GameDefinition fields and implements IGameFactory to produce game states for simulation. This class abstracts the raw file so that the rest of the engine can treat the imported game like any other.
EFGFileGameFactory.cs – The factory for creating instances of the game from the .efg file. EFGFileGameFactory uses the parsed EFGFileGameDefinition to generate new GameProgress and related objects. It ensures that each simulation run starts with a clean state reflecting the structure from the file. This might involve setting initial chance seeds or other one-time setups defined in the file (like drawing initial private information if the game definition includes it).
EFGFileGameLauncher.cs – A launcher to run an EFG file-defined game. EFGFileGameLauncher presumably takes as input the path or name of an .efg file (perhaps specified in GameOptions or as a parameter) and then uses ACESim’s solving algorithms or direct simulation to analyze that game. It allows users to plug in a new game file and quickly simulate it without writing new code for that game’s logic – simply by launching via this class.
EFGFileGameMove.cs – Represents a single move (action) as defined in the .efg file for a particular information set. EFGFileGameMove likely stores properties such as the move’s name/label, the next information set or outcome it leads to, and possibly the utility if it directly leads to a terminal node. This class is used by the simulation to enumerate and execute actions available at each information set as imported from the file.
EFGFileGameOptions.cs – Options specific to running an .efg game. EFGFileGameOptions probably includes the filename or resource name of the game to load, and maybe flags like “interpret chance as deterministic” or other toggles for how to handle the file. These options allow the user to specify which .efg game to run and any special handling needed (for example, some .efg files might contain chance in certain formats).
EFGFileGameProgress.cs – A specialized GameProgress for tracking state while running an .efg-defined game. EFGFileGameProgress likely doesn’t have game-specific state (since the game’s state is generic as per the file) but it may contain pointers to the current node or information set in the imported structure. Essentially, it keeps track of where we are in the externally defined game tree (which info set or chance node currently, which actions have been taken so far). It might store the current information set ID and the history of moves indexes.
EFGFileInformationSet.cs – Represents a player’s information set as described in the .efg file. EFGFileInformationSet stores data like which player it belongs to, a list of moves (usually the file will list the moves available at that info set), and possibly an ID or label. It may also link to the EFGFileInformationSetNode in the tree structure. This class is central to navigating the game as it’s the basis for what actions a player can take given what they know.
EFGFileInformationSetID.cs – A small struct or class to identify information sets uniquely (maybe combining player and a number). EFGFileInformationSetID ensures each info set from the file can be referenced easily in dictionaries or maps. It might override equality for (player, infoSetNumber) pairs. This helps in connecting moves and outcomes to the right info set object.
EFGFileInformationSetNode.cs – Perhaps represents a node in the game tree tied to an information set. EFGFileInformationSetNode could correspond to a particular game state that lies in a given information set. In extensive form, multiple game states (histories) can belong to the same information set for a player. This class might store the set of histories (or a representative) for the info set and link to child nodes (following each possible move). It’s used to actually simulate moving through the tree while respecting the information structure.
EFGFileNode.cs – Represents a generic node in the imported game’s tree (could be decision or chance). EFGFileNode likely has references to either an EFGFileInformationSet (if it’s a player decision node) or an EFGFileChanceInformationSet (if a chance node), as well as links to its child nodes. It may also hold a pointer to its parent and which move was taken to get here. This is the fundamental element of the game tree built from the file.
EFGFileOutcomeNode.cs – Represents a terminal node/outcome in the .efg game tree. EFGFileOutcomeNode stores the payoff for each player at this outcome (as specified in the file). It might also have an outcome label or ID if the file provides one. During simulation, reaching an EFGFileOutcomeNode means the game ends, and this class provides the utilities to the players which the simulation can record. This class is critical for connecting the gameplay to result reporting, as it carries the final payoffs.
EFGFileReader.cs – Parses the .efg file format and constructs the in-memory representation. EFGFileReader likely contains the file reading logic: it opens the given .efg file, reads through the syntax (players, info sets, moves, outcomes), and creates corresponding EFGFile... objects for each element. It must handle the hierarchical structure described in the file and produce a structured set of objects that EFGFileGameDefinition can then use to initialize the game. Essentially, this is the translator from text file to ACESim objects.
bayes1a.efg (data file) – An example Extensive Form Game file included in the repository. bayes1a.efg is likely a sample game (perhaps a Bayesian game example) that can be loaded by EFGFileGame. It’s a text file describing players, their possible moves, chance events, and payoffs. This file can be used with EFGFileGameOptions by specifying its name, allowing the ACESim engine to simulate the game defined by this file.
pennies.efg (data file) – Another example .efg game file, possibly describing the classic Matching Pennies game or a similar simple game. Like bayes1a.efg, this file can be loaded to create a game instance. It serves as a test or demonstration of the EFG import capability. By providing these sample .efg files, the repository allows users to try out the engine on known game examples or to verify that the parser and engine are working correctly.
(The two .efg files are notable non-code files demonstrating the usage of the EFGFileGame. They are important for testing and understanding how external game definitions can be integrated.)
LeducGame
A specific implementation of the Leduc Hold’em poker game, a common two-player limit betting poker used in AI research. It involves a deck of cards and two rounds of betting. The LeducGame folder contains a detailed model of this poker variant:
LeducBettingRound.cs – Contains logic for a betting round in Leduc poker. LeducBettingRound likely manages the sequence of bets and actions (bet, call, raise, fold) within one betting phase. Leduc has two betting rounds (one pre-flop with one private card each, and one post-flop after a community card is revealed). This class probably encapsulates the state and progress of one such round: whose turn, how much has been bet, and when the round ends (e.g., when all players have either called or folded).
LeducChoiceRecord.cs – A structure to record a specific choice (action) made by a player, possibly with context. LeducChoiceRecord might store which player made the choice, what the action was (fold, call, raise, etc.), and maybe the betting amount if applicable. It helps log the actions taken in the game history, especially since betting can involve amounts. This record can be used to reconstruct what happened in a round or to apply those actions to update the pot and player chips.
LeducChoiceStage.cs – Likely defines different stages of choices in the game. In Leduc, players might have distinct stages: one to decide whether to fold or bet when it’s their turn, another stage for the next round’s decisions. LeducChoiceStage could enumerate or classify these stages (e.g., “Pre-FlopAction”, “Post-FlopAction”) to clarify the game progression. Alternatively, it might coordinate multiple choice points (like first to act vs second to act) within a single round.
LeducGame.cs – The main class controlling the Leduc Poker game. LeducGame implements the overall flow: dealing cards, running the first betting round, revealing the public (community) card, then the second betting round, and finally determining the winner and payoff (based on hand strength and pot). It uses LeducGameProgress for state, and interacts with LeducBettingRound to manage bets. This class ensures the sequence of events follows poker rules and that all necessary information (private cards, public card) is properly handled.
LeducGameDecisions.cs – Enumerates the decision points in Leduc. LeducGameDecisions likely lists something like: Decision 1: First betting round decision for Player1, Decision 2: First betting round decision for Player2, Decision 3: Second betting round decision for Player1, etc. It formalizes the decision indices or names which the framework uses to step through the game. This makes the integration with the generic engine possible by mapping generic ActionPoints to the actual poker decisions.
LeducGameDefinition.cs – The GameDefinition subclass for Leduc. LeducGameDefinition sets up the two players, the deck of Leduc cards (there are a small number of cards in Leduc, typically 6 cards with 2 suits or similar), and defines the structure of rounds and decisions. It also likely contains the logic to compare hands at showdown (to determine winner if no one folds) and the payoff calculation (usually the pot to the winner). The GameDefinition might also create the LeducGameFactory and has routines to deal initial cards and the community card.
LeducGameFactory.cs – Factory to create new instances of a Leduc game run. LeducGameFactory will initialize a LeducGameProgress (dealing cards randomly for that run), instantiate players with their private info (cards), and set up any other initial conditions (like starting pot, initial bettor). It ensures each play-through of Leduc starts fresh with a shuffled deck and no prior history. This factory is called for each simulation or hand that is played.
LeducGameInputs.xml (data file) – An XML file containing configuration for the Leduc game. LeducGameInputs.xml likely specifies game parameters such as the deck composition, blinds or ante amounts, and possibly the mapping of card notations. It may define the ranks of cards or the suit order. The LeducGameDefinition or Factory probably reads this XML to configure the game (for example, if one wanted to tweak the deck size or initial chip stacks, they might do so via this file).
LeducGameLauncher.cs – A launcher to simulate Leduc poker games. LeducGameLauncher probably sets up either self-play or algorithmic analysis of Leduc. It could run a series of random hands to compute empirical frequencies or feed the game into a solving algorithm (like CFR, which is famously applied to Leduc in literature). This class would handle looping over many hands, maybe train a strategy, and collect statistics like win rate, average winnings, etc.
LeducGameOptions.cs – Contains customizable options for Leduc. LeducGameOptions might include number of iterations to run, whether to use fixed card deals (for reproducibility), or toggles for verbose logging of each hand. It could also capture any rule variations (if, say, one wanted to experiment with different betting limits or a third betting round – though standard Leduc has two). These options make the simulation flexible for research.
LeducGamePlayers.cs – Defines the players in Leduc (likely just Player 1 and Player 2, with identical roles apart from position). LeducGamePlayers might not have much differentiation since both players have the same actions available, but it may tag one as the dealer and one as the big blind if applying those concepts. This could affect who acts first in each round. The class ensures roles like “dealer” are assigned each hand (often Leduc alternates dealer).
LeducGameProgress.cs – Extends GameProgress with poker-specific state tracking. LeducGameProgress will keep track of dealt cards (each player’s private card and the public card), the current pot size, bets in the current round, and which betting round is active. It also tracks if any player has folded (which immediately ends the hand). This progress state is essential for making decisions (e.g., a player’s strategy might depend on their card and the public card). After each betting round, it resets some variables and prepares for the next. At showdown, it stores the result (e.g., winner and hand comparison outcome).
LeducGameState.cs – Possibly an abstraction of the state (cards and bets) at any point. LeducGameState might represent the public state visible to all players (like bets placed, public card) separate from LeducGameProgress which might include private info. This class could be used for constructing information sets or for reporting. It might also contain helper methods to encode the state (e.g., as inputs for neural networks, if using AI).
LeducPlayerChoice.cs – Represents a single player’s decision in the game, possibly with context of the action. LeducPlayerChoice might encapsulate something like “Player X chooses to Bet in round 1”. It could be used to structure the strategies or to log outcomes. There might be logic to evaluate the consequence of that choice (like deducting chips, updating the pot). Essentially, this class couples a player’s identity with a specific action choice made.
LeducPlayerChoiceWithoutFold.cs – Perhaps a variant of LeducPlayerChoice used in scenarios or strategy considerations where folding is not considered (or not available). LeducPlayerChoiceWithoutFold might be used for information sets after a certain point where a fold can’t occur (for instance, if we’re considering strategies conditional on no one folding in the first round). It may help simplify strategy representation by excluding the fold action in certain subgames, thereby focusing analysis on betting behavior.
LeducTurn.cs – Likely manages whose turn it is and turn progression. LeducTurn class could coordinate the alternation of actions between players in each betting round. In two-player games, turns alternate until a round ends. This class might encapsulate the logic for moving the action to the next player, handling the case when one player’s action ends the round (like a call closing the betting). It ensures the correct sequence of play order is followed.
(In summary, the LeducGame implementation is quite detailed, reflecting the complexity of poker rules. The presence of an XML input for card setup and multiple helper classes indicates an attempt to make the game both accurate and possibly configurable. The classes together handle dealing, betting logic, turn-taking, and showdown resolution for this simplified poker game.)
LitigGame
This folder contains a comprehensive model of a litigation game, likely modeling the legal process (with features like filing a case, settlement negotiations, trial, side bets, etc.). It’s a complex game, reflected by its multiple subfolders for different aspects of the litigation process. The LitigGame is probably the central model of the project (“Modeling Fee Shifting With Computational Game Theory” suggests a legal dispute model). Main LitigGame classes:
LitigGame.cs – The main class orchestrating the litigation game. LitigGame coordinates the phases of a lawsuit: it likely includes pre-trial negotiation, possibly signaling (like a plaintiff’s demand or a defendant’s signal of strength), trial (if it occurs), and outcome determination (win/lose and costs). It uses many support classes to handle each part of this process but serves as the top-level integrator. It ensures the decisions happen in the right order and that the game terminates with either a settlement or a trial verdict.
LitigGameActionsGenerator.cs – Generates the available actions at various litigation decision points. LitigGameActionsGenerator likely creates lists of possible offers, responses, or other moves (like whether to go to trial or settle) at each stage. For example, it might generate a set of possible settlement offers a plaintiff can make or possible signals a defendant can send. By encapsulating this, the game logic can easily adjust ranges of offers or probability distributions without hardcoding them in the main game class.
LitigGameDecisions.cs – Enumerates the decision points in the litigation game. LitigGameDecisions defines something like: Offer stage, Response stage, Side-bet decision, etc., aligning with the moves players make. Each entry corresponds to an ActionPoint in the game timeline. This makes the structure explicit so that LitigGameDefinition knows the sequence of moves and the engine can iterate through them.
LitigGameDefinition.cs – The GameDefinition for litigation. LitigGameDefinition sets up the players (e.g., plaintiff and defendant), defines all phases of the game (what decisions are made and by whom), and how outcomes/payoffs are determined. Payoffs likely involve whether plaintiff wins, legal costs incurred, any side bets payouts, etc. This class integrates subcomponents like dispute generation (to get case merits), options (like fee shifting rules), and it uses them to create a game that the engine can play. It also implements IGameFactory to produce game instances initialized with a random dispute scenario.
LitigGameFactory.cs – The factory that builds a fresh litigation game instance. LitigGameFactory uses LitigGameDefinition to generate a new LitigGameProgress with a random case scenario (through dispute generators), assigns any initial actions (like an initial filing decision perhaps), and returns the ready GameProgress. It ensures each simulation has a new dispute context (quality of case, etc.) so that the strategy needs to adapt to underlying case merits.
LitigGameLauncher.cs – A launcher to run simulations of the litigation game. LitigGameLauncher probably ties together typical scenarios to test, runs the game under specified strategy algorithms or simulations, and collects outcomes. For example, it might run many iterations to estimate equilibrium settlement rates or run different fee-shifting rules (an option) to see their effect. It likely uses LitigGameOptionsGenerator to iterate through variations (like English Rule vs American Rule for legal fees, etc.).
LitigGamePlayers.cs – Defines the roles of the players (commonly Plaintiff and Defendant). LitigGamePlayers sets up any player-specific parameters such as risk preferences or resource constraints if applicable. It clearly labels player 1 as one side and player 2 as the other, which is used throughout the game logic and reporting (so we can say "plaintiff’s utility" rather than "player 1’s utility"). There might not be asymmetric rules beyond naming, but if, say, only the plaintiff can make the initial offer, that is encoded via these role distinctions.
LitigGameProgress.cs – Extends GameProgress to maintain the state of an ongoing lawsuit simulation. LitigGameProgress is likely quite complex: it keeps track of the randomly generated dispute parameters (like the merits/quality of the case, perhaps drawn from DisputeGeneration), any signals sent, any settlement offers and responses, whether a settlement was reached, and if not, the trial outcome. It might also accumulate costs incurred by each party through the process. This Progress object is the hub that all decision-making components refer to in order to know the current state (e.g., what offer was made, whether a side bet exists, etc.).
LitigGameProgress_PostGameInfo.cs – A supplemental class to collect post-game information after a litigation game concludes. This likely holds data like: did the case settle or go to trial, how much each party spent, what was the plaintiff’s private signal, etc. Essentially, anything about the realized scenario that might not be directly part of payoff but is useful for analysis (for example, to correlate signals with outcomes). LitigGameProgress_PostGameInfo packages these details once the game is done, probably for reporting purposes (to output detailed case-by-case results or to feed manual reports).
LitigGameReportDefinition.cs – Specifies the results metrics to record for litigation games. LitigGameReportDefinition likely indicates reports such as settlement rate, average settlement amount if settled, fraction of plaintiff wins at trial, average litigation cost for each side, etc. It defines what data from LitigGameProgress or PostGameInfo should be extracted into summary statistics. This ties into the SimpleReports system so that after running many simulations, one can produce structured output (tables/graphs) for these metrics.
MyGameInputs.xml (data file) – An XML file likely containing default input values or parameters for the litigation game. This could include default distributions for case quality, legal costs, maybe parameters for side bets or signals. It might be a user-editable file to tweak the scenario without recompiling code. The game might read this on startup to load, for example, the mean and variance of damage awards or other such exogenous inputs for dispute generation. Essentially, it is a configuration file for the LitigGame, possibly loaded by LitigGameFactory or DisputeGeneration classes.
Subfolders in LitigGame:
DisputeGeneration/ – This subfolder contains classes that generate disputes/cases for the litigation game. These classes create the initial scenario (e.g., the type of case, the merits, the potential damages):
ILitigGameDisputeGenerator.cs – Interface defining the contract for a dispute generator. ILitigGameDisputeGenerator declares a method (perhaps GenerateDispute()) that returns a randomly generated dispute instance (containing attributes like case quality, damages, etc.). Different implementations correspond to different types of cases.
LitigGameAppropriationDisputeGenerator.cs – Implements dispute generation for an appropriation case scenario. This class would create a case where the legal dispute is about appropriation (e.g., someone taking property), with parameters suited to that context (perhaps how strong the evidence is, likely damages). It ensures that the dispute characteristics (strength, signal distributions) match what an appropriation case would look like.
LitigGameContractDisputeGenerator.cs – Dispute generator for contract cases. LitigGameContractDisputeGenerator provides random case details specific to contract disputes (e.g., breach of contract scenarios). It might define a distribution for damages (contract value) and likelihood of breach evidence. The idea is to simulate a case in this category with realistic parameter ranges.
LitigGameDiscriminationDisputeGenerator.cs – Generator for discrimination cases. This class creates a scenario involving alleged discrimination (e.g., employment discrimination). It would set up the strength of evidence or quality of the case in a way reflecting discrimination suits, and any special considerations (like statutory caps on damages or likelihood of punitive damages).
LitigGameDisputeGeneratorActions.cs – Possibly a support class that consolidates how dispute generation ties into game actions. LitigGameDisputeGeneratorActions might not generate disputes itself but could generate initial actions based on the dispute (for instance, whether the plaintiff files the case might depend on the dispute quality). Alternatively, it could simply coordinate between different dispute generators or select which generator to use based on game options.
LitigGameEqualQualityProbabilitiesDisputeGenerator.cs – A specialized generator that might treat all dispute qualities as equally likely. LitigGameEqualQualityProbabilitiesDisputeGenerator could ignore empirical distributions and just uniformly sample case strength. This might be used for theoretical analysis or debugging, where one wants to assume no bias in the distribution of cases. It ensures every case quality level has equal probability.
LitigGameExogenousDisputeGenerator.cs – Possibly a generator that takes dispute characteristics as exogenous input (maybe from MyGameInputs.xml) rather than randomly generating them. LitigGameExogenousDisputeGenerator could read predetermined sequences or distributions of disputes (making the simulation scenarios externally controlled). It allows using real-world data or user-specified scenarios as the input for simulation rather than a purely random model.
LitigGameNegligenceDisputeGenerator.cs – Generator for negligence cases. LitigGameNegligenceDisputeGenerator would create a scenario typical of negligence tort cases (like accidents). It likely sets up variables such as probability of plaintiff victory (depending on negligence evidence) and expected damages if the plaintiff wins. Each generated dispute would have a “merit” reflecting how clear-cut the negligence is.
Together, the DisputeGeneration classes allow the litigation game to sample a diverse set of legal disputes. The game can thus simulate a mixed caseload or focus on one type by selecting the appropriate generator. They feed into the game by initializing case-specific parameters before the strategic decisions (like offers or trial) begin.
ManualReports/ – Contains classes for custom, manually-coded reports specific to the litigation game. These go beyond the automated SimpleReports by computing detailed outputs:
SignalOfferReport.cs – Generates a Signal vs. Offer report. SignalOfferReport likely analyzes the relationship between the defendant’s private signal and the settlement offers made. It might produce a table or dataset showing, for each range of defendant signals (case strengths), what settlement offer was proposed or whether the case settled. This can illuminate how information asymmetry (signals) influences negotiation outcomes.
StageCostReport.cs – Produces a report on costs incurred at each stage of litigation. StageCostReport probably tallies the legal costs for pre-trial vs. trial for each case or on average. For example, it might output the average attorney fees spent in cases that settled vs. those that went to trial. This report helps understand the cost efficiency of the legal process under various strategies or rules, which is often a key focus in litigation models (especially if modeling fee-shifting).
Options/ – This subfolder encapsulates classes related to game options and rule variations specifically for the litigation game (e.g., fee shifting rules, settlement rule toggles, warm-start strategies):
DeltaOffersCalculation.cs – Handles calculations for delta offers (differences in offers). DeltaOffersCalculation likely computes adjustments or comparisons between multiple rounds of offers. For example, if the model allows multiple alternating offers, this class could determine how a defendant’s counteroffer compares to the plaintiff’s initial offer (the “delta”). It might be used to implement strategies like “split the difference” or to inform how offers update over time.
DeltaOffersOptions.cs – Configurations related to the Delta Offers process. DeltaOffersOptions might allow enabling or disabling the use of delta adjustments in the negotiating strategy, or set parameters for how aggressive those adjustments are. If the game can be played with or without certain negotiation heuristics (like anchoring on the first offer), this class would capture that choice.
LitigGameOptions.cs – The main options class for the litigation game. LitigGameOptions includes key rule settings such as whether fee-shifting is in effect (e.g., English Rule vs. American Rule), whether side bets are allowed, number of negotiation rounds, information structures (e.g., is defendant’s signal private or shared), and so on. By adjusting these options, one can simulate different legal regimes or game variants. This class is used by LitigGameDefinition and others to modify the game logic based on scenario.
LitigGameOptionsGenerator.cs – Generates sets of litigation game options for experimentation. LitigGameOptionsGenerator likely creates a list of LitigGameOptions combinations, for example: one with American Rule (each pays own fees) and one with English Rule (loser pays winner’s fees), possibly crossed with side-bet on/off. This allows the Launcher to run the game under each regime and compare outcomes. It automates exploring the option space.
LitigGameWarmStartOptions.cs – Options related to warm-starting strategies or simulations in the litigation game. LitigGameWarmStartOptions might specify if the simulation should begin with some precomputed strategy or equilibrium (to save time reaching steady state), or if some values (like initial beliefs) are seeded from analytical solutions. Warm-starting can speed up convergence of learning algorithms by starting them near an expected solution. This class would carry any parameters or flags needed to enable that behavior.
PretrialDecisions/ – Classes focused on pre-trial decisions that are part of the game (aside from settlement offers). These might include whether to file a case, invest in legal resources, or make side bets:
ILitigGamePretrialDecisionGenerator.cs – Interface for generating pre-trial decision events. ILitigGamePretrialDecisionGenerator probably outlines methods for creating decisions that occur before the main negotiation/trial, such as whether parties engage in discovery, motions, or side bets. Implementations would then create specific decision instances.
LitigGamePretrialActions.cs – Likely enumerates or manages the possible pretrial actions. LitigGamePretrialActions could list actions such as “File Suit” (for plaintiff), “Motion to Dismiss” (for defendant), or “Invest in Evidence”. It defines what actions are considered part of the pretrial phase and possibly their outcomes (e.g., a motion might end the case early if successful). This class informs the game of what extra decisions to consider at the start.
LitigGameSideBet.cs – Manages running side bets between parties. LitigGameSideBet probably represents an arrangement where the two sides place a wager on the trial outcome (often a modeling trick to induce certain equilibria or to simulate fee shifting by different means). This class would handle the terms of the bet and how it’s settled depending on who wins the trial. In the game’s logic, if side bets are allowed (controlled by options), an instance of this might be created and influence payoffs (essentially transferring some amount from loser to winner outside of the court’s judgment).
RunningSideBets/ – This subfolder specifically covers the scenario where parties engage in side bets during the litigation process:
LitigGameRunningSideBets.cs – Handles the logic when side bets are active throughout the litigation. LitigGameRunningSideBets might track whether a bet was made and update the game’s outcome accordingly. It could integrate with both the negotiation and trial phases by adding or subtracting the bet amount from payoffs. This class likely works closely with LitigGameSideBet and could encapsulate repeated betting or adjusting bet amounts as the case evolves.
LitigGameRunningSideBetsActions.cs – Generates or defines actions related to side bets. LitigGameRunningSideBetsActions could specify that at certain points (e.g., after a signal or before trial), parties can offer a bet or accept/decline a bet. It would list those actions (e.g., “OfferSideBet”, “AcceptSideBet”, “NoBet”) and possibly any parameters for the bet. This ensures the game includes side bet decisions in the sequence of play when that feature is enabled.
In summary, the LitigGame and its sub-components provide a rich and configurable model of the litigation process. By toggling options and using different dispute generators, one can simulate how cases might resolve under various legal rules (fee shifting or not), with different case types, and even explore concepts like parties insuring against trial risk (side bets). The classes are designed to separate concerns: dispute generation is separate from negotiation logic, which is separate from reporting. This modular design allows analyzing the impact of each piece (e.g., how dispute quality distribution affects settlement rates, or how fee shifting affects side bet behavior).
Resources (Embedded Resources and External Libs)
The Resources folder contains non-source assets used by ACESimBase, such as schema definitions and external libraries required at runtime:
Settings.xsd – An XML Schema Definition for configuration settings. This file, Settings.xsd, likely defines the structure of certain XML settings files used in the project (perhaps the *GameInputs.xml files or other config files). It prescribes what XML elements and types are expected, ensuring that inputs conform to the required format. For example, it might specify that in LeducGameInputs.xml, there must be elements for <Deck> and <Blinds>. This helps with validation and documentation of configuration files.
System.Data.SqlServerCe.Entity.dll – An assembly (DLL) included with the project, likely to support SQL Server Compact Edition (CE) entity framework usage. The presence of SqlServerCe libraries suggests that ACESim might have the capability to store results or intermediate data in a compact database file for later analysis. These DLLs are Microsoft’s libraries for database operations on a lightweight SQL CE database. They are included in Resources so that if the program needs to use a database (for example, to log simulation results persistently or to retrieve large data sets for analysis like machine learning training data), it has the required drivers.
System.Data.SqlServerCe.dll – Another DLL for SQL Server Compact core functionality. This provides the engine for the compact database. Together with the Entity DLL, it would allow ACESimBase or related projects to create a .sdf (SQL CE database file) and perform CRUD operations. In context, ACESim might not use it directly in ACESimBase code (there’s no explicit .cs for database), but possibly the test or console projects use it to store experiment results. Regardless, its inclusion in ACESimBase’s resources means any component can invoke local database operations if needed (for example, storing millions of self-play histories might be done via a database to manage memory).
(These resources are supporting files; they don’t contain gameplay logic but provide infrastructure. Settings.xsd ensures robust config management, and the SQL CE libraries enable optional data persistence features.)
SimpleReports (Reporting Framework)
The SimpleReports namespace provides a lightweight framework for collecting and filtering simulation results into human-readable reports or data tables. This is used across games to output statistics without hard-coding print statements. Key classes include:
ColumnVariableOptions.cs – Defines options for report variables that vary across runs. ColumnVariableOptions might specify which game parameter or metric is treated as a variable column in a report. For example, if generating a table where each column is a different fee-shifting rule, this class could capture that the “FeeShiftingRule” option is a column variable, and list the values (American, English). It helps the report generator know how to pivot data.
ReportCollection.cs – A container for multiple reports. ReportCollection can hold several SimpleReport instances, possibly one for each combination of certain variables or for each type of output. It provides methods to add results to the appropriate report and then to output or retrieve all reports at once. This class allows grouping related reports (for instance, one collection could include settlement rate report, cost report, and utility report for the litigation game).
SimpleReport.cs – Represents a single simple report, essentially a table of results. SimpleReport tracks rows of data, each row corresponding to a particular experimental condition or run, and columns for various metrics or outcome statistics. It likely provides methods to add a data point (with associated keys for grouping variables), and internally aggregates data if needed (like computing averages). In the end, it can output the data in a formatted way (CSV, console table, etc.). Many games use this to accumulate simulation outcomes in a structured form.
SimpleReportColumnFilter.cs – Allows filtering which columns appear in a report. SimpleReportColumnFilter might be used to include or exclude certain result metrics depending on user interest. For instance, one might only want to see payoff-related columns and filter out debugging metrics. This class likely holds criteria or a list of allowed column names that SimpleReport or ReportCollection will use to decide what to output.
SimpleReportColumnFilterOptions.cs – Options for specifying filters on report columns. SimpleReportColumnFilterOptions could contain booleans or patterns to easily configure SimpleReportColumnFilter. Instead of hard-coding column lists, this allows, say, a config file or command-line switch to choose to hide intermediate metrics or show detailed ones. For example, an option could be “ShowTrialDetails = true/false” that then the filter uses to include or drop columns like trial duration, etc.
SimpleReportColumnItem.cs – Represents a single column in a report, with its associated data or configuration. SimpleReportColumnItem may store the column’s name, its data type, format (like how to print it), and possibly a function or reference to how to compute it from raw simulation data. This class is used by SimpleReportDefinition to define what each column means and by SimpleReport to hold the actual values for each row under that column.
SimpleReportColumnVariable.cs – Represents a variable that distinguishes different reports or rows. SimpleReportColumnVariable could be something like “Fee Rule” or “Case Type” which can vary between simulations. This class would identify that variable and possibly hold the set of values it can take. It’s used to pivot or categorize results. For example, if the simulation is run for multiple case types, this variable ensures the report separates results per case type.
SimpleReportDefinition.cs – The blueprint for constructing a specific report. SimpleReportDefinition defines which columns are included (likely by creating SimpleReportColumnItem instances for each metric of interest), which variables are considered (creating SimpleReportColumnVariable), and how data is mapped into the report structure. In games like LitigGame, the *GameReportDefinition.cs (e.g., LitigGameReportDefinition) probably extends or uses this to specify particular metrics. This class generalizes that process so the reporting engine knows what to record and display.
SimpleReportFilter.cs – Encapsulates filtering logic for report rows. While SimpleReportColumnFilter was about columns, SimpleReportFilter might filter rows (for example, only include runs where a certain condition holds). It could also combine multiple criteria including both row and column filters. This might be used if one wants to focus on, say, only those simulations where the case went to trial, or only the results for one player. It prunes the dataset for focused analysis.
SimpleReportMerging.cs – Provides functionality to merge multiple reports or data sets. If simulations are run in parallel or separately for different conditions, SimpleReportMerging can combine their outputs into a single coherent report. It likely matches on common variables and appends data accordingly. This is useful if, for example, one runs part of the experiment at one time and the rest later – their results can be merged. Or if one has separate SimpleReport instances (maybe one per repetition) and wants an aggregated report.
Strategies (Strategy Representation)
This namespace handles how strategies (the mapping from information sets to actions) are represented, manipulated, and stored. It is critical for solving algorithms which need to maintain and update strategy profiles:
Decision.cs – Likely defines a Decision object or struct, representing a single decision point (information set) within a strategy context. Decision could hold identifiers for the info set, possibly the probabilities of each action (or references to them), and any metadata like whether it’s a chance or player decision. This class is probably used in strategy serialization or analysis, to refer to “the decision at node X with these probabilities”.
IStrategiesDeveloper.cs – An interface for classes that develop strategies (through some algorithm or heuristic). IStrategiesDeveloper likely declares methods like ImproveStrategy(Strategy current) or GenerateStrategy(). It sets a contract for any class that takes an existing strategy profile and tries to improve or modify it, possibly using iterative methods. Classes implementing this might wrap algorithms from GameSolvingAlgorithms in a different interface or might implement custom heuristics for initial strategy guess, etc.
Strategy.cs – Represents a strategy profile (probably for a single player) in the game. The Strategy class most likely contains the probabilities for each action at each information set for one player. It could be implemented as a mapping from Decision (or info set ID) to a distribution over actions. It would provide methods to get or set the probability of a specific action, to update probabilities (like regret-matching updates), and possibly to sample an action given the strategy. It might also hold a reference to the GameDefinition to know how many decisions there are and how to index them.
StrategySerialization.cs – Provides methods to serialize and deserialize strategy profiles. StrategySerialization could convert a Strategy object into a compact string or binary form (for example, to save to a file or to embed in a report). It may handle both writing out the strategy in a readable format (e.g., listing probabilities for each info set) and reading it back. This is useful for analyzing final strategies, sharing them, or warm-starting algorithms with a previously saved strategy.
StrategyState.cs – Captures the state of a strategy possibly in the context of an iterative algorithm. StrategyState might store not just the strategy (probabilities) but also cumulative information like regrets or iteration counts associated with that strategy. It could be used by StrategiesDeveloperBase or solving algorithms to checkpoint the state of an ongoing strategy development process. Alternatively, it might represent the state of multiple players’ strategies combined (i.e., a strategy profile for the whole game). It likely has fields to hold each player’s Strategy and any other stateful info needed to resume computations.
Overall, the Strategies classes allow the program to handle strategies abstractly – create them, modify them, and save/load them – which is essential for running and analyzing the game-solving algorithms (since those revolve around strategy profiles evolving towards equilibrium).
Conclusion: The ACESimBase directory is structured to separate the concerns of game definition, simulation runtime, algorithmic solving, and result reporting. Important files like game definitions (e.g., LitigGameDefinition, LeducGameDefinition), game progress classes (e.g., LitigGameProgress, LeducGameProgress), and algorithm implementations (e.g., CounterfactualRegretMinimization, DeepCFR) contain the core logic for modeling and solving the games of interest, and thus are described in greater depth above. Utility and support files (such as those in GameSolvingSupport and Util) provide the necessary computational scaffolding (from data structures to math helpers) that enable the core logic to run efficiently. By understanding the role of each file, one can navigate the codebase effectively and modify or extend the simulation and algorithms for new research questions or game scenarios.