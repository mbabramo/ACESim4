using ACESim.Util;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Reflection;
using System.IO;
using Tensorflow;
using static TorchSharp.torch;
using ACESimBase.Util.NWayTreeStorage;
using ACESimBase.Util.Parallelization;
using ACESimBase.Util.Debugging;
using ACESimBase.Util.CodeGen;

namespace ACESimBase.Util.ArrayProcessing
{
    [Serializable]
    public partial class ArrayCommandList
    {

        // TODO: (1) Right now, we have a mechanism (KeepCommandsTogether) that prevents us from breaking into a new command chunk within
        // an if statement. A better alternative would be to store the value of the condition and create a child that will execute if and
        // only if the condition is true. That is, the Execute... method in autogenerated code would return a bool indicating whether we
        // should Skip the node, and then we would use the Skip feature (tentatively implemented below) to skip the relevant code if
        // necessary. (1b) This could result in too many command chunks. We might then want to create a new command chunk only below
        // some parallelism depth. 
        // (2) We avoid repeating identical sequences of commands by referring to the earlier command chunk. But we would also like to
        // create a mechanism that allows us to generate similar sequences of commands, differing only in the relevant ordered source
        // indices and/or ordered destination indices. For example, we could specify a function that would translate ordered source
        // indices or ordered destination indices, so that we could load data or save data back to similar but distinct information sets.
        // For example, if we have a two round bargaining game, then we might want to use essentially the same code for the second round
        // of the bargaining regardless of how we ended up in the second round. If we could bracket an entire round of decisions, that
        // would greatly reduce the size of the tree and allow us to have more rounds (though still at considerable cost with regard 
        // to execution). Probably the way this would work would be to have a section of code where an original target is 
        // incremented by some value. That is, every set of round 1 information sets would be immediately be followed by round 2
        // information sets that follow it, except that each such information set would be followed by the following round 3 
        // information sets. The algorithm should thus be the same except for such values and (critically) for the final utilities,
        // whether the bargaining round leads to settlement or not. We would thus also need the final utilities values to be
        // set up in the same way, but this would require significant manual setup work, especially if the goal is to be able to
        // avoid playing every permutation of the game.
        // (3) Can we avoid revisiting when we repeat identical sequences, at least as an option? I think the challenge here is
        // with ReuseDestinations, since the numbers may go to different destinations. 

        #region Fields and settings

        public ArrayCommand[] UnderlyingCommands;
        public int NextCommandIndex;
        public int MaxCommandIndex;
        public int FirstScratchIndex;
        public int NextArrayIndex;
        public int MaxArrayIndex;

        // NEW: Toggle Roslyn or Reflection.Emit compilation
        public int MinNumCommandsToCompile = 25;
        public bool UseRoslyn = true; // DEBUG -- current problem with ILChunkEmitter is that it doesn't work for large chunks (e.g., over 1,000,000). So we need to break things up, ideally using if commands.
        public int MaxCommandsPerChunk { get; set; } = 1_000; // DEBUG // Use int.MaxValue to disable. Note that scratch slots will be reused only if this is the case.
        public bool DisableAdvancedFeatures = false;

        bool AutogenerateCode => !DisableAdvancedFeatures && true;
        [NonSerialized]
        Type AutogeneratedCodeType;
        public bool AutogeneratedCodeIsPrecompiled = false; // We can autogenerate and then just save to a c# file, so long as the game structure doesn't change. But we still need to initialize our game tree, since we use it to calculate our ordered sources. In that case, we don't need to autogenerate the code.
        bool CopyVirtualStackToLocalVariables => UseRoslyn; // A complication here is that this may cause the stack to become too large, so we can set to false to avoid that problem
        private bool _condition; // this is used for autogenerated code runtime

        // Ordered sources: We initially develop a list of indices of the data passed to the algorithm each iteration. Before each iteration, we copy the data corresponding to these indices into the OrderedSources array in the order in which it will be needed. A command that otherwise would copy from the original data instead loads the next item in ordered sources. This may slightly improve performance because a sequence of original data will be cached. More importantly, it can improve parallelism: When a player chooses among many actions that are structurally equivalent (that is, they do not change how the game is played from that point on), we can run the same code with different slices of the OrderedSources array.
        public bool UseOrderedSources => !DisableAdvancedFeatures && true; 
        public List<int> OrderedSourceIndices;
        public double[] OrderedSources;
        // Ordered destinations: Similarly, when the unrolled algorithm changes the data passed to it (for example, incrementing regrets in CFR), instead of directly incrementing the data, we develop in advance a list of the indices that will be changed. Then, when running the algorithm, we store the actual data that needs to be changed in an array, and on completion of the algorithm, we run through that array and change the data at the specified index for each item. This enhances parallelism because we don't have to lock around each data change, instead locking only around the final set of changes. This also may facilitate spreading the algorithm across machines, since each CPU can simply report the set of changes to make.
        public bool UseOrderedDestinations => !DisableAdvancedFeatures && true;
        public bool ReuseDestinations => !DisableAdvancedFeatures && false; // NOTE: Not currently working (must adapt to source code generation). If true, then we will not add a new ordered destination index for a destination location already used within code executed not in parallel. Instead, we will just increment the previous destination.
        public bool ReuseScratchSlots => MaxCommandsPerChunk == int.MaxValue;
        public List<int> OrderedDestinationIndices;
        public double[] OrderedDestinations;
        public List<int>[] OrderedDestinationsInverted; // here, the outer array is the same size as the target array, and the inner list consists of the items to add up for that array index.
        public (int targetIndex, List<int> sourceIndices)[] OrderedDestinationsInvertedWithTarget;
        public Dictionary<int, int> ReusableOrderedDestinationIndices;
        public bool Parallelize;

        public List<string> CommentTable = new();

        public bool RecordCommandTreeString = false;

        private Dictionary<string, ArrayCommandChunkDelegate> _compiledChunkMethods
    = new Dictionary<string, ArrayCommandChunkDelegate>();

        private bool DoParallel => !DisableAdvancedFeatures && Parallelize;

        // If true, then when a command refers to an array index, 0 refers to FirstScratchIndex.
        public bool ScratchIndicesStartAt0 => UseOrderedSources && UseOrderedDestinations;
        public int FullArraySize => FirstScratchIndex + (DoParallel ? 0 : MaxArrayIndex);

        public Stack<int> PerDepthStartArrayIndices;
        int NextVirtualStackID = 0;

        bool RepeatIdenticalRanges => !DisableAdvancedFeatures && ReuseScratchSlots; // instead of repeating identical sequences of commands, we run the same sequence twice
        public Stack<int?> RepeatingExistingCommandRangeStack;
        public bool RepeatingExistingCommandRange = false; // when this is true, we don't need to add new commands

        public NWayTreeStorageInternal<ArrayCommandChunk> CommandTree;
        public string CommandTreeString;
        List<byte> CurrentCommandTreeLocation = new List<byte>();
        NWayTreeStorageInternal<ArrayCommandChunk> CurrentNode => (NWayTreeStorageInternal<ArrayCommandChunk>) CommandTree.GetNode(CurrentCommandTreeLocation);
        ArrayCommandChunk CurrentCommandChunk => CurrentNode.StoredValue;

        StringBuilder CodeGenerationBuilder = new StringBuilder();
        HashSet<string> CompiledFunctions = new HashSet<string>();

        // Checkpoints: If we want to figure out why the compiled code is not working, we can use checkpoints. 
        // Wherever the command is copy to index -2, that will be interpreted as an instruction to add the value
        // to the checkpoints list. We can then, for example, compare the checkpoints with checkpoints from noncompiled
        // code or from code not using the ArrayCommandList to see where the values differ.
        public bool UseCheckpoints = false; 
        public static int CheckpointTrigger = -2; // -1 is used for other purposes, and must be negative
        public List<double> Checkpoints;
        private static int _nextExecId = 0;
        private int _globalSkipDepth = 0;

        #endregion

        #region Construction and command tree creation

        public ArrayCommandList(int maxNumCommands, int initialArrayIndex, bool parallelize)
        {
            UnderlyingCommands = new ArrayCommand[maxNumCommands];
            OrderedSourceIndices = new List<int>();
            OrderedDestinationIndices = new List<int>();
            ReusableOrderedDestinationIndices = new Dictionary<int, int>();
            FirstScratchIndex = initialArrayIndex;
            if (ScratchIndicesStartAt0)
                NextArrayIndex = 0;
            else
                NextArrayIndex = FirstScratchIndex;
            MaxArrayIndex = NextArrayIndex - 1;
            PerDepthStartArrayIndices = new Stack<int>();
            RepeatingExistingCommandRangeStack = new Stack<int?>();
            Parallelize = parallelize;
            CommandTree = new NWayTreeStorageInternal<ArrayCommandChunk>(null);
            CommandTree.StoredValue = new ArrayCommandChunk()
            {
                ChildrenParallelizable = false,
                StartCommandRange = 0,
                StartSourceIndices = 0,
                StartDestinationIndices = 0
            };
        }

        // We are simulating a stack. When entering a new depth level, we remember the next array index. Then, when exiting this depth level, we revert to this array index. A consequence of this is that depth i + 1 can return values to depth <= i only by copying to array indices already set at this earlier depth. 

        public void IncrementDepth()
        {
            PerDepthStartArrayIndices.Push(NextArrayIndex);
        }

        public void DecrementDepth(bool completeCommandList = false)
        {
            var popResult = PerDepthStartArrayIndices.Pop();
            if (RepeatIdenticalRanges && ReuseScratchSlots)
            {
                NextArrayIndex = popResult;
            }
            if (!PerDepthStartArrayIndices.Any() && completeCommandList)
            {
                CompleteCommandList();
                LogBalancedSegments(50_000); // DEBUG
            }
        }

        /// <summary>
        /// Starts a new command chunk. If an identical start command range is specified, then
        /// that range is recorded so that the commands do not need to be repeated. 
        /// </summary>
        /// <param name="runChildrenInParallel"></param>
        /// <param name="identicalStartCommandRange"></param>
        /// <param name="name"></param>
        public void StartCommandChunk(
    bool runChildrenInParallel,
    int? identicalStartCommandRange,
    string name = "",
    bool ignoreKeepTogether = false)
        {
#if DEBUG
            TabbedText.WriteLine(
                $"[CHUNK‑NEW] nextCmd={NextCommandIndex}  name=\"{name}\"  " +
                $"runChildrenInParallel={runChildrenInParallel}  "
              + $"identicalStart={identicalStartCommandRange?.ToString() ?? "null"}");
#endif

            runChildrenInParallel = false; // DEBUG SUPERDEBUG

            if (KeepCommandsTogetherLevel > 0 && !ignoreKeepTogether)
                return;

            if (RepeatIdenticalRanges && identicalStartCommandRange is int identical)
            {
                RepeatingExistingCommandRangeStack.Push(identicalStartCommandRange);
                NextCommandIndex = identical;
                RepeatingExistingCommandRange = true;
            }

            var currentNode = CurrentNode;
            var currentNodeIsInParallel = currentNode?.StoredValue.ChildrenParallelizable ?? false;
            if (currentNodeIsInParallel)
                ReusableOrderedDestinationIndices = new Dictionary<int, int>();

            if (currentNode.StoredValue.LastChild == 255)
                throw new Exception("Too many tree branches");

            byte nextChild = (byte)(currentNode.StoredValue.LastChild + 1);

            var childNode = new NWayTreeStorageInternal<ArrayCommandChunk>(currentNode);
            childNode.StoredValue = new ArrayCommandChunk
            {
                Name = name,
                ChildrenParallelizable = runChildrenInParallel,
                StartCommandRange = NextCommandIndex,
                StartSourceIndices = OrderedSourceIndices?.Count() ?? 0,
                StartDestinationIndices = OrderedDestinationIndices?.Count() ?? 0
            };

            currentNode.SetBranch(nextChild, childNode);
            currentNode.StoredValue.LastChild = nextChild;
            CurrentCommandTreeLocation.Add(nextChild);

#if DEBUG
            TabbedText.WriteLine(
                $"[START‑CHUNK] parentID={currentNode.StoredValue.ID}  "
              + $"childID={childNode.StoredValue.ID}  branch={nextChild}  "
              + $"ChildrenParallelizable={childNode.StoredValue.ChildrenParallelizable}  "
              + $"startCmd={childNode.StoredValue.StartCommandRange}");
#endif
        }


        public void EndCommandChunk(int[] copyIncrementsToParent = null, bool endingRepeatedChunk = false)
        {
#if DEBUG
            {
                string Dump(int[] a) => a == null ? "null" : string.Join(",", a);
                var child = CurrentCommandChunk;                 // chunk being ended *now*
                string map = child?.TranslationToLocalIndex == null
                    ? "∅"
                    : string.Join(",", child.TranslationToLocalIndex
                                          .Select((t, i) => t is null ? null : $"{i}->{t}")
                                          .Where(s => s != null));

                TabbedText.WriteLine($"[EC‑TOP] endingID={child?.ID,4}  stackID={child?.VirtualStackID,3}  "
                              + $"CopyIncParam=[{Dump(copyIncrementsToParent)}]  "
                              + $"TransMap=[{map}]");
            }
#endif
#if DEBUG
            var chunkId = CurrentCommandChunk?.ID ?? -1;
            TabbedText.WriteLine(
                $"[END] chunk {chunkId} sets CopyIncrementsToParent = " +
                $"{(copyIncrementsToParent == null ? "null"
                                                   : string.Join(',', copyIncrementsToParent))}");
#endif

            if (KeepCommandsTogetherLevel > 0)
                return;
            //TabbedText.WriteLine($"Ending");
            //TabbedText.TabUnindent(); 
            var commandChunkBeingEnded = CurrentCommandChunk;
            commandChunkBeingEnded.EndCommandRangeExclusive = NextCommandIndex;
            commandChunkBeingEnded.EndSourceIndicesExclusive = OrderedSourceIndices?.Count() ?? 0;
            commandChunkBeingEnded.EndDestinationIndicesExclusive = OrderedDestinationIndices?.Count() ?? 0;
            // now update parent
            CurrentCommandTreeLocation = CurrentCommandTreeLocation.Take(CurrentCommandTreeLocation.Count() - 1).ToList(); // remove last item
            CurrentCommandChunk.EndCommandRangeExclusive = NextCommandIndex;
            CurrentCommandChunk.EndSourceIndicesExclusive = OrderedSourceIndices?.Count() ?? 0;
            CurrentCommandChunk.EndDestinationIndicesExclusive = OrderedDestinationIndices?.Count() ?? 0;
            if (copyIncrementsToParent != null)
            {
                //TabbedText.WriteLine($"Planning to copy increments {String.Join(",", copyIncrementsToParent)} on {commandChunkBeingEnded.ID} with stackid {commandChunkBeingEnded.VirtualStackID} to parentsid {commandChunkBeingEnded.ParentVirtualStackID}");
            }
            commandChunkBeingEnded.CopyIncrementsToParent = copyIncrementsToParent;
            if (endingRepeatedChunk && RepeatIdenticalRanges && RepeatingExistingCommandRangeStack.Any())
            {
                RepeatingExistingCommandRangeStack.Pop();
                if (!RepeatingExistingCommandRangeStack.Any())
                    RepeatingExistingCommandRange = false;
            }
        }

        public void SetSkip(string chunkName, bool skip)
        {
            CommandTree.WalkTree(x =>
            {
                if (x.StoredValue.Name == chunkName)
                    x.StoredValue.Skip = skip;
                else if (x.Parent != null)
                    x.StoredValue.Skip = x.Parent.StoredValue.Skip;
            });
        }

        /// <summary>
        /// Rebuilds the command‑tree and all virtual‑stack metadata for the **current**
        /// value of <see cref="MaxCommandsPerChunk"/>.  Does the same work that
        /// <c>CompleteCommandList()</c> performs immediately after hoisting, but can be
        /// called later on a clone whose chunk‑limit differs from the original.
        /// </summary>
        public void FinaliseCommandTree()
        {
            // 1) Ensure every gap between children is covered by an explicit branch
            CommandTree.WalkTree(x =>
                InsertMissingBranches((NWayTreeStorageInternal<ArrayCommandChunk>)x));

            // 2) Hoist oversized If‑bodies using *this* MaxCommandsPerChunk
            HoistAndSplitLargeIfBodies();

            // 3) Allocate virtual‑stack arrays and wire parent/child relationships
            CommandTree.WalkTree(null, x =>
                SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)x));
            CommandTree.WalkTree(x =>
                SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)x));
        }

        public void CompleteCommandList()
        {
            MaxCommandIndex = NextCommandIndex;
            while (CurrentCommandTreeLocation.Any())
                EndCommandChunk();
            CompleteCommandTree();
        }

        // ░░ ArrayCommandList.cs ░░───────────────────────────────────────────────
        public void RebuildCommandTree()
        {
            /* 1) make a brand‑new root leaf that spans the full command list */
            var root = new NWayTreeStorageInternal<ArrayCommandChunk>(null);
            root.StoredValue = new ArrayCommandChunk
            {
                ID = 0,
                Name = "root",
                StartCommandRange = 0,
                EndCommandRangeExclusive = NextCommandIndex,
                StartSourceIndices = 0,
                EndSourceIndicesExclusive = 0,
                StartDestinationIndices = 0,
                EndDestinationIndicesExclusive = 0
            };

            CommandTree = root;   // ‹‑‑ replace the previous tree completely

            /* 2) run the same passes used in CompleteCommandList()  */
            CommandTree.WalkTree(x =>
                InsertMissingBranches((NWayTreeStorageInternal<ArrayCommandChunk>)x));

            // (Hoisting already done before the mutator, so we do not call it here.)

            CommandTree.WalkTree(null, x =>
                SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)x));
            CommandTree.WalkTree(x =>
                SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)x));

            if (RecordCommandTreeString)
                CommandTreeString = CommandTree.ToString();
        }


        /// <summary>
        /// Looks to see whether there are sequences of commands that are not specifically included within chunks. If so, chunks are created for those commands. 
        /// </summary>
        private void InsertMissingBranches(NWayTreeStorageInternal<ArrayCommandChunk> node)
        {
            byte lastChild = node.StoredValue.LastChild;
            if (lastChild > 0)
            {
                List<NWayTreeStorageInternal<ArrayCommandChunk>> children = new List<NWayTreeStorageInternal<ArrayCommandChunk>>();
                int currentCommandIndex = node.StoredValue.StartCommandRange;
                int currentSourceIndex = node.StoredValue.StartSourceIndices;
                int currentDestinationIndex = node.StoredValue.StartDestinationIndices;
                for (byte c = 1; c <= lastChild; c++)
                {
                    var branch = (NWayTreeStorageInternal<ArrayCommandChunk>) node.GetBranch(c);
                    var next = branch.StoredValue;
                    if (branch.StoredValue.StartCommandRange > currentCommandIndex)
                    { // there is a missing command range -- insert it
                        var toInsert = new NWayTreeStorageInternal<ArrayCommandChunk>(node);
                        toInsert.StoredValue = new ArrayCommandChunk()
                        {
                            ChildrenParallelizable = false,
                            StartCommandRange = currentCommandIndex,
                            EndCommandRangeExclusive = next.StartCommandRange,
                            StartSourceIndices = currentSourceIndex,
                            EndSourceIndicesExclusive = next.StartSourceIndices,
                            StartDestinationIndices = currentDestinationIndex,
                            EndDestinationIndicesExclusive = next.StartDestinationIndices,
                        };
                        children.Add(toInsert);
                    }
                    children.Add(branch);
                    currentCommandIndex = next.EndCommandRangeExclusive;
                    currentSourceIndex = next.EndSourceIndicesExclusive;
                    currentDestinationIndex = next.EndDestinationIndicesExclusive;
                    if (c == lastChild && (currentCommandIndex < node.StoredValue.EndCommandRangeExclusive || currentSourceIndex < node.StoredValue.EndSourceIndicesExclusive || currentDestinationIndex < node.StoredValue.EndDestinationIndicesExclusive))
                    {
                        var toInsert = new NWayTreeStorageInternal<ArrayCommandChunk>(node);
                        toInsert.StoredValue = new ArrayCommandChunk()
                        {
                            ChildrenParallelizable = false,
                            StartCommandRange = currentCommandIndex,
                            EndCommandRangeExclusive = node.StoredValue.EndCommandRangeExclusive,
                            StartSourceIndices = currentSourceIndex,
                            EndSourceIndicesExclusive = node.StoredValue.EndSourceIndicesExclusive,
                            StartDestinationIndices = currentDestinationIndex,
                            EndDestinationIndicesExclusive = node.StoredValue.EndDestinationIndicesExclusive,
                        };
                        children.Add(toInsert);
                    }
                }
                node.Branches = children.ToArray();
            }
        }

        private void CompleteCommandTree()
        {
            CommandTree.WalkTree(x => InsertMissingBranches((NWayTreeStorageInternal<ArrayCommandChunk>)x));

            HoistAndSplitLargeIfBodies();

            CommandTree.WalkTree(null, x => SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)x));
            CommandTree.WalkTree(x => SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)x));

            if (RecordCommandTreeString)
                CommandTreeString = CommandTree.ToString();
            CompileCode(); 
        }

        public void SetupVirtualStack(NWayTreeStorageInternal<ArrayCommandChunk> node)
        {
            ArrayCommandChunk c = node.StoredValue;

#if DEBUG
            if (c.VirtualStack != null)
                TabbedText.WriteLine($"[VS‑WARN] id={c.ID}  already has VS={c.VirtualStackID}  "
                              + "→ allocating another one now");
#endif

            /* allocate a brand‑new scratch array */
            c.VirtualStack = new double[MaxArrayIndex + 1];
            c.VirtualStackID = NextVirtualStackID++;

#if DEBUG
            TabbedText.WriteLine($"[VS‑ALLOC] id={c.ID}  newVS={c.VirtualStackID}");
#endif

            if (node.Branches == null || node.Branches.Length == 0)
            {
                c.FirstReadFromStack = new int?[MaxArrayIndex + 1];
                c.FirstSetInStack = new int?[MaxArrayIndex + 1];
                c.LastSetInStack = new int?[MaxArrayIndex + 1];
                c.LastUsed = new int?[MaxArrayIndex + 1];
                c.TranslationToLocalIndex = new int?[MaxArrayIndex + 1];

                (c.IndicesReadFromStack, c.IndicesInitiallySetInStack) =
                    DetermineWhenIndicesFirstLastUsed(
                        c.StartCommandRange,
                        c.EndCommandRangeExclusive,
                        c.FirstReadFromStack,
                        c.FirstSetInStack,
                        c.LastSetInStack,
                        c.LastUsed,
                        c.TranslationToLocalIndex);
            }
            else
            {
                DetermineSourcesUsedFromChildren(node);
            }
        }



        private static void DetermineSourcesUsedFromChildren(
          NWayTreeStorageInternal<ArrayCommandChunk> node)
        {
            ArrayCommandChunk c = node.StoredValue;
            HashSet<int> childrenSourceIndicesUsed = new HashSet<int>();

            if (node.Branches != null)
            {
                foreach (var branch in node.Branches)
                {
                    if (branch == null) continue;                    // ← skip nulls
                    if (branch.StoredValue?.IndicesReadFromStack == null) continue;

                    foreach (int idx in branch.StoredValue.IndicesReadFromStack)
                        childrenSourceIndicesUsed.Add(idx);
                }
            }

            c.IndicesReadFromStack = childrenSourceIndicesUsed.OrderBy(x => x).ToArray();
            c.IndicesInitiallySetInStack = null; // set only in children
        }


        private (int[] indicesReadFromStack, int[] indicesSetInStack) DetermineWhenIndicesFirstLastUsed(int startRange, int endRangeExclusive, int?[] firstReadFromStack, int?[] firstSetInStack, int?[] lastSetInStack, int?[] lastUsed, int?[] translationToLocalIndex)
        {
            // DEBUG
            const bool LOG_STACK_DIAG = false;            // flip to false to silence
            if (LOG_STACK_DIAG)
            {
                TabbedText.WriteLine(
                    $"[DIAG]  Analyse [{startRange},{endRangeExclusive})  " +
                    $"stackLen={firstReadFromStack.Length}");
            }

            HashSet<int> indicesUsed = new HashSet<int>();
            for (int commandIndex = startRange; commandIndex < endRangeExclusive; commandIndex++)
            {
                int virtualStackIndex = UnderlyingCommands[commandIndex].GetSourceIndexIfUsed();
                if (virtualStackIndex != -1)
                {
                    if (firstReadFromStack[virtualStackIndex] == null && firstSetInStack[virtualStackIndex] == null)
                        firstReadFromStack[virtualStackIndex] = commandIndex;
                    lastUsed[virtualStackIndex] = commandIndex;
                    indicesUsed.Add(virtualStackIndex);
                }
                virtualStackIndex = UnderlyingCommands[commandIndex].GetTargetIndexIfUsed();
                if (UseCheckpoints && virtualStackIndex == CheckpointTrigger)
                    virtualStackIndex = -1;
                if (virtualStackIndex != -1)
                {
                    // NOTE: If we get an IndexOutOfRangeException or other problem here,
                    // it may because of a failure to copy increments to parent when ending
                    // a chunk.
                    if (firstReadFromStack[virtualStackIndex] == null &&
    firstSetInStack[virtualStackIndex] == null)
                    {
                        var t = UnderlyingCommands[commandIndex].CommandType;

                        if (t >= ArrayCommandType.MultiplyBy && t <= ArrayCommandType.DecrementBy)
                        {
                            // read‑modify‑write → also mark first read
                            firstReadFromStack[virtualStackIndex] = commandIndex;
                        }

                        // either way, this is the first write
                        firstSetInStack[virtualStackIndex] = commandIndex;
                    }
                    lastSetInStack[virtualStackIndex] = commandIndex;
                    lastUsed[virtualStackIndex] = commandIndex;
                    indicesUsed.Add(virtualStackIndex);
                }
            }

            List<(int virtualStackIndex, int commandFirstUsed, int commandLastUsed)> useRanges = indicesUsed.Select(j => (j, firstReadFromStack[j] ?? firstSetInStack[j], lastUsed[j])).Where(x => x.Item2 != null || x.Item3 != null).Select(t => (t.Item1, (int)t.Item2, (int)t.Item3)).ToList();
            Dictionary<int, (HashSet<int> firstUses, HashSet<int> lastUses)> firstAndLastUsesForCommand = new Dictionary<int, (HashSet<int> firstUses, HashSet<int> lastUses)>();
            foreach (var useRange in useRanges)
            {
                if (!firstAndLastUsesForCommand.ContainsKey(useRange.commandFirstUsed))
                    firstAndLastUsesForCommand[useRange.commandFirstUsed] = (new HashSet<int>(), new HashSet<int>());
                if (!firstAndLastUsesForCommand.ContainsKey(useRange.commandLastUsed))
                    firstAndLastUsesForCommand[useRange.commandLastUsed] = (new HashSet<int>(), new HashSet<int>());
                firstAndLastUsesForCommand[useRange.commandFirstUsed].firstUses.Add(useRange.virtualStackIndex);
                firstAndLastUsesForCommand[useRange.commandLastUsed].lastUses.Add(useRange.virtualStackIndex);
            }

            int lastLocalIndexUsed = -1;
            Stack<int> availableLocals = new Stack<int>();
            for (int commandIndex = startRange; commandIndex < endRangeExclusive; commandIndex++)
            {
                if (firstAndLastUsesForCommand.ContainsKey(commandIndex))
                {
                    var firstUses = firstAndLastUsesForCommand[commandIndex].firstUses;
                    var lastUses = firstAndLastUsesForCommand[commandIndex].lastUses;
                    foreach (int virtualStackIndexFirstUsed in firstUses)
                    {
                        if (availableLocals.Any())
                        {
                            // we can recycle a local variable
                            translationToLocalIndex[virtualStackIndexFirstUsed] = availableLocals.Pop();
                        }
                        else
                            translationToLocalIndex[virtualStackIndexFirstUsed] = ++lastLocalIndexUsed;
                    }
                    foreach (int virtualStackIndexLastUsed in lastUses)
                    { // we're done with this local variable -- make it available
                        availableLocals.Push((int)translationToLocalIndex[virtualStackIndexLastUsed]);
                    }
                }
            }
            int[] indicesReadFromStack = Enumerable.Range(0, firstReadFromStack.Length).Where(x => firstReadFromStack[x] != null).ToArray();
            int[] indicesInitiallySetInStack = Enumerable.Range(0, firstSetInStack.Length).Where(x => firstSetInStack[x] != null).ToArray();
            TabbedText.WriteLine(
    $"[IDX‑ANAL] range=[{startRange},{endRangeExclusive})  "
  + $"read=[{string.Join(",", indicesReadFromStack)}]  "
  + $"set=[{string.Join(",", indicesInitiallySetInStack)}]");

#if DEBUG
            {
                const int probe = 1;                                // slot we care about
                if (probe < firstReadFromStack.Length)              // guard for small stacks
                {
                    string fr = firstReadFromStack[probe]?.ToString() ?? "–";
                    string fs = firstSetInStack[probe]?.ToString() ?? "–";
                    TabbedText.WriteLine($"[DWS‑IDX1] [{startRange},{endRangeExclusive})  "
                                  + $"firstRead={fr}  firstSet={fs}");
                }
            }
#endif
            TabbedText.WriteLine($"[CHECK‑LIST] chunk ?  Read=[{string.Join(",", indicesReadFromStack)}]  Inc=?");


            return (indicesReadFromStack, indicesInitiallySetInStack);
        }

        public void SetupVirtualStackRelationships(
    NWayTreeStorageInternal<ArrayCommandChunk> node)
        {
            var parentNode = (NWayTreeStorageInternal<ArrayCommandChunk>)node.Parent;
            if (parentNode == null) return;                             // root

            var child = node.StoredValue;
            var parent = parentNode.StoredValue;

            // share the same virtual‑stack whenever
            //   • the parent runs its children sequentially  OR
            //   • *this* child is guaranteed to run sequentially
            bool shareStack =
                    (!parent.ChildrenParallelizable  // parent runs sequentially  OR
                  || !child.ChildrenParallelizable)  // this child runs sequentially
                 && !child.RequiresPrivateStack;     // … *unless* the child knows it has to merge


#if DEBUG
            if (parent.ChildrenParallelizable && !child.ChildrenParallelizable && shareStack)
                TabbedText.WriteLine($"[WARN] parent {parent.ID} ChildrenParallelizable=true, "
                              + $"child {child.ID} false  →  shareStack={shareStack} (will re‑use VS)");

            TabbedText.WriteLine(
                $"[REL‑DECIDE] pID={parent.ID,4} cID={child.ID,4} "
              + $"share={shareStack}  reason="
              + (shareStack
                    ? (!parent.ChildrenParallelizable ? "parent‑not‑parallel"
                                                       : "child‑not‑parallel")
                    : "parallel"));
#endif

            if (shareStack)
            {
#if DEBUG
                TabbedText.WriteLine($"[VS‑OVWR] child {child.ID}  VS {child.VirtualStackID} "
                              + $"→ parent VS {parent.VirtualStackID}");
#endif
                child.VirtualStack = parent.VirtualStack;
                child.VirtualStackID = parent.VirtualStackID;
                child.ParentVirtualStack = parent.VirtualStack;
                child.ParentVirtualStackID = parent.VirtualStackID;
            }
            else
            {
                child.ParentVirtualStack = parent.VirtualStack;
                child.ParentVirtualStackID = parent.VirtualStackID;
            }

#if DEBUG
            TabbedText.WriteLine(
                $"[REL‑DONE]  pVS={parent.VirtualStackID,3}  cVS={child.VirtualStackID,3}  "
              + $"CopyInc={child.CopyIncrementsToParent?.Length ?? 0}");
            TabbedText.WriteLine(
                $"[CHECK‑LIST] chunk {child.ID}  Read=[{string.Join(',', child.IndicesReadFromStack ?? Array.Empty<int>())}]  "
              + $"Inc=[{string.Join(',', child.CopyIncrementsToParent ?? Array.Empty<int>())}]");
#endif
        }





        private int HighestSourceIndexInCommandRange(int startRange, int endRangeExclusive)
        {
            int lastArrayIndex = 0;
            for (int i = 0; i < endRangeExclusive; i++)
            {
                lastArrayIndex = Math.Max(lastArrayIndex, UnderlyingCommands[i].GetSourceIndexIfUsed());
            }
            if (lastArrayIndex == 0)
                return 0;
            if (ScratchIndicesStartAt0)
                return lastArrayIndex;
            return lastArrayIndex - FirstScratchIndex;
        }

        private int HighestTargetIndexInCommandRange(int startRange, int endRangeExclusive)
        {
            int lastArrayIndex = 0;
            for (int i = 0; i < endRangeExclusive; i++)
            {
                lastArrayIndex = Math.Max(lastArrayIndex, UnderlyingCommands[i].GetTargetIndexIfUsed());
            }
            if (lastArrayIndex == 0)
                return 0;
            if (ScratchIndicesStartAt0)
                return lastArrayIndex; // we've already decremented
            return lastArrayIndex - FirstScratchIndex;
        }


        #endregion

        #region Command creation
        private void AddCommand(ArrayCommand command)
        {
            if (NextCommandIndex == 0 && command.CommandType != ArrayCommandType.Blank)
                InsertBlankCommand();

            if (RepeatingExistingCommandRange)
            {
                ArrayCommand existing = UnderlyingCommands[NextCommandIndex];
                if (!command.Equals(existing) &&
                    (!ReuseDestinations || command.CommandType != ArrayCommandType.ReusedDestination))
                    throw new Exception("Expected repeated command to be equal but it wasn't");
                NextCommandIndex++;
                return;
            }

            if (NextCommandIndex >= UnderlyingCommands.Length)
                throw new Exception("Commands array size must be increased.");

            UnderlyingCommands[NextCommandIndex++] = command;

            if (NextArrayIndex > MaxArrayIndex)
                MaxArrayIndex = NextArrayIndex;
        }




        // First, methods to create commands that use new spots in the array

        public int[] NewZeroArray(int arraySize)
        {
            int[] result = new int[arraySize];
            for (int i = 0; i < arraySize; i++)
                result[i] = NewZero();
            return result;
        }

        public int NewZero()
        {
            AddCommand(new ArrayCommand(ArrayCommandType.Zero, NextArrayIndex, -1));
            return NextArrayIndex++;
        }

        public int[] NewUninitializedArray(int arraySize)
        {
            int[] result = new int[arraySize];
            for (int i = 0; i<arraySize; i++)
                result[i] = NewUninitialized();
            return result;
        }

        public int NewUninitialized()
        {
            return NextArrayIndex++;
        }

        public int CopyToNew(int sourceIndex, bool fromOriginalSources)
        {
            if (UseOrderedSources && fromOriginalSources)
            {
                // Instead of copying from the source, we will add this index to our list of indices. This will improve performance, because we can preconstruct our sources and then just read from these consecutively.
                OrderedSourceIndices.Add(sourceIndex);
                AddCommand(new ArrayCommand(ArrayCommandType.NextSource, NextArrayIndex, -1));
            }
            else
                AddCommand(new ArrayCommand(ArrayCommandType.CopyTo, NextArrayIndex, sourceIndex));
            return NextArrayIndex++;
        }

        public int[] CopyToNew(int[] sourceIndices, bool fromOriginalSources)
        {
            return sourceIndices.Select(x => CopyToNew(x, fromOriginalSources)).ToArray();
        }

        public int AddToNew(int index1, bool fromOriginalSources, int index2)
        {
            int result = CopyToNew(index1, fromOriginalSources);
            Increment(result, false, index2);
            return result;
        }

        public int MultiplyToNew(int index1, bool fromOriginalSources, int index2)
        {
            int result = CopyToNew(index1, fromOriginalSources);
            MultiplyBy(result, index2);
            return result;
        }

        // Next, methods that modify existing array items in place

        public void ZeroExisting(int[] indices)
        {
            foreach (int index in indices)
                ZeroExisting(index);
        }

        public void ZeroExisting(int index)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.Zero, index, -1));
        }

        public void CreateCheckpoint(int sourceIndex)
        {
            if (UseCheckpoints)
                CopyToExisting(CheckpointTrigger, sourceIndex);
        }

        public void CopyToExisting(int index, int sourceIndex)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.CopyTo, index, sourceIndex));
        }

        public void CopyToExisting(int[] indices, int[] sourceIndices)
        {
            for (int i = 0; i < indices.Length; i++)
            {
                CopyToExisting(indices[i], sourceIndices[i]);
            }
        }

        public void MultiplyArrayBy(int[] indices, int indexOfMultiplier)
        {
            for (int i = 0; i < indices.Length; i++)
                MultiplyBy(indices[i], indexOfMultiplier);
        }

        public void MultiplyArrayBy(int[] indices, int[] indicesOfMultipliers)
        {
            for (int i = 0; i < indices.Length; i++)
                MultiplyBy(indices[i], indicesOfMultipliers[i]);
        }

        public void MultiplyBy(int index, int indexOfMultiplier)
        {
            if (!ScratchIndicesStartAt0 && index < FirstScratchIndex)
                throw new NotSupportedException(); // use approach of increment to avoid interlocking code
            AddCommand(new ArrayCommand(ArrayCommandType.MultiplyBy, index, indexOfMultiplier));
        }

        public void IncrementArrayBy(int[] indices, bool targetOriginals,  int indexOfIncrement)
        {
            for (int i = 0; i < indices.Length; i++)
                Increment(indices[i], targetOriginals, indexOfIncrement);
        }

        public void IncrementArrayBy(int[] indices, bool targetOriginals, int[] indicesOfIncrements)
        {
            for (int i = 0; i < indices.Length; i++)
                Increment(indices[i], targetOriginals, indicesOfIncrements[i]);
        }

        public void Increment(int index, bool targetOriginal, int indexOfIncrement)
        {
            if (targetOriginal)
            {
                // When this is true, the goal is to change a value in the original array of values, specifically among the destination
                // indices. This allows us to return various results from the algorithm as a whole. We do this by adding the index in
                // the original array to OrderedDestinationIndices. Then, we add a NextDestination command. When that command is
                // processed, the processing code will look at the next value in OrderedDestinationIndices, and it will set the
                // original value at that index. 

                //TabbedText.WriteLine($"Targeting original at {index}");
                if (UseOrderedDestinations)
                {
                    if (ReuseDestinations && ReusableOrderedDestinationIndices.ContainsKey(index))
                    {
                        AddCommand(new ArrayCommand(ArrayCommandType.ReusedDestination, ReusableOrderedDestinationIndices[index], indexOfIncrement));
                    }
                    else
                    {
                        OrderedDestinationIndices.Add(index);
                        if (ReuseDestinations)
                            ReusableOrderedDestinationIndices.Add(index, OrderedDestinationIndices.Count() - 1);
                        AddCommand(new ArrayCommand(ArrayCommandType.NextDestination, -1, indexOfIncrement));
                    }
                }
                else
                    AddCommand(new ArrayCommand(ArrayCommandType.IncrementBy, index, indexOfIncrement));
            }
            else
                AddCommand(new ArrayCommand(ArrayCommandType.IncrementBy, index, indexOfIncrement));
        }

        public void IncrementByProduct(int index, bool targetOriginal, int indexOfIncrementProduct1, int indexOfIncrementProduct2)
        {
            int spaceForProduct = CopyToNew(indexOfIncrementProduct1, false);
            MultiplyBy(spaceForProduct, indexOfIncrementProduct2);
            Increment(index, targetOriginal, spaceForProduct);
            if (ReuseScratchSlots)
            {
                NextArrayIndex--;
            }
        }

        public void DecrementArrayBy(int[] indices, int indexOfDecrement)
        {
            for (int i = 0; i < indices.Length; i++)
                Decrement(indices[i], indexOfDecrement);
        }

        public void DecrementArrayBy(int[] indices, int[] indicesOfDecrements)
        {
            for (int i = 0; i < indices.Length; i++)
                Decrement(indices[i], indicesOfDecrements[i]);
        }

        public void Decrement(int index, int indexOfDecrement)
        {
            if (!ScratchIndicesStartAt0 && index < FirstScratchIndex)
                throw new NotSupportedException(); // use approach of increment to avoid interlocking code
            AddCommand(new ArrayCommand(ArrayCommandType.DecrementBy, index, indexOfDecrement));
        }

        public void DecrementByProduct(int index, int indexOfDecrementProduct1, int indexOfDecrementProduct2)
        {
            int spaceForProduct = CopyToNew(indexOfDecrementProduct1, false);
            MultiplyBy(spaceForProduct, indexOfDecrementProduct2);
            Decrement(index, spaceForProduct);
            if (ReuseScratchSlots)
            {
                NextArrayIndex--; // we've set aside an array index to be used for this command. But we no longer need it, so we can now allocate it to some other purpose (e.g., Decrementing by another product)
            }
        }

        // Flow control. We do flow control by a combination of comparison commands and go to commands. When a comparison is made, if the comparison fails, the next command is skipped. Thus, the combination of the comparison and the go to command ensures that the go to command will be obeyed only if the comparison succeeds.

        public void InsertEqualsOtherArrayIndexCommand(int index1, int index2)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.EqualsOtherArrayIndex, index1, index2));
        }

        public void InsertNotEqualsOtherArrayIndexCommand(int index1, int index2)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.NotEqualsOtherArrayIndex, index1, index2));
        }

        public void InsertGreaterThanOtherArrayIndexCommand(int index1, int index2)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.GreaterThanOtherArrayIndex, index1, index2));
        }

        public void InsertLessThanOtherArrayIndexCommand(int index1, int index2)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.LessThanOtherArrayIndex, index1, index2));
        }

        /// <summary>
        /// Inserts a command to make a comparison between the item at index1 and an integral value that is provided. This can be useful to achieve iteration over an index variable.
        /// </summary>
        /// <param name="index1"></param>
        /// <param name="valueToCompareTo"></param>
        public void InsertEqualsValueCommand(int index1, int valueToCompareTo)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.EqualsValue, index1, valueToCompareTo));
        }

        public void InsertNotEqualsValueCommand(int index1, int valueToCompareTo)
        {
            AddCommand(new ArrayCommand(ArrayCommandType.NotEqualsValue, index1, valueToCompareTo));
        }

        // We need to keep commands together to stop a new command chunk between an IF command and an ENDIF command. 

        int KeepCommandsTogetherLevel = 0;
        public void KeepCommandsTogether()
        {
            KeepCommandsTogetherLevel++;
        }

        public void EndKeepCommandsTogether()
        {
            KeepCommandsTogetherLevel--;
        }

        public void InsertIfCommand()
        {
            KeepCommandsTogether();
            AddCommand(new ArrayCommand(ArrayCommandType.If, -1, -1));
        }

        public void InsertEndIfCommand()
        {
            EndKeepCommandsTogether();
            AddCommand(new ArrayCommand(ArrayCommandType.EndIf, -1, -1));
        }

        /// <summary>
        ///  Inserts a blank command.
        /// </summary>
        /// <returns>The command index (not an array index, as with most comamnds)</returns>
        public int InsertBlankCommand()
        {
            int commandIndex = NextCommandIndex; // not the array index
            AddCommand(new ArrayCommand(ArrayCommandType.Blank, -1, -1));
            return commandIndex;
        }

        public void InsertComment(string text)
        {
            int id = CommentTable.Count;
            CommentTable.Add(text);
            // we store the comment’s row‑id in SourceIndex
            AddCommand(new ArrayCommand(ArrayCommandType.Comment, -1, id));
        }

        #endregion

        #region Code generation

        public void CompileCode()
        {
            // This is your existing gate to skip codegen for certain conditions
            if (!AutogenerateCode || /* DEBUG !RepeatIdenticalRanges || */ !UseOrderedDestinations || !UseOrderedSources)
                return;

            // Decide which approach to use
            if (UseRoslyn)
            {
                // Existing Roslyn-based logic
                Stopwatch s = new Stopwatch();
                s.Start();
                TabbedText.WriteLine($"Autogenerating and compiling code...");

                string checkpoints = "";
                if (UseCheckpoints)
                    checkpoints = $@"

        public static List<double> Checkpoints = new List<double>();

        public static void ResetCheckpoints()
        {{
            Checkpoints = new List<double>();
        }}";

                CodeGenerationBuilder.AppendLine($@"using System;
    using System.Collections.Generic;

    namespace CommandTreeCodegen
    {{
    public static class AutogeneratedCode 
    {{{checkpoints}
");
                CommandTree.WalkTree(x => GenerateCode((NWayTreeStorageInternal<ArrayCommandChunk>)x));
                CodeGenerationBuilder.AppendLine($@"}}
}}");
                string fullyQualifiedClassName = "CommandTreeCodegen.AutogeneratedCode";
                if (AutogeneratedCodeIsPrecompiled)
                {
                    TabbedText.WriteLine($"Using precompiled code.");
                    AutogeneratedCodeType = Type.GetType(fullyQualifiedClassName);
                    return;
                }
                var codeString = CodeGenerationBuilder.ToString();
                CodeGenerationBuilder = new StringBuilder();
                AutogeneratedCodeType = StringToCode.LoadCode(codeString, fullyQualifiedClassName);
#if DEBUG
                TabbedText.WriteLine(
                    $"[ROS‑COMPILE]  "
                  + $"methods={string.Join(", ", CompiledFunctions)}  "
                  + $"UseRoslyn={UseRoslyn}");
#endif
                TabbedText.WriteLine($"...Code autogeneration complete after {s.ElapsedMilliseconds} milliseconds");
            }
            else
            {
                CompileCode_ReflectionEmit();
            }
        }

        // NEW: Stub or placeholder for Reflection.Emit approach:
        private void CompileCode_ReflectionEmit()
        {
            _compiledChunkMethods.Clear();

            // Walk the CommandTree, compile any chunk with enough commands
            CommandTree.WalkTree(nodeObj =>
            {
                var node = nodeObj as NWayTreeStorageInternal<ArrayCommandChunk>;
                if (node == null) return;

                ArrayCommandChunk chunk = node.StoredValue;
                int startCmd = chunk.StartCommandRange;
                int endCmd = chunk.EndCommandRangeExclusive;
                int numCommands = endCmd - startCmd;

                if (numCommands >= MinNumCommandsToCompile)
                {
                    string methodKey = $"Chunk_{startCmd}_{endCmd - 1}";

                    // Build the IL
                    var emitter = new ILChunkEmitter(chunk, UnderlyingCommands); 
                    ArrayCommandChunkDelegate del = emitter.EmitMethod(methodKey,   /*out*/
                                                   out int ilBytes);
                    TabbedText.WriteLine(
                        $"[IL] chunk {methodKey} — {numCommands:N0} commands, {ilBytes:N0} IL bytes"); // DEBUG

                    // Store the delegate
                    _compiledChunkMethods[methodKey] = del;
                }
            });
        }

        private bool ExecuteAutogeneratedCode(ArrayCommandChunk chunk)
        {
#if DEBUG
            TabbedText.WriteLine($"[ROS‑TRY] chunkID={chunk.ID}  "
                               + $"startCmd={chunk.StartCommandRange}");
#endif

            /* Roslyn disabled? ───────────────*/
            if (!UseRoslyn)
            {
#if DEBUG
                TabbedText.WriteLine($"[ROS‑SKIP] id={chunk.ID}  (UseRoslyn == false)");
#endif
                return false;
            }

            int start = chunk.StartCommandRange;
            int end = chunk.EndCommandRangeExclusive - 1;
            string fn = $"Execute{start}to{end}";

            /* Was this slice ever scheduled for compilation? */
            if (!CompiledFunctions.Contains(fn))
            {
#if DEBUG
                TabbedText.WriteLine($"[ROS‑SKIP] id={chunk.ID}  (function {fn} not in list)");
#endif
                return false;
            }

            /* Does the method really exist in the current assembly? */
            MethodInfo mi = AutogeneratedCodeType?.GetMethod(
                                fn,
                                BindingFlags.Public | BindingFlags.Static);

            if (mi == null)
            {
#if DEBUG
                TabbedText.WriteLine($"[ROS‑SKIP] id={chunk.ID}  "
                                   + $"(method {fn} not found in AutogeneratedCodeType)");
#endif
                return false;   // fall back to IL / interpreter
            }

#if DEBUG
            TabbedText.WriteLine($"[ROS‑RUN] id={chunk.ID}  fn={fn}");
#endif

            /* Run the compiled delegate. The Invoke wrapper already updates the
               ref parameters inside the array.                                    */
            InvokeAutogeneratedCode(chunk, fn);
            return true;
        }



        /// <summary>
        /// Executes the compiled Roslyn method for <paramref name="chunk"/> and
        /// synchronises live ordered‑source / ordered‑destination indices *and* the
        /// shared branch‑condition flag.
        /// </summary>
        private void InvokeAutogeneratedCode(ArrayCommandChunk chunk, string fnName)
        {
#if DEBUG
            TabbedText.WriteLine(
                $"[ROS‑CALL] fn={fnName}  chunkID={chunk.ID}  " +
                $"virtualStack={string.Join(",", chunk.VirtualStack)}");
#endif

            MethodInfo mi = AutogeneratedCodeType.GetMethod(fnName);
            if (mi == null)
                throw new MissingMethodException($"Autogenerated method {fnName} not found.");

            /* live pointers passed BY‑REF to the Roslyn slice */
            int cosi = chunk.StartSourceIndices;
            int codi = chunk.StartDestinationIndices;

            object[] args =
            {
        chunk.VirtualStack,   // vs
        OrderedSources,       // os
        OrderedDestinations,  // od
        cosi,                 // ref cosi
        codi,                 // ref codi
        _condition            // ref condition  (field lives for the whole call‑chain)
    };

            try
            {
                mi.Invoke(null,
                          BindingFlags.Default,
                          binder: null,
                          parameters: args,
                          culture: null);

                /* retrieve by‑ref outputs */
                cosi = (int)args[3];
                codi = (int)args[4];
                _condition = (bool)args[5];   // propagate updated flag to subsequent slices

                chunk.StartSourceIndices = cosi;
                chunk.StartDestinationIndices = codi;

#if DEBUG
                TabbedText.WriteLine(
                    $"[ROS‑CALL_AFT] fn={fnName}  chunkID={chunk.ID}  " +
                    $"cosi→{cosi}  codi→{codi}  cond={_condition}");
#endif
            }
            catch (TargetInvocationException tie)
            {
#if DEBUG
                TabbedText.WriteLine(
                    $"[ROS‑ERR] {tie.InnerException?.GetType().Name}: {tie.InnerException?.Message}");
#endif
                throw;
            }
        }


        public void ResetCheckpoints()
        {
            if (!UseCheckpoints)
                return;

            if (AutogenerateCode)
            {
                var method = AutogeneratedCodeType.GetMethod("ResetCheckpoints");
                method.Invoke(null, null);
            }
            else
            {
                Checkpoints = new List<double>();
            }
        }

        public void LoadCheckpoints()
        {
            if (!UseCheckpoints)
                return;
            if (AutogenerateCode)
            {
                var fields = AutogeneratedCodeType.GetFields();
                Checkpoints = (List<double>) fields[0].GetValue(null);
            }
        }
        private void GenerateCode(NWayTreeStorageInternal<ArrayCommandChunk> node)
        {
            bool isLeaf = node.Branches == null || node.Branches.Length == 0;
            bool isConditionalGate = node.StoredValue?.Name == "Conditional";
            bool parentIsGate = node.Parent is NWayTreeStorageInternal<ArrayCommandChunk> p
                                     && p.StoredValue?.Name == "Conditional";

            bool containsFlow = ChunkContainsFlowControl(node.StoredValue);

            /* never compile a leaf that *still* has flow‑control */
            if (containsFlow && !isConditionalGate)
                return;

            /* compile only leaves or the gate itself */
            if (!isLeaf && !isConditionalGate)
                return;

            /* ►► NO length check ◄◄   (always compile flow‑control‑free leaves) */

            int start = node.StoredValue.StartCommandRange;
            int end = node.StoredValue.EndCommandRangeExclusive - 1;
            string fnName = $"Execute{start}to{end}";
            if (CompiledFunctions.Contains(fnName))
                return;

            if (!AutogeneratedCodeIsPrecompiled)
            {
                CodeGenerationBuilder.AppendLine();
                CodeGenerationBuilder.AppendLine(GenerateSourceTextForChunk(node.StoredValue));
            }

            CompiledFunctions.Add(fnName);
        }
        private string GenerateSourceTextForChunk(ArrayCommandChunk c)
        {
            int startCmd = c.StartCommandRange;
            int endCmd = c.EndCommandRangeExclusive - 1;

            /* ── gather direct child slices if this is the Conditional gate ── */
            List<ArrayCommandChunk> childSlices = null;
            if (c.Name == "Conditional")
            {
                childSlices = new List<ArrayCommandChunk>();
                CommandTree.WalkTree(nObj =>
                {
                    var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
                    if (n.StoredValue == c && n.Branches != null)
                        foreach (var br in n.Branches.Where(b => b != null))
                            childSlices.Add(br.StoredValue);
                });
            }

            int?[] trans = c.TranslationToLocalIndex ?? Array.Empty<int?>();

            var b = new StringBuilder();

            /* ── method header ── */
            b.AppendLine($@"public static void Execute{startCmd}to{endCmd}(
    double[] vs, double[] os, double[] od,
    ref int cosi, ref int codi, ref bool condition)
{{");

            /* ── declare & initialise locals (if translation present) ───────────── */
            if (CopyVirtualStackToLocalVariables && trans.Length > 0)
            {
                var emitted = new HashSet<int>();               // ensure each i_k once

                for (int g = 0; g < trans.Length; g++)
                {
                    if (trans[g] is int loc && emitted.Add(loc))
                    {
                        // loc  = local variable index (k)   •   g = global VS index
                        b.AppendLine($"    double i_{loc} = vs[{g}];");
                    }
                }
                b.AppendLine();
            }

            var srcIncr = new List<int>();
            var dstIncr = new List<int>();

            for (int cmd = startCmd; cmd <= endCmd; cmd++)
            {
                ArrayCommand ac = UnderlyingCommands[cmd];
                int tgtIdx = ac.GetTargetIndexIfUsed();
                int srcIdx = ac.GetSourceIndexIfUsed();

                string srcStr = ac.SourceIndex >= 0 ? $"vs[{ac.SourceIndex}]" : "0";
                string tgtStr = ac.Index >= 0 ? $"vs[{ac.Index}]" : "0";

                if (CopyVirtualStackToLocalVariables && trans.Length > 0)
                {
                    if (srcIdx >= 0 && srcIdx < trans.Length && trans[srcIdx] is int sLoc)
                        srcStr = $"i_{sLoc}";
                    if (tgtIdx >= 0 && tgtIdx < trans.Length && trans[tgtIdx] is int tLoc
                        && !(UseCheckpoints && tgtIdx == CheckpointTrigger))
                        tgtStr = $"i_{tLoc}";
                }

                switch (ac.CommandType)
                {
                    /* ── writes to VS ─────────────────────────── */
                    case ArrayCommandType.Zero:
                        if (tgtStr.StartsWith("i_"))
                        {
                            b.AppendLine($"    {tgtStr} = 0;");
                            b.AppendLine($"    vs[{ac.Index}] = {tgtStr};");
                        }
                        else
                            b.AppendLine($"    {tgtStr} = 0;");
                        break;

                    case ArrayCommandType.CopyTo:
                        {
                            bool hasAlias = tgtStr.StartsWith("i_");
                            string rhs = srcStr;              // simplified: always read from VS
                            if (UseCheckpoints && ac.Index == CheckpointTrigger)
                            {
                                b.AppendLine($"    Checkpoints.Add({rhs});");
                            }
                            else if (hasAlias)
                            {
                                b.AppendLine($"    {tgtStr} = {rhs};");
                                b.AppendLine($"    vs[{ac.Index}] = {tgtStr};");
                            }
                            else
                            {
                                b.AppendLine($"    {tgtStr} = {rhs};");
                                // ensure the backing VS slot is updated even when no alias was used
                                if (tgtStr != $"vs[{ac.Index}]")
                                    b.AppendLine($"    vs[{ac.Index}] = {tgtStr};");
                            }
                            break;
                        }

                    case ArrayCommandType.IncrementBy:
                    case ArrayCommandType.DecrementBy:
                    case ArrayCommandType.MultiplyBy:
                        {
                            string op = ac.CommandType switch
                            {
                                ArrayCommandType.IncrementBy => "+=",
                                ArrayCommandType.DecrementBy => "-=",
                                _ => "*="
                            };
                            if (tgtStr.StartsWith("i_"))
                            {
                                b.AppendLine($"    {tgtStr} {op} {srcStr};");
                                b.AppendLine($"    vs[{ac.Index}] = {tgtStr};");
                            }
                            else
                                b.AppendLine($"    {tgtStr} {op} {srcStr};");
                            break;
                        }

                    /* ── pointer‑advancing ────────────────────── */
                    case ArrayCommandType.NextSource:
                        b.AppendLine($"    {tgtStr} = os[cosi++];");
                        for (int i = 0; i < srcIncr.Count; i++) srcIncr[i]++;
                        break;

                    case ArrayCommandType.NextDestination:
                        b.AppendLine($"    od[codi++] = {srcStr};");
                        for (int i = 0; i < dstIncr.Count; i++) dstIncr[i]++;
                        break;

                    case ArrayCommandType.ReusedDestination:
                        b.AppendLine($"    od[{ac.Index}] += {srcStr};");
                        break;

                    /* ── comparisons ─────────────────────────── */
                    case ArrayCommandType.EqualsOtherArrayIndex: b.AppendLine($"    condition = {tgtStr} == {srcStr};"); break;
                    case ArrayCommandType.NotEqualsOtherArrayIndex: b.AppendLine($"    condition = {tgtStr} != {srcStr};"); break;
                    case ArrayCommandType.GreaterThanOtherArrayIndex: b.AppendLine($"    condition = {tgtStr} >  {srcStr};"); break;
                    case ArrayCommandType.LessThanOtherArrayIndex: b.AppendLine($"    condition = {tgtStr} <  {srcStr};"); break;
                    case ArrayCommandType.EqualsValue: b.AppendLine($"    condition = {tgtStr} == (double){ac.SourceIndex};"); break;
                    case ArrayCommandType.NotEqualsValue: b.AppendLine($"    condition = {tgtStr} != (double){ac.SourceIndex};"); break;

                    /* ── control flow ─────────────────────────── */
                    case ArrayCommandType.If:
                        srcIncr.Add(0); dstIncr.Add(0);
                        b.AppendLine("    if (condition)\n    {");
                        break;

                    case ArrayCommandType.EndIf:
                        {
                            int sInc = srcIncr[^1]; srcIncr.RemoveAt(srcIncr.Count - 1);
                            int dInc = dstIncr[^1]; dstIncr.RemoveAt(dstIncr.Count - 1);

                            b.AppendLine("    }");

                            if ((childSlices == null || childSlices.Count == 0) && (sInc != 0 || dInc != 0))
                                b.AppendLine($@"    else {{
        cosi += {sInc};
        codi += {dInc};
    }}");
                            break;
                        }

                    case ArrayCommandType.Comment:
                        b.AppendLine($"    // {CommentTable[ac.SourceIndex]}");
                        break;
                }
            }

            /* ── Conditional gate: dispatch body slices ── */
            if (childSlices != null && childSlices.Count > 0)
            {
                b.AppendLine("    if (!condition) return;");
                foreach (var s in childSlices)
                    b.AppendLine(
                        $"    Execute{s.StartCommandRange}to{s.EndCommandRangeExclusive - 1}" +
                        "(vs, os, od, ref cosi, ref codi, ref condition);");
            }

            b.AppendLine("}");
            return b.ToString();
        }









        #endregion

        #region Command execution
        // ───────────────────────────────────────────────────────────────────────────
        // 1) Main entry point: hoisted & un‑hoisted all go through this.
        // ───────────────────────────────────────────────────────────────────────────

        public void ExecuteAll(double[] array, bool tracing)
        {
            _condition = true;
#if DEBUG
            TabbedText.WriteLine("══════════════════════════════════════════════════════");
            TabbedText.WriteLine($"[ExecuteAll]  arrayLen={array?.Length ?? 0}  tracing={tracing}");
#endif

            /*───────────────────────────────────────────────────────────
             * helper: run the chunk if it is either
             *   • a leaf            (no children)  OR
             *   • a “Conditional”   (gate node created by HoistMutator)
             *──────────────────────────────────────────────────────────*/
            static bool IsExecutableNode(NWayTreeStorageInternal<ArrayCommandChunk> n)
            {
                return (n.Branches == null || n.Branches.Length == 0)   // leaf
                    || n.StoredValue?.Name == "Conditional";            // gate
            }

            /*─────────────────────────────
             * 1)  CHECKPOINT MODE
             *────────────────────────────*/
            if (Checkpoints != null)
            {
                PrepareOrderedSourcesAndDestinations(array);
                _nextExecId = 0;

                CommandTree.WalkTree(
                    /* enter ▸ pre‑order ─────────────────────────────── */
                    n =>
                    {
                        var node = (NWayTreeStorageInternal<ArrayCommandChunk>)n;
                        var chunk = node.StoredValue;
                        chunk.CopyParentVirtualStack();

                        /* run “Conditional” gate _before_ visiting children */
                        if (chunk.Skip) return;
                        if (chunk.Name == "Conditional")
                            ExecuteSectionOfCommands(chunk);
                    },
                    /* exec ▸ post‑order ──────────────────────────────── */
                    n =>
                    {
                        var node = (NWayTreeStorageInternal<ArrayCommandChunk>)n;
                        var chunk = node.StoredValue;
                        if (chunk.Skip) return;

                        /* NEW: body‑slices are children of a Conditional gate — already
                           invoked by the gate itself, so do not execute again here */
                        if (node.Parent is NWayTreeStorageInternal<ArrayCommandChunk> p
                            && p.StoredValue?.Name == "Conditional")
                            return;

                        if (IsExecutableNode(node) && chunk.Name != "Conditional")
                            ExecuteSectionOfCommands(chunk);

                        chunk.CopyIncrementsToParentIfNecessary();
                        chunk.ResetIncrementsForParent();
                    },

                    /* parallel? */ _ => false
                );

                CopyOrderedDestinations(array);
#if DEBUG
                TabbedText.WriteLine("[ExecuteAll]  END (checkpoint mode)");
                TabbedText.WriteLine("══════════════════════════════════════════════════════");
#endif
                return;
            }

            /*─────────────────────────────
             * 2)  Decide flat vs. chunked
             *────────────────────────────*/

            bool hasChildIncrements = false;
            bool hasSkippedLeaves = false;
            bool treeHasBranches = CommandTree.Branches != null && CommandTree.Branches.Length > 0;

            CommandTree.WalkTree(n =>
            {
                var c = ((NWayTreeStorageInternal<ArrayCommandChunk>)n).StoredValue;
                if (c.CopyIncrementsToParent != null) hasChildIncrements = true;
                if (c.Skip) hasSkippedLeaves = true;
            });

            bool needChunked =
                   treeHasBranches          // NEW: any branching at all ⇒ use chunked
                || DoParallel
                || RepeatIdenticalRanges
                || hasChildIncrements
                || hasSkippedLeaves;

            if (!needChunked)
            {
                ExecuteAllCommands(array);
                return;
            }

            /*─────────────────────────────
             * 3)  CHUNKED EXECUTION
             *────────────────────────────*/
            PrepareOrderedSourcesAndDestinations(array);

            CommandTree.WalkTree(
                /* enter ▸ pre‑order ─────────────────────────────── */
                n =>
                {
                    var node = (NWayTreeStorageInternal<ArrayCommandChunk>)n;
                    var chunk = node.StoredValue;
                    chunk.CopyParentVirtualStack();

                    /* run “Conditional” gate _before_ its children */
                    if (chunk.Skip) return;
                    if (chunk.Name == "Conditional")
                        ExecuteSectionOfCommands(chunk);
                },
                /* exec ▸ post‑order ──────────────────────────────── */
                n =>
                {
                    var node = (NWayTreeStorageInternal<ArrayCommandChunk>)n;
                    var chunk = node.StoredValue;
                    if (chunk.Skip) return;

                    /* NEW: body‑slices are children of a Conditional gate — already
                        invoked by the gate itself, so do not execute again here */
                    if (node.Parent is NWayTreeStorageInternal<ArrayCommandChunk> p
                        && p.StoredValue?.Name == "Conditional")
                        return;

                    if (IsExecutableNode(node) && chunk.Name != "Conditional")
                        ExecuteSectionOfCommands(chunk);

                    chunk.CopyIncrementsToParentIfNecessary();
                    chunk.ResetIncrementsForParent();
                },
                /* parallel? */ n =>
                    DoParallel &&
                    ((NWayTreeStorageInternal<ArrayCommandChunk>)n)
                        .StoredValue.ChildrenParallelizable
            );

            CopyOrderedDestinations(array);
#if DEBUG
            TabbedText.WriteLine("[ExecuteAll]  END (chunked)");
            TabbedText.WriteLine("══════════════════════════════════════════════════════");
#endif
        }






        // ───────────────────────────────────────────────────────────────────────────
        // 2) Flat‑interpreter entry point (called directly by tests before hoist,
        //    and internally above for the non‑parallel branch).
        // ───────────────────────────────────────────────────────────────────────────
        public double[] ExecuteAllCommands(double[] array)
        {
#if DEBUG
            TabbedText.WriteLine("[ExecuteAllCommands]  BEGIN");
#endif
            if (MaxCommandIndex == 0)
                CompleteCommandList();

            // only the flat (un‑hoisted) path sets these up/tears them down
            PrepareOrderedSourcesAndDestinations(array);

            /* 1️⃣  choose a stack that can hold every index the ACL may touch          */
            int stackLen = MaxArrayIndex + 1;          // highest index + 1
            bool usingScratch = array.Length < stackLen;   // need private buffer?
            double[] stackBuf = usingScratch ? new double[stackLen] : array;

            /* 2️⃣  if we allocated a private buffer, copy the “original” region       */
            if (usingScratch && FirstScratchIndex > 0)
            {
                int originals = Math.Min(FirstScratchIndex, array.Length);
                Array.Copy(array, 0, stackBuf, 0, originals);
            }

            Span<double> virtualStack = stackBuf;

            /* 3️⃣  interpret all commands (inclusive end = MaxCommandIndex‑1)         */
            ExecuteSectionOfCommands(
                virtualStack,
                startCommandIndex: 0,
                endCommandIndexInclusive: MaxCommandIndex - 1,
                currentOrderedSourceIndex: 0,
                currentOrderedDestinationIndex: 0);

            /* 4️⃣  copy results for the original region back to the caller (only
                    needed when we ran on a private scratch buffer)                    */
            if (usingScratch && FirstScratchIndex > 0)
            {
                Array.Copy(stackBuf, 0, array, 0, FirstScratchIndex);
            }

            CopyOrderedDestinations(array);
#if DEBUG
            TabbedText.WriteLine("[ExecuteAllCommands]  END");
#endif
            return array;
        }




        /// <summary>
        /// Execute one command‑chunk, honouring the global skip‑depth so that slices
        /// of an If‑body previously evaluated to <c>false</c> are scanned but not
        /// executed. Each chunk chooses the first available path:
        ///   1) Roslyn‑generated static method
        ///   2) Cached IL delegate
        ///   3) Interpreter loop
        /// </summary>
        private void ExecuteSectionOfCommands(ArrayCommandChunk commandChunk)
        {
            /* ───── Cross‑chunk skipping ─────────────────────────────────── */
            if (_globalSkipDepth > 0)
            {
#if DEBUG
                TabbedText.WriteLine($"[SKIP‑CHK] id={commandChunk.ID}  depth={_globalSkipDepth}");
#endif
                ScanChunkForSkipDepth(commandChunk);   // update depth counters only
                return;
            }

#if DEBUG
            TabbedText.WriteLine($"[INT‑ENTER] id={commandChunk.ID}  "
                          + $"VS={commandChunk.VirtualStackID}  "
                          + $"pVS={commandChunk.ParentVirtualStackID}");
#endif

            /* ────────── LOG: chunk entry ────────── */
            TabbedText.WriteLine(
                $"[CHUNK] id={commandChunk.ID,3}  cmds=[{commandChunk.StartCommandRange},{commandChunk.EndCommandRangeExclusive})  "
              + $"cosi→{commandChunk.StartSourceIndices}  codi→{commandChunk.StartDestinationIndices}  "
              + $"copyUp={Format(cp: commandChunk.CopyIncrementsToParent)}");

            static string Format(int[] cp) => cp == null ? "∅" : $"[{string.Join(",", cp)}]";

#if DEBUG
            TabbedText.WriteLine($"[CHUNK‑ENTER] id={commandChunk.ID}");
#endif

            /* ───── Roslyn path ──────────────────────────────────────────── */
            if (UseRoslyn)
            {
                bool compiled = ExecuteAutogeneratedCode(commandChunk);
#if DEBUG
                TabbedText.WriteLine(compiled
                    ? $"[CHUNK‑ROS]  id={commandChunk.ID}  ran‑compiled"
                    : $"[CHUNK‑ROS]  id={commandChunk.ID}  NO‑compiled‑method");
#endif
                if (compiled) return;
            }

            /* ───── Reflection‑Emit / interpreter path ───────────────────── */
            int startCmd = commandChunk.StartCommandRange;
            int endCmd = commandChunk.EndCommandRangeExclusive - 1;
            string key = $"Chunk_{startCmd}_{endCmd}";

            if (_compiledChunkMethods.TryGetValue(key, out var del))
            {
#if DEBUG
                TabbedText.WriteLine($"[CHUNK‑IL ]  id={commandChunk.ID}  delKey={key}");
#endif
                int cosi = commandChunk.StartSourceIndices;
                int codi = commandChunk.StartDestinationIndices;

                /* pass the shared condition flag by ref */
                del(commandChunk.VirtualStack,
                    OrderedSources,
                    OrderedDestinations,
                    ref cosi,
                    ref codi,
                    ref _condition);

#if DEBUG
                TabbedText.WriteLine($"[IL‑EXIT] id={commandChunk.ID}  cosi→{cosi}  codi→{codi}  vs0={commandChunk.VirtualStack[0]}");
#endif
                return;
            }

#if DEBUG
            TabbedText.WriteLine($"[CHUNK‑INT]  id={commandChunk.ID}  interp cmds={startCmd}..{endCmd}");
#endif
            ExecuteSectionOfCommands(
                new Span<double>(commandChunk.VirtualStack),
                startCmd,
                endCmd,
                commandChunk.StartSourceIndices,
                commandChunk.StartDestinationIndices);

#if DEBUG
            TabbedText.WriteLine($"[INT‑EXIT] id={commandChunk.ID}  vs0={commandChunk.VirtualStack[0]}");
#endif
        }



        /// <summary>
        /// Scan <paramref name="chunk"/> counting nested If / EndIf tokens, so that
        /// _globalSkipDepth is updated while all real work is skipped.
        /// </summary>
        private void ScanChunkForSkipDepth(ArrayCommandChunk chunk)
        {
            for (int i = chunk.StartCommandRange; i < chunk.EndCommandRangeExclusive; i++)
            {
                var t = UnderlyingCommands[i].CommandType;
                if (t == ArrayCommandType.If) _globalSkipDepth++;
                else if (t == ArrayCommandType.EndIf && _globalSkipDepth > 0)
                    _globalSkipDepth--;
            }
        }
        private bool ChunkContainsFlowControl(ArrayCommandChunk chunk)
        {
            for (int i = chunk.StartCommandRange; i < chunk.EndCommandRangeExclusive; i++)
            {
                var t = UnderlyingCommands[i].CommandType;
                if (t == ArrayCommandType.If || t == ArrayCommandType.EndIf)
                    return true;
            }
            return false;
        }
        /// <summary>
        /// For the command range [<paramref name="fromCmd"/>, <paramref name="toCmd"/>)  
        /// find the first <b>outer‑level</b> If and its matching EndIf.
        /// Returns (ifIndex, endIfIndex, bodySize).  If no pair found, ifIndex is –1.
        /// </summary>
        private (int ifIdx, int endIfIdx, int bodySize) FindOutermostIf(
                int fromCmd, int toCmd)
        {
            int depth = 0;
            int ifIdx = -1;
            for (int i = fromCmd; i < toCmd; i++)
            {
                var t = UnderlyingCommands[i].CommandType;
                if (t == ArrayCommandType.If)
                {
                    if (depth == 0 && ifIdx == -1)
                        ifIdx = i;                    // first outer‑level If
                    depth++;
                }
                else if (t == ArrayCommandType.EndIf)
                {
                    depth--;
                    if (depth == 0 && ifIdx != -1)
                        return (ifIdx, i, i - ifIdx - 1); // found matching EndIf
                }
            }
            return (-1, -1, 0);                       // no outer‑level If
        }


        /* small local helpers for the new traces */ // DEBUG -- delete after logging
        double Before(int idx, Span<double> virtualStack)
        {
            return (idx >= 0 && idx < virtualStack.Length) ? virtualStack[idx] : double.NaN;
        }

        private void ExecuteSectionOfCommands(
            Span<double> virtualStack,
            int startCommandIndex,
            int endCommandIndexInclusive,
            int currentOrderedSourceIndex,
            int currentOrderedDestinationIndex)
        {
#if DEBUG
            TabbedText.WriteLine($"[DBG] ExecuteSectionOfCommands: stackLen={virtualStack.Length}  " +
                            $"cmdRange=[{startCommandIndex}..{endCommandIndexInclusive}]  " +
                            $"srcStart={currentOrderedSourceIndex}  dstStart={currentOrderedDestinationIndex}");
#endif

            bool conditionMet = false;
            int commandIndex = startCommandIndex;

            while (commandIndex <= endCommandIndexInclusive)
            {
                ArrayCommand command = UnderlyingCommands[commandIndex];

                /* optional pre‑diagnostics for NextDestination */
                if (command.CommandType == ArrayCommandType.NextDestination)
                {
#if DEBUG
                    TabbedText.WriteLine($"[DST‑BEF] slice {CurrentCommandChunk.ID} cmd#{commandIndex} " +
                                    $"dstPtr={currentOrderedDestinationIndex}");
#endif
                }

                /* bounds checks (unchanged) */
                if (command.Index < 0 || command.Index >= virtualStack.Length)
                    TabbedText.WriteLine($"[ERROR] cmd#{commandIndex} ({command.CommandType}): " +
                                    $"Index={command.Index} out of [0..{virtualStack.Length - 1}]");

                if (command.SourceIndex >= 0 && command.SourceIndex >= virtualStack.Length)
                    TabbedText.WriteLine($"[ERROR] cmd#{commandIndex} ({command.CommandType}): " +
                                    $"SourceIndex={command.SourceIndex} out of [0..{virtualStack.Length - 1}]");

                if ((command.CommandType == ArrayCommandType.NextDestination ||
                     command.CommandType == ArrayCommandType.ReusedDestination) &&
                    currentOrderedDestinationIndex >= OrderedDestinations.Length)
                    TabbedText.WriteLine($"[ERROR] cmd#{commandIndex} ({command.CommandType}): " +
                                    $"dstPtr={currentOrderedDestinationIndex} >= OrderedDestinations.Length={OrderedDestinations.Length}");

                if (command.CommandType == ArrayCommandType.NextSource &&
                    currentOrderedSourceIndex >= OrderedSources.Length)
                    TabbedText.WriteLine($"[ERROR] cmd#{commandIndex} ({command.CommandType}): " +
                                    $"srcPtr={currentOrderedSourceIndex} >= OrderedSources.Length={OrderedSources.Length}");

                /*──────────────── switch over command type ───────────────*/
                switch (command.CommandType)
                {
                    case ArrayCommandType.Zero:
                        virtualStack[command.Index] = 0;
                        break;

                    case ArrayCommandType.CopyTo:
                        if (UseCheckpoints && command.Index == CheckpointTrigger)
                            Checkpoints?.Add(virtualStack[command.SourceIndex]);
                        else
                            virtualStack[command.Index] = virtualStack[command.SourceIndex];
                        break;

                    case ArrayCommandType.NextSource:
                        virtualStack[command.Index] = OrderedSources[currentOrderedSourceIndex++];
                        break;

                    case ArrayCommandType.NextDestination:
                        {
                            double value = virtualStack[command.SourceIndex];
#if DEBUG
                            TabbedText.WriteLine($"[OD‑IMM] NextDest  odIdx={currentOrderedDestinationIndex}  val={value}");
#endif
                            OrderedDestinations[currentOrderedDestinationIndex++] = value;
#if DEBUG
                            TabbedText.WriteLine($"[DST‑AFT] slice {CurrentCommandChunk.ID} dstPtr now {currentOrderedDestinationIndex}");
#endif
                        }
                        break;

                    case ArrayCommandType.ReusedDestination:
                        {
                            double value = virtualStack[command.SourceIndex];
#if DEBUG
                            double before = OrderedDestinations[command.Index];
                            TabbedText.WriteLine($"[OD‑IMM] ReusedDest idx={command.Index}  {before} += {value} → {before + value}");
#endif
                            OrderedDestinations[command.Index] += value;
                        }
                        break;

                    case ArrayCommandType.MultiplyBy:
                        virtualStack[command.Index] *= virtualStack[command.SourceIndex];
                        break;

                    /* arithmetic with verbose traces */
                    case ArrayCommandType.IncrementBy:
                        {
                            double oldVal = virtualStack[command.Index];
                            double delta = virtualStack[command.SourceIndex];
                            virtualStack[command.Index] = oldVal + delta;
#if DEBUG
                            TabbedText.WriteLine($"[INC] slice {CurrentCommandChunk.ID} cmd#{commandIndex} " +
                                            $"idx={command.Index}  {oldVal} + {delta} → {virtualStack[command.Index]}");
#endif
                        }
                        break;

                    case ArrayCommandType.DecrementBy:
                        {
                            double oldVal = virtualStack[command.Index];
                            double delta = virtualStack[command.SourceIndex];
                            virtualStack[command.Index] = oldVal - delta;
#if DEBUG
                            TabbedText.WriteLine($"[DEC] slice {CurrentCommandChunk.ID} cmd#{commandIndex} " +
                                            $"idx={command.Index}  {oldVal} - {delta} → {virtualStack[command.Index]}");
#endif
                        }
                        break;

                    /* comparisons */
                    case ArrayCommandType.EqualsOtherArrayIndex:
                        conditionMet = virtualStack[command.Index] == virtualStack[command.SourceIndex];
                        break;
                    case ArrayCommandType.NotEqualsOtherArrayIndex:
                        conditionMet = virtualStack[command.Index] != virtualStack[command.SourceIndex];
                        break;
                    case ArrayCommandType.GreaterThanOtherArrayIndex:
                        conditionMet = virtualStack[command.Index] > virtualStack[command.SourceIndex];
                        break;
                    case ArrayCommandType.LessThanOtherArrayIndex:
                        conditionMet = virtualStack[command.Index] < virtualStack[command.SourceIndex];
                        break;
                    case ArrayCommandType.EqualsValue:
                        conditionMet = virtualStack[command.Index] == command.SourceIndex;
                        break;
                    case ArrayCommandType.NotEqualsValue:
                        conditionMet = virtualStack[command.Index] != command.SourceIndex;
                        break;

                    /* flow control */
                    case ArrayCommandType.If:
                        if (!conditionMet)
                        {
                            int depth = 1;
                            while (depth > 0)
                            {
                                commandIndex++;
                                var ct = UnderlyingCommands[commandIndex].CommandType;
                                if (ct == ArrayCommandType.If) depth++;
                                else if (ct == ArrayCommandType.EndIf) depth--;
                                else if (ct == ArrayCommandType.NextSource) currentOrderedSourceIndex++;
                                else if (ct == ArrayCommandType.NextDestination) currentOrderedDestinationIndex++;
                            }
                            if (depth > 0) _globalSkipDepth += depth;
                        }
                        break;
                    case ArrayCommandType.EndIf:
                    case ArrayCommandType.Comment:
                    case ArrayCommandType.Blank:
                        break;
                    default:
                        throw new NotImplementedException();
                }

                commandIndex++;
            }
        }


        #endregion

        #region Logging

        [NonSerialized]
        ConcurrentDictionary<int, string> arrayValueAfterCommand = null;
        StringBuilder commandLog = new StringBuilder();
        private void LogCommand(int commandIndex, Span<double> array)
        {
            ArrayCommand command = UnderlyingCommands[commandIndex];
            if (command.CommandType == ArrayCommandType.If || command.CommandType == ArrayCommandType.EndIf || command.CommandType == ArrayCommandType.ReusedDestination || command.CommandType == ArrayCommandType.Blank)
                return;
            if (arrayValueAfterCommand == null || arrayValueAfterCommand.ContainsKey(commandIndex))
                arrayValueAfterCommand = new ConcurrentDictionary<int, string>();
            if (command.CommandType == ArrayCommandType.NextDestination)
                arrayValueAfterCommand[commandIndex] = $"{array[command.SourceIndex]} is next destination (from {command.SourceIndex}";
            else
                arrayValueAfterCommand[commandIndex] = $"{array[command.Index]} is in index {command.Index} from {command.SourceIndex} {(command.SourceIndex != -1 ? array[command.SourceIndex].ToString() : "")}";
        }

        private void PrintCommandLog()
        {
            var ordered = arrayValueAfterCommand.OrderBy(x => x.Key).ToList();
            foreach (var item in ordered)
                commandLog.AppendLine($"{item.Key}: {item.Value}");
        }

        #endregion

        #region Copying ordered sources

        public void PrepareOrderedSourcesAndDestinations(double[] array)
        {
            int sourcesCount = OrderedSourceIndices.Count();
            int destinationsCount = OrderedDestinationIndices.Count();
            if (OrderedSources == null)
            {
                OrderedSources = new double[sourcesCount];
                OrderedDestinations = new double[destinationsCount];
            }
            Parallelizer.Go(DoParallel, 0, sourcesCount, n =>
            {
                OrderedSources[n] = array[OrderedSourceIndices[n]];
            });
            Array.Clear(OrderedDestinations, 0, destinationsCount);
        }

        /// <summary>
        /// Copies (and, when necessary, merges) the values that were queued in
        /// <see cref="OrderedDestinations"/> back into the real data array.
        /// The result now matches the parallel path exactly: every original slot
        /// is written **once** with its final total – never “old + delta”.
        /// </summary>
        public void CopyOrderedDestinations(double[] array)
        {
#if DEBUG
            TabbedText.WriteLine("══════════════════════════════════════════════════════");
#endif
            int startOrderedDestinationIndex = 0;
            int endOrderedDestinationIndexExclusive = OrderedDestinationIndices.Count();

#if DEBUG
            TabbedText.WriteLine($"[OD‑HDR] copy {startOrderedDestinationIndex}..{endOrderedDestinationIndexExclusive - 1}  " +
                            $"mode={(DoParallel ? "parallel" : "serial")}");
#endif

            /* ───────────────────────────── 1. PARALLEL ────────────────────────── */
            if (DoParallel)
            {
                // (unchanged – still builds the inverted map and assigns totals)
                if (OrderedDestinationsInverted == null)
                {
                    OrderedDestinationsInverted = new List<int>[array.Length];

                    for (int currentOrderedDestinationIndex = startOrderedDestinationIndex;
                         currentOrderedDestinationIndex < endOrderedDestinationIndexExclusive;
                         currentOrderedDestinationIndex++)
                    {
                        int destIdx = OrderedDestinationIndices[currentOrderedDestinationIndex];
                        (OrderedDestinationsInverted[destIdx] ??=
                            new List<int>()).Add(currentOrderedDestinationIndex);
#if DEBUG
                        TabbedText.WriteLine($"[OD‑MAP] dst={destIdx}  srcODIdx={currentOrderedDestinationIndex}");
#endif
                    }

                    int nonNullCount = OrderedDestinationsInverted.Count(x => x != null);
                    OrderedDestinationsInvertedWithTarget =
                        new (int targetIndex, List<int> sourceIndices)[nonNullCount];

                    int t = 0;
                    for (int i = 0; i < array.Length; i++)
                        if (OrderedDestinationsInverted[i] != null)
                            OrderedDestinationsInvertedWithTarget[t++] = (i, OrderedDestinationsInverted[i]);
                }
                else if (OrderedDestinationsInverted.Length != array.Length)
                    throw new Exception();

                int numTargets = OrderedDestinationsInvertedWithTarget.Length;

                Parallelizer.Go(true, 0, numTargets, i =>
                {
                    var (targetIndex, srcList) = OrderedDestinationsInvertedWithTarget[i];
                    if (srcList == null) return;

                    double total = 0;
                    foreach (int src in srcList)
                    {
                        total += OrderedDestinations[src];
#if DEBUG
                        TabbedText.WriteLine($"[OD‑ACC] tgt={targetIndex}  +=" +
                                        $"OD[{src}]={OrderedDestinations[src]}");
#endif
                    }
#if DEBUG
                    TabbedText.WriteLine($"[OD‑WR ] tgt={targetIndex}  total={total}");
#endif
                    array[targetIndex] = total;
                });
            }

            /* ───────────────────────────── 2. SERIAL ──────────────────────────── */
            else
            {
                // Aggregate first (handles duplicates) → single overwrite per slot.
                var totals = new Dictionary<int, double>(endOrderedDestinationIndexExclusive);

                for (int idx = startOrderedDestinationIndex;
                     idx < endOrderedDestinationIndexExclusive;
                     idx++)
                {
                    int dest = OrderedDestinationIndices[idx];
                    double delta = OrderedDestinations[idx];

                    if (totals.TryGetValue(dest, out double running))
                        totals[dest] = running + delta;
                    else
                        totals.Add(dest, delta);

#if DEBUG
                    TabbedText.WriteLine($"[OD‑ACC] dst={dest}  += {delta}  runningTotal={totals[dest]}");
#endif
                }

                foreach (var (dest, total) in totals)
                {
#if DEBUG
                    double before = array[dest];
                    TabbedText.WriteLine($"[OD‑WR ] dst={dest}  {before} → {total}");
#endif
                    array[dest] = total;
                }
            }

#if DEBUG
            TabbedText.WriteLine("[OD‑END] first 10 array vals → " +
                            string.Join(", ", array.Take(10)));
            TabbedText.WriteLine("══════════════════════════════════════════════════════");
#endif
        }


        #endregion

        #region Logging

        // DEBUG
        public void LogBalancedSegments(int printEvery = 10_000)
        {
            int depth = 0;
            int segLen = 0;
            int longest = 0;
            int segStart = 0;

            for (int i = 0; i < MaxCommandIndex; i++)
            {
                var t = UnderlyingCommands[i].CommandType;
                if (t == ArrayCommandType.If) depth++;
                if (t == ArrayCommandType.EndIf) depth--;

                segLen++;

                if (depth == 0)
                {
                    // a balanced segment just closed
                    if (segLen >= printEvery)
                        Console.WriteLine($"SEG [{segStart,8:N0}–{i,8:N0}]  len={segLen:N0}");

                    if (segLen > longest) longest = segLen;
                    segStart = i + 1;
                    segLen = 0;
                }
            }
            Console.WriteLine($"Longest balanced segment = {longest:N0} commands");
        }

        // DEBUG
        public void DumpLeafRanges(string tag)
        {
            Console.WriteLine($"── Leaf dump {tag} ──");
            CommandTree.WalkTree(nodeObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nodeObj;
                if (n.Branches == null || n.Branches.Length == 0)
                {
                    var s = n.StoredValue;
                    int size = s.EndCommandRangeExclusive - s.StartCommandRange;
                    Console.WriteLine($"leaf  [{s.StartCommandRange,8:N0},{s.EndCommandRangeExclusive,8:N0})  len={size:N0}");
                }
            });
        }

        #endregion

        #region Breaking up large chunks

        // ----------  helper record  ----------
        public struct IfBodyInfo
        {
            public int IfIndex;            // position of the “If” command
            public int EndIfIndex;         // position of its matching “EndIf”
            public int BodySize;           // # commands strictly inside the pair
            public int SourcesInBody;      // # NextSource commands in the body
            public int DestinationsInBody; // # NextDestination commands in the body
        }

        // ----------  scanner  ----------
        /// <summary>
        /// Examine the command span <c>[start, endExclusive)</c> (typically a leaf
        /// chunk) and return information for every <c>If … EndIf</c> pair whose body
        /// exceeds <see cref="MaxCommandsPerChunk"/>.
        /// The list is ordered by the position of the <c>If</c> tokens (inner‑most
        /// bodies are reported before their enclosing parents).
        /// </summary>
        private List<IfBodyInfo> FindIfBodies(int start, int endExclusive)
        {
            var largeBodies = new List<IfBodyInfo>();
            var openIfs = new Stack<int>();   // holds command indices of open “If”s

            for (int i = start; i < endExclusive; i++)
            {
                var type = UnderlyingCommands[i].CommandType;

                if (type == ArrayCommandType.If)
                {
                    openIfs.Push(i);
                }
                else if (type == ArrayCommandType.EndIf)
                {
                    if (openIfs.Count == 0)
                        throw new InvalidOperationException($"Unmatched EndIf at cmd {i}.");

                    int ifIdx = openIfs.Pop();
                    int bodyStart = ifIdx + 1;
                    int bodyEndExcl = i;                 // EndIf not part of body
                    int bodySize = bodyEndExcl - bodyStart;

                    if (bodySize > MaxCommandsPerChunk)   // only “too big” bodies matter
                    {
                        int srcCnt = 0, dstCnt = 0;

                        for (int j = bodyStart; j < bodyEndExcl; j++)
                        {
                            var t = UnderlyingCommands[j].CommandType;
                            if (t == ArrayCommandType.NextSource) srcCnt++;
                            else if (t == ArrayCommandType.NextDestination) dstCnt++;
                        }

                        largeBodies.Add(new IfBodyInfo
                        {
                            IfIndex = ifIdx,
                            EndIfIndex = i,
                            BodySize = bodySize,
                            SourcesInBody = srcCnt,
                            DestinationsInBody = dstCnt
                        });
                    }
                }
            }

            if (openIfs.Count != 0)
                throw new InvalidOperationException("Unmatched If/EndIf in command list.");

            largeBodies.Sort((a, b) => - a.IfIndex.CompareTo(b.IfIndex));


            return largeBodies;
        }


        /// <summary>
        /// Detect oversized leaves that contain an outer‑level If…EndIf pair and
        /// hoist them into a Conditional gate with size‑bounded children.  All the
        /// detailed work is delegated to <see cref="HoistPlanner"/> (read‑only pass)
        /// and <see cref="HoistMutator"/> (mutation pass).
        /// </summary>
        private void HoistAndSplitLargeIfBodies()
        {
            // 1) Ensure we have at least a trivial one‑leaf tree to analyse.
            var root = HoistMutator.EnsureTreeExists(this);

            // 2) Build a read‑only plan of which leaves need hoisting.
            var planner = new HoistPlanner(UnderlyingCommands, MaxCommandsPerChunk);
            var plan = planner.BuildPlan(root);

            // 3) If nothing to do, return immediately.
            if (plan.Count == 0)
                return;

            // 4) Apply the mutations in‑place (gate insertion + body slicing).
            HoistMutator.ApplyPlan(this, plan);

            // 5) OPTIONAL: refresh the cached pretty‑print string so that any
            //    subsequent debugging or assertions show the new structure.
            if (RecordCommandTreeString)
                CommandTreeString = CommandTree.ToString();
        }


        /*══════════════════════════════════════════════════════════════════
         *  High‑level flow
         *  ─────────────────
         *  0.  locate If‑body span                               (FindBodySpan)
         *  1.  cut the body into slices ≤ MaxCommandsPerChunk    (CreateSlices)
         *  2.  build virtual‑stack metadata for gate + slices    (BuildStackInfo)
         *  3.  attach CopyIncrementsToParent lists where needed  (AttachCopyLists)
         *══════════════════════════════════════════════════════════════════*/
        public void SliceBodyIntoChildren(NWayTreeStorageInternal<ArrayCommandChunk> gate)
        {
            /* 0️⃣ Locate the outermost If…EndIf inside this gate */
            (int ifIdx, int endIfIdx) = FindBodySpan(gate.StoredValue);
            if (ifIdx < 0) return;                          // nothing to do

            /* 1️⃣ Slice the body and wire children under the gate */
            var slices = CreateSlices(gate, ifIdx, endIfIdx);

            /* 2️⃣ Ensure every node (gate + slices) has stack metadata */
            BuildStackInfo(gate, slices);

            /* 3️⃣ Add CopyIncrementsToParent when a slice owns its own stack */
            AttachCopyLists(gate.StoredValue, slices);
        }

        /*──────────────────────── helpers ───────────────────────*/

        private (int ifIdx, int endIfIdx) FindBodySpan(ArrayCommandChunk g)
        {
            var pair = FindOutermostIf(g.StartCommandRange, g.EndCommandRangeExclusive);
            return (pair.ifIdx, pair.endIfIdx);
        }

        /// <summary>
        /// Split the If‑body held by <paramref name="gate"/> into child slices
        /// that each contain at most <c>MaxCommandsPerChunk</c> commands.
        /// The method now also assigns the *correct* ordered‑source (cosi) and
        /// ordered‑destination (codi) pointers to every child, so siblings start
        /// exactly where the previous slice left off.
        /// </summary>
        private IList<NWayTreeStorageInternal<ArrayCommandChunk>> CreateSlices(
                NWayTreeStorageInternal<ArrayCommandChunk> gate,
                int ifIdx,
                int endIfIdxExcl)
        {
            int bodyStart = ifIdx + 1, bodyEnd = endIfIdxExcl;           // EndIf excluded
            if (bodyStart >= bodyEnd)
                return Array.Empty<NWayTreeStorageInternal<ArrayCommandChunk>>();

            var slices = new List<NWayTreeStorageInternal<ArrayCommandChunk>>();
            var gInfo = gate.StoredValue;

            // running ordered‑source / ordered‑destination pointers, inherited from gate
            int curSrcIdx = gInfo.StartSourceIndices;
            int curDstIdx = gInfo.StartDestinationIndices;

            int slicePos = bodyStart;
            byte bId = 1;                                           // 0 = prefix slice

            while (slicePos < bodyEnd && bId < byte.MaxValue)
            {
                /* 1️⃣  decide slice end, respecting nesting depth and MaxCommandsPerChunk */
                int sliceEnd = FindSliceEnd(slicePos, bodyEnd, MaxCommandsPerChunk);

                /* 2️⃣  count NextSource / NextDestination inside the slice */
                int srcIncr = 0, dstIncr = 0;
                for (int i = slicePos; i < sliceEnd; i++)
                {
                    var t = UnderlyingCommands[i].CommandType;
                    if (t == ArrayCommandType.NextSource) srcIncr++;
                    if (t == ArrayCommandType.NextDestination) dstIncr++;
                }

                /* 3️⃣  create child chunk and assign *accurate* pointer ranges */
                var child = MakeChildChunk(gate, gInfo, slicePos, sliceEnd);
                var info = child.StoredValue;

                info.RequiresPrivateStack = true;
                info.StartSourceIndices = curSrcIdx;
                info.EndSourceIndicesExclusive = curSrcIdx + srcIncr;
                info.StartDestinationIndices = curDstIdx;
                info.EndDestinationIndicesExclusive = curDstIdx + dstIncr;

                /* 4️⃣  wire into tree, collect for caller */
                gate.SetBranch(bId++, child);
                slices.Add(child);

                /* 5️⃣  advance cumulative pointers + move to next slice */
                curSrcIdx += srcIncr;
                curDstIdx += dstIncr;
                slicePos = sliceEnd;
            }

            /* gate now spans If … EndIf inclusive */
            gInfo.EndCommandRangeExclusive = endIfIdxExcl + 1;
            gInfo.LastChild = (byte)(bId - 1);
#if DEBUG
            TabbedText.WriteLine($"[CREATESLICES] Gate chunk {gInfo.ID} will execute (Skip=false)");
#endif
            gInfo.Skip = false;        // gate must not re‑execute body

#if DEBUG
            /* one‑time diagnostic dump for the slices we just built */
            foreach (var s in slices)
            {
                var c = s.StoredValue;
                TabbedText.WriteLine(
                    $"[SLICE] id={c.ID,3}  cmds=[{c.StartCommandRange},{c.EndCommandRangeExclusive})  " +
                    $"cosi {c.StartSourceIndices}->{c.EndSourceIndicesExclusive}  " +
                    $"codi {c.StartDestinationIndices}->{c.EndDestinationIndicesExclusive}");
            }
#endif

            return slices;
        }
        // ──────────────────────────────────────────────────────────────────────────────


        private void BuildStackInfo(
        NWayTreeStorageInternal<ArrayCommandChunk> gate,
        IEnumerable<NWayTreeStorageInternal<ArrayCommandChunk>> slices)
        {
            /* gate must have a stack BEFORE we wire its children */
            SetupVirtualStack(gate);
            SetupVirtualStackRelationships(gate);

            foreach (var s in slices)
            {
                SetupVirtualStack(s);
                SetupVirtualStackRelationships(s);
#if DEBUG
                var c = s.StoredValue;
                TabbedText.WriteLine(
                    $"[STACK‑INFO] id={c.ID}  VS={c.VirtualStackID}  "
                  + $"pVS={c.ParentVirtualStackID}  "
                  + $"ChildrenParallelizable={c.ChildrenParallelizable}");
#endif
            }
        }


        /// <summary>
        /// Find every slice that owns a private virtual‑stack array and make sure
        /// its **entire set of writes** (every slot that is written at least once)
        /// is merged back to the parent.  This fixes the case where the last slice
        /// of a hoisted If‑body had no CopyIncrementsToParent list and its delta
        /// was silently lost.
        /// </summary>
        /// <summary>
        /// For every child slice that owns its own virtual‑stack array, ensure its full
        /// read/write footprint is merged into the parent.  Then give the gate itself a
        /// copy‑list that forwards the accumulated delta one level up.
        /// </summary>
        /// <summary>
        /// For every slice that **owns a private virtual‑stack array** we
        /// (1) give the slice its own CopyIncrementsToParent list, *and*  
        /// (2) – if the gate itself also owns a private stack – build the
        /// union of those indices and assign it to the gate, so the gate’s
        /// deltas are merged one level higher.
        ///
        /// This restores the lost “+1 +2 ⇒ +3” behaviour that the failing
        /// test is checking.
        /// </summary>
        /// <summary>
        /// Give every child slice (and, when needed, the gate itself)
        /// a complete CopyIncrementsToParent list so that no delta is lost.
        /// </summary>
        private void AttachCopyLists(
                ArrayCommandChunk gateInfo,
                IList<NWayTreeStorageInternal<ArrayCommandChunk>> slices)
        {
            var unionForGate = new HashSet<int>();

            foreach (var slice in slices)
            {
                var info = slice.StoredValue;

                if (ReferenceEquals(info.VirtualStack, gateInfo.ParentVirtualStack))
                    continue;            // ← slice shares the root stack, no merge needed

                /* ── skip if slice shares its parent or never writes ─────────────── */
                if (ReferenceEquals(info.VirtualStack, info.ParentVirtualStack) ||
                    info.ParentVirtualStack == null ||
                    info.LastSetInStack == null)
                    continue;

                /* ── build the slice‑local copy list ─────────────────────────────── */
                var toCopy = new List<int>();
                for (int i = 0; i < info.LastSetInStack.Length; i++)
                    if (info.LastSetInStack[i] != null)
                        toCopy.Add(i);

                if (toCopy.Count == 0) continue;

                info.CopyIncrementsToParent = toCopy.ToArray();
#if DEBUG
                TabbedText.WriteLine($"[SLICE‑INFO] child {info.ID} CopyInc=[{string.Join(",", toCopy)}]");
#endif
                /* ── remember for the gate’s own merge list ─────────────────────── */
                foreach (int idx in toCopy) unionForGate.Add(idx);
            }

            /* ── if the gate has its own stack, it must also merge up ───────────── */
            bool gateHasPrivateStack =
                    gateInfo.ParentVirtualStack != null &&
                    !ReferenceEquals(gateInfo.VirtualStack, gateInfo.ParentVirtualStack);

            if (unionForGate.Count > 0)
                gateInfo.CopyIncrementsToParent = unionForGate.ToArray();
#if DEBUG
            if (gateHasPrivateStack)
                TabbedText.WriteLine($"[GATE‑INFO] gate {gateInfo.ID} CopyInc=[{string.Join(",", unionForGate)}]");
            ValidateIncrementCopying(gateInfo, slices);
#endif
        }

        /// Return the first command index ≥ <paramref name="sliceStart"/> that:
        ///   • brings nesting depth back to 0, AND
        ///   • either reaches <paramref name="max"/> commands or hits <paramref name="bodyEnd"/>.
        private int FindSliceEnd(int sliceStart, int bodyEnd, int max)
        {
            int depth = 0, sliceEnd = sliceStart;
            while (sliceEnd < bodyEnd)
            {
                var t = UnderlyingCommands[sliceEnd].CommandType;
                if (t == ArrayCommandType.If) depth++;
                if (t == ArrayCommandType.EndIf) depth--;

                sliceEnd++;

                bool reachedMax = sliceEnd - sliceStart >= max;
                bool atBoundary = depth == 0 && (reachedMax || sliceEnd == bodyEnd);
                if (atBoundary) break;
            }
            return sliceEnd;
        }


        /// Create a child chunk that copies stack/buffer metadata from <paramref name="gInfo"/>.
        private NWayTreeStorageInternal<ArrayCommandChunk> MakeChildChunk(
        NWayTreeStorageInternal<ArrayCommandChunk> gate,
        ArrayCommandChunk gInfo,
        int sliceStart,
        int sliceEnd)
        {
            var child = new NWayTreeStorageInternal<ArrayCommandChunk>(gate);
            child.StoredValue = new ArrayCommandChunk
            {
                ChildrenParallelizable = false,          // (unchanged)
                StartCommandRange = sliceStart,
                EndCommandRangeExclusive = sliceEnd,

                StartSourceIndices = gInfo.StartSourceIndices,
                EndSourceIndicesExclusive = gInfo.EndSourceIndicesExclusive,
                StartDestinationIndices = gInfo.StartDestinationIndices,
                EndDestinationIndicesExclusive = gInfo.EndDestinationIndicesExclusive,

                ExecId = _nextExecId++
            };

#if DEBUG
            TabbedText.WriteLine($"[MAKE] new slice {child.StoredValue.ID} created  " +
                            $"ChildrenParallelizable={child.StoredValue.ChildrenParallelizable}");
#endif
            return child;
        }


        #endregion

        #region Logging
        // DEBUG
        public void DumpLeafIfUnbalanced(NWayTreeStorageInternal<ArrayCommandChunk> leaf)
        {
            int ifCount = 0, endIfCount = 0;
            var st = leaf.StoredValue;

            for (int i = st.StartCommandRange; i < st.EndCommandRangeExclusive; i++)
            {
                var t = UnderlyingCommands[i].CommandType;
                if (t == ArrayCommandType.If) ifCount++;
                if (t == ArrayCommandType.EndIf) endIfCount++;
            }

            if (ifCount != endIfCount)
            {
                TabbedText.WriteLine(
                   $"❌  Unbalanced leaf ID={st.ID}  if={ifCount}  endif={endIfCount}  " +
                   $"range=[{st.StartCommandRange},{st.EndCommandRangeExclusive})");

                for (int i = st.StartCommandRange; i < st.EndCommandRangeExclusive; i++)
                    TabbedText.WriteLine($"   {i,8}: {UnderlyingCommands[i]}");
            }
        }
        [Conditional("DEBUG")]
        public void DumpLeafSummary(string tag = "")
        {
            TabbedText.WriteLine($"── Tree dump {tag} ──");
            CommandTree.WalkTree(nodeObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nodeObj;
                if (n.Branches != null && n.Branches.Length > 0) return; // leaves only
                var s = n.StoredValue;
                int ifs = 0, endIfs = 0;
                for (int i = s.StartCommandRange; i < s.EndCommandRangeExclusive; i++)
                {
                    var t = UnderlyingCommands[i].CommandType;
                    if (t == ArrayCommandType.If) ifs++;
                    if (t == ArrayCommandType.EndIf) endIfs++;
                }
                TabbedText.WriteLine(
                    $"leaf ID={s.ID,3}  name={s.Name,-12}  " +
                    $"exec={s.ExecId,4}  if={ifs}  endif={endIfs}  " +
                    $"range=[{s.StartCommandRange},{s.EndCommandRangeExclusive})");
            });
        }

        [Conditional("DEBUG")]
        [Conditional("DEBUG")]
        private void ValidateIncrementCopying(
    ArrayCommandChunk gate,
    IList<NWayTreeStorageInternal<ArrayCommandChunk>> slices)
        {
            /* ❶  Build the union of indices every CHILD *that writes* will merge up */
            var expectedUnion = new HashSet<int>();

            foreach (var node in slices)
            {
                var child = node.StoredValue;

                bool hasPrivateStack =
                       child.ParentVirtualStack != null &&
                      !ReferenceEquals(child.VirtualStack, child.ParentVirtualStack);

                if (!hasPrivateStack)
                    continue;                        // shared stack → no merge list needed

                bool childWrites =
                    child.LastSetInStack != null &&
                    child.LastSetInStack.Any(x => x != null);

                if (childWrites)
                {
                    Debug.Assert(child.CopyIncrementsToParent != null &&
                                 child.CopyIncrementsToParent.Length > 0,
                        $"❌ slice {child.ID} owns a stack *and writes* but has no CopyInc list");

                    foreach (int idx in child.CopyIncrementsToParent)
                        expectedUnion.Add(idx);
                }
                else
                {   // never wrote → ensure we *didn’t* create a pointless list
                    Debug.Assert(child.CopyIncrementsToParent == null ||
                                 child.CopyIncrementsToParent.Length == 0,
                        $"❌ slice {child.ID} never writes but has CopyInc entries");
                }
            }

            /* ❷  If the gate itself owns a private stack, it must copy the union ‑‑
                   but only when that union is non‑empty                                */
            bool gateHasPrivateStack =
                   gate.ParentVirtualStack != null &&
                  !ReferenceEquals(gate.VirtualStack, gate.ParentVirtualStack);

            if (!gateHasPrivateStack)
                return;

            if (expectedUnion.Count == 0)
            {
                Debug.Assert(gate.CopyIncrementsToParent == null ||
                             gate.CopyIncrementsToParent.Length == 0,
                    $"❌ gate {gate.ID} should have no CopyInc entries – children wrote nothing");
            }
            else
            {
                Debug.Assert(gate.CopyIncrementsToParent != null,
                    $"❌ gate {gate.ID} owns a stack but CopyInc list is null");

                Debug.Assert(expectedUnion.SetEquals(gate.CopyIncrementsToParent),
                    $"❌ gate {gate.ID} CopyInc mismatch – expected " +
                    $"[{string.Join(',', expectedUnion)}], actual " +
                    $"[{string.Join(',', gate.CopyIncrementsToParent ?? Array.Empty<int>())}]");
            }
        }



#if DEBUG
        void LogFlags(string phase)
        {
            CommandTree.WalkTree(n =>
            {
                var c = ((NWayTreeStorageInternal<ArrayCommandChunk>)n).StoredValue;
                if (!c.ChildrenParallelizableLogged)
                {
                    TabbedText.WriteLine($"[FLAG‑{phase}] id={c.ID,4}  ChildrenParallelizable={c.ChildrenParallelizable}");
                    c.ChildrenParallelizableLogged = true;    // print only first time we visit
                }
            });
        }
#endif


        #endregion
    }
}
