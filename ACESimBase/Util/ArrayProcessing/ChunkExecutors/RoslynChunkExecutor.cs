using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using ACESimBase.Util.Debugging;    // for TabbedText
using ACESimBase.Util.ArrayProcessing;
using ACESimBase.Util.NWayTreeStorage;
using static ACESimBase.Util.ArrayProcessing.ArrayCommandList;

namespace ACESimBase.Util.ArrayProcessing.ChunkExecutors
{
    public class RoslynChunkExecutor : IChunkExecutor
    {
        private readonly bool _useCheckpoints;
        private readonly StringBuilder CodeGenerationBuilder = new StringBuilder();
        private readonly HashSet<string> CompiledFunctions = new HashSet<string>();
        private readonly List<ArrayCommandChunk> _scheduled = new List<ArrayCommandChunk>();
        private Type AutogeneratedCodeType;

        public RoslynChunkExecutor(bool useCheckpoints)
        {
            _useCheckpoints = useCheckpoints;
        }

        public void AddToGeneration(ArrayCommandChunk chunk)
        {
            int start = chunk.StartCommandRange;
            int end = chunk.EndCommandRangeExclusive - 1;
            string fn = $"Execute{start}to{end}";
            if (CompiledFunctions.Add(fn))
                _scheduled.Add(chunk);
        }

        public void PerformGeneration()
        {
            if (_scheduled.Count == 0)
                return;

            var sw = Stopwatch.StartNew();
            TabbedText.WriteLine("Autogenerating and compiling code...");

            // 1) Header + optional checkpoints
            string checkpoints = "";
            if (_useCheckpoints)
                checkpoints = $@"
        public static List<double> Checkpoints = new List<double>();
        public static void ResetCheckpoints()
        {{
            Checkpoints = new List<double>();
        }}";

            CodeGenerationBuilder.AppendLine("using System;");
            CodeGenerationBuilder.AppendLine("using System.Collections.Generic;");
            CodeGenerationBuilder.AppendLine();
            CodeGenerationBuilder.AppendLine("namespace CommandTreeCodegen");
            CodeGenerationBuilder.AppendLine("{");
            CodeGenerationBuilder.AppendLine("  public static class AutogeneratedCode");
            CodeGenerationBuilder.AppendLine("  {");
            CodeGenerationBuilder.AppendLine(checkpoints);
            CodeGenerationBuilder.AppendLine();

            // 2) Emit one method per scheduled chunk
            foreach (var chunk in _scheduled)
                GenerateSourceTextForChunk(chunk);

            // 3) Close class & namespace
            CodeGenerationBuilder.AppendLine("  }");
            CodeGenerationBuilder.AppendLine("}");

            // 4) Compile via StringToCode
            string code = CodeGenerationBuilder.ToString();
            CodeGenerationBuilder.Clear();
            AutogeneratedCodeType = StringToCode.LoadCode(code, "CommandTreeCodegen.AutogeneratedCode");

            sw.Stop();
            TabbedText.WriteLine($"...Code autogeneration complete after {sw.ElapsedMilliseconds} ms");

            _scheduled.Clear();
        }

        public void Execute(
            ArrayCommandChunk chunk,
            double[] vs,
            double[] os,
            double[] od,
            ref int cosi,
            ref int codi,
            ref bool condition)
        {
            int start = chunk.StartCommandRange;
            int end = chunk.EndCommandRangeExclusive - 1;
            string fn = $"Execute{start}to{end}";

            var mi = AutogeneratedCodeType.GetMethod(fn, BindingFlags.Public | BindingFlags.Static);
            if (mi == null)
                throw new MissingMethodException($"Autogenerated method {fn} not found.");

            object[] args = { vs, os, od, cosi, codi, condition };
            mi.Invoke(null, args);

            // Pull back by‑ref parameters
            cosi = (int)args[3];
            codi = (int)args[4];
            condition = (bool)args[5];

            // Sync chunk indices
            chunk.StartSourceIndices = cosi;
            chunk.StartDestinationIndices = codi;
        }

        /// <summary>
        /// Copied from ArrayCommandList.GenerateSourceTextForChunk, but scoped to one chunk.
        /// Handles Zero; extend for other opcodes as needed.
        /// </summary>
        private void GenerateSourceTextForChunk(ArrayCommandChunk c)
        {
            int start = c.StartCommandRange;
            int end = c.EndCommandRangeExclusive - 1;
            string fn = $"Execute{start}to{end}";

            CompiledFunctions.Add(fn);
            CodeGenerationBuilder.AppendLine($@"    public static void {fn}(
      double[] vs, double[] os, double[] od,
      ref int cosi, ref int codi, ref bool condition)
    {{");

            // Emit the Zero command; you can expand this switch for other commands
            foreach (var cmd in c.ParentList.UnderlyingCommands
                                           .Skip(start)
                                           .Take(end - start + 1))
            {
                switch (cmd.CommandType)
                {
                    case ArrayCommandType.Zero:
                        CodeGenerationBuilder.AppendLine($"      vs[{cmd.Index}] = 0;");
                        break;

                    default:
                        CodeGenerationBuilder.AppendLine($"      // {cmd.CommandType} not implemented");
                        break;
                }
            }

            CodeGenerationBuilder.AppendLine("    }");
            CodeGenerationBuilder.AppendLine();
        }
    }
}
