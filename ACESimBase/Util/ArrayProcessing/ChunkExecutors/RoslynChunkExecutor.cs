// ------------------------------------------------------------------------------------
//  RoslynChunkExecutor.cs
//  Autogenerates C# for ArrayCommand chunks using Roslyn and the depth‑aware
//  LocalsAllocationPlan.  Relies on ChunkExecutorHelpers for depth/interval
//  and dirty‑bit bookkeeping.
// ------------------------------------------------------------------------------------

namespace ACESimBase.Util.ArrayProcessing.ChunkExecutors;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Text;
using ACESimBase.Util.Debugging;         // TabbedText
using ACESimBase.Util.ArrayProcessing;
using ACESimBase.Util.CodeGen;

internal sealed class RoslynChunkExecutor : ChunkExecutorBase
{
    private readonly bool _useCheckpoints;
    private readonly LocalsAllocationPlan _plan;

    private readonly StringBuilder _codeGen = new();
    private readonly List<ArrayCommandChunk> _scheduled = new();
    private readonly Dictionary<ArrayCommandChunk, ArrayCommandChunkDelegate> _compiled = new();
    private Type _autogenType;

    public RoslynChunkExecutor(ArrayCommand[] cmds, int start, int end, bool useCheckpoints, bool localVariableReuse = true)
        : base(cmds, start, end)
    {
        _useCheckpoints = useCheckpoints;
        _plan = localVariableReuse ? LocalVariablePlanner.PlanLocals(cmds, start, end) : null;
    }

    /*───────────────────────────────────────────────────────────────────────*/
    /*  Generation API                                                      */
    /*───────────────────────────────────────────────────────────────────────*/

    public override void AddToGeneration(ArrayCommandChunk chunk)
    {
        if (!_compiled.ContainsKey(chunk) && !_scheduled.Contains(chunk))
            _scheduled.Add(chunk);
    }

    public override void PerformGeneration()
    {
        if (_scheduled.Count == 0) return;

        // Build file header
        _codeGen.AppendLine("using System;\nusing System.Collections.Generic;\nnamespace CommandTreeCodegen\n{");
        _codeGen.AppendLine("  public static class AutogeneratedCode\n  {");
        if (_useCheckpoints)
            _codeGen.AppendLine("    public static List<double> Checkpoints = new();\n");

        foreach (var chunk in _scheduled)
            EmitSourceForChunk(chunk);

        _codeGen.AppendLine("  }\n}");

        _autogenType = StringToCode.LoadCode(_codeGen.ToString(), "CommandTreeCodegen.AutogeneratedCode");
        _codeGen.Clear();

        foreach (var chunk in _scheduled)
        {
            int s = chunk.StartCommandRange;
            int e = chunk.EndCommandRangeExclusive - 1;
            string fn = $"Execute{s}to{e}";
            var mi = _autogenType!.GetMethod(fn, BindingFlags.Public | BindingFlags.Static)!;
            var del = (ArrayCommandChunkDelegate)Delegate.CreateDelegate(typeof(ArrayCommandChunkDelegate), mi);
            _compiled[chunk] = del;
        }
        _scheduled.Clear();
    }

    public override void Execute(ArrayCommandChunk chunk, double[] vs, double[] os, double[] od,
                                 ref int cosi, ref int codi, ref bool condition)
    {
        var del = _compiled[chunk];
        del(vs, os, od, ref cosi, ref codi, ref condition);
        chunk.StartSourceIndices = cosi;
        chunk.StartDestinationIndices = codi;
    }

    /*───────────────────────────────────────────────────────────────────────*/
    /*  Code‑generation internals                                           */
    /*───────────────────────────────────────────────────────────────────────*/

    private void EmitSourceForChunk(ArrayCommandChunk c)
    {
        int start = c.StartCommandRange;
        int end = c.EndCommandRangeExclusive - 1;
        string fn = $"Execute{start}to{end}";

        // Helpers
        var depthMap = new DepthMap(Commands.ToArray(), start, end + 1);
        var intervals = _plan != null ? new IntervalIndex(_plan) : new IntervalIndex();
        var bind = new LocalBindingState(_plan?.LocalCount ?? 0);
        var cb = new CodeBuilder();

        // ── method signature
        cb.AppendLine($"    public static void {fn}(double[] vs, double[] os, double[] od, ref int cosi, ref int codi, ref bool condition)");
        cb.AppendLine("    {"); cb.Indent();

        // ── declare locals l0..lN
        if (_plan?.LocalCount > 0)
        {
            cb.AppendLine($"double {string.Join(", ", Enumerable.Range(0, _plan!.LocalCount).Select(i => $"l{i}"))};");
            cb.AppendLine();
        }

        // ── per‑command emission loop
        for (int i = start; i <= end; i++)
        {
            var cmd = Commands[i - start];
            int depth = depthMap.GetDepth(i);

            // Intervals starting at this cmd
            if (intervals.TryStart(i, out int slot))
            {
                int local = _plan!.SlotToLocal[slot];
                if (!bind.TryReuse(local, slot, depth, out int flushSlot))
                {
                    // cannot reuse – local still reserved; allocate comment note
                }
                else
                {
                    if (flushSlot != -1)
                        cb.AppendLine($"vs[{flushSlot}] = l{local};");
                    cb.AppendLine($"l{local} = vs[{slot}];");
                    bind.StartInterval(slot, local, depth);
                }
            }

            // Emit body of command (reads/writes via helper lambdas)
            string R(int s) => _plan.SlotToLocal.TryGetValue(s, out int l) ? $"l{l}" : $"vs[{s}]";
            string W(int s) => R(s);

            void MarkWrite(int s)
            {
                if (_plan.SlotToLocal.TryGetValue(s, out int l))
                    bind.MarkWritten(l);
            }

            switch (cmd.CommandType)
            {
                case ArrayCommandType.Zero:
                    cb.AppendLine($"{W(cmd.Index)} = 0;");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.CopyTo:
                    cb.AppendLine($"{W(cmd.Index)} = {R(cmd.SourceIndex)};");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.IncrementBy:
                    cb.AppendLine($"{W(cmd.Index)} += {R(cmd.SourceIndex)};");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.DecrementBy:
                    cb.AppendLine($"{W(cmd.Index)} -= {R(cmd.SourceIndex)};");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.MultiplyBy:
                    cb.AppendLine($"{W(cmd.Index)} *= {R(cmd.SourceIndex)};");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.NextSource:
                    cb.AppendLine($"{W(cmd.Index)} = os[cosi++];");
                    MarkWrite(cmd.Index);
                    break;
                case ArrayCommandType.NextDestination:
                    cb.AppendLine($"od[codi++] = {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.ReusedDestination:
                    cb.AppendLine($"od[{cmd.Index}] += {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.EqualsOtherArrayIndex:
                    cb.AppendLine($"condition = {R(cmd.Index)} == {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.NotEqualsOtherArrayIndex:
                    cb.AppendLine($"condition = {R(cmd.Index)} != {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.GreaterThanOtherArrayIndex:
                    cb.AppendLine($"condition = {R(cmd.Index)} > {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.LessThanOtherArrayIndex:
                    cb.AppendLine($"condition = {R(cmd.Index)} < {R(cmd.SourceIndex)};");
                    break;
                case ArrayCommandType.EqualsValue:
                    cb.AppendLine($"condition = {R(cmd.Index)} == (double){cmd.SourceIndex};");
                    break;
                case ArrayCommandType.NotEqualsValue:
                    cb.AppendLine($"condition = {R(cmd.Index)} != (double){cmd.SourceIndex};");
                    break;
                case ArrayCommandType.If:
                    cb.AppendLine("if (condition) {"); cb.Indent();
                    break;
                case ArrayCommandType.EndIf:
                    // Before closing brace, flush dirty locals bound at this depth
                    foreach (int s in bind.FlushDirtyForDepth(depth))
                    {
                        int l = _plan.SlotToLocal[s];
                        cb.AppendLine($"vs[{s}] = l{l};");
                    }
                    cb.Unindent(); cb.AppendLine("}");
                    break;
                case ArrayCommandType.Comment:
                case ArrayCommandType.Blank:
                    break;
            }

            // Intervals ending at this cmd
            if (intervals.TryEnd(i, out int endSlot))
            {
                int local = _plan.SlotToLocal[endSlot];
                bind.Release(local);
            }
        }

        // ── epilogue: flush all locals once
        if (_plan != null)
            foreach (var iv in _plan.Intervals)
            {
                int loc = _plan.SlotToLocal[iv.Slot];
                cb.AppendLine($"vs[{iv.Slot}] = l{loc};");
            }

        cb.Unindent(); cb.AppendLine("}");  // close method

        _codeGen.AppendLine(cb.ToString());
    }
}
