// File: ChunkExecutors/RoslynChunkExecutor.cs

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using ACESimBase.Util.Debugging;         // for TabbedText
using ACESimBase.Util.ArrayProcessing;   // for ArrayCommandChunk, ArrayCommandChunkDelegate
using ACESimBase.Util.NWayTreeStorage;
using static ACESimBase.Util.ArrayProcessing.ArrayCommandList; // for Commands, CheckpointTrigger
using ACESimBase.Util.CodeGen;           // for StringToCode
using ACESimBase.Util.ArrayProcessing.ChunkExecutors;
using System.Linq; // for LocalAllocationPlan

namespace ACESimBase.Util.ArrayProcessing.ChunkExecutors
{
    public class RoslynChunkExecutor : ChunkExecutorBase
    {
        private readonly bool _useCheckpoints;
        private readonly LocalsAllocationPlan _localPlan;
        private readonly StringBuilder _codeGen = new StringBuilder();
        private readonly List<ArrayCommandChunk> _scheduled = new List<ArrayCommandChunk>();
        private readonly Dictionary<ArrayCommandChunk, ArrayCommandChunkDelegate> _compiledDelegates
            = new Dictionary<ArrayCommandChunk, ArrayCommandChunkDelegate>();
        private Type _autogenType;

        // old constructor: no locals
        public RoslynChunkExecutor(
            ArrayCommand[] underlyingCommands,
            int startIndex,
            int endIndexExclusive,
            bool useCheckpoints
        ) : this(underlyingCommands, startIndex, endIndexExclusive, useCheckpoints, null)
        { }

        // new constructor: optional LocalAllocationPlan
        public RoslynChunkExecutor(
            ArrayCommand[] underlyingCommands,
            int startIndex,
            int endIndexExclusive,
            bool useCheckpoints,
            LocalsAllocationPlan localPlan
        ) : base(underlyingCommands, startIndex, endIndexExclusive)
        {
            _useCheckpoints = useCheckpoints;
            _localPlan = localPlan;
        }

        public override void AddToGeneration(ArrayCommandChunk chunk)
        {
            if (!_compiledDelegates.ContainsKey(chunk) && !_scheduled.Contains(chunk))
                _scheduled.Add(chunk);
        }

        public override void PerformGeneration()
        {
            if (_scheduled.Count == 0)
                return;

            var sw = Stopwatch.StartNew();
            TabbedText.WriteLine("Autogenerating and compiling code...");

            // 1) Header + optional checkpoints
            string checkpoints = "";
            if (_useCheckpoints)
                checkpoints = @"
        public static List<double> Checkpoints = new List<double>();
        public static void ResetCheckpoints()
        {
            Checkpoints = new List<double>();
        }";

            _codeGen.AppendLine("using System;");
            _codeGen.AppendLine("using System.Collections.Generic;");
            _codeGen.AppendLine();
            _codeGen.AppendLine("namespace CommandTreeCodegen");
            _codeGen.AppendLine("{");
            _codeGen.AppendLine("  public static class AutogeneratedCode");
            _codeGen.AppendLine("  {");
            _codeGen.AppendLine(checkpoints);
            _codeGen.AppendLine();

            // 2) One method per scheduled chunk
            foreach (var chunk in _scheduled)
                GenerateSourceTextForChunk(chunk);

            // 3) Close class & namespace
            _codeGen.AppendLine("  }");
            _codeGen.AppendLine("}");

            // 4) Compile via StringToCode
            string code = _codeGen.ToString();
            _codeGen.Clear();
            _autogenType = StringToCode.LoadCode(code, "CommandTreeCodegen.AutogeneratedCode");

            // 5) Create and cache delegates
            foreach (var chunk in _scheduled)
            {
                int start = chunk.StartCommandRange;
                int end = chunk.EndCommandRangeExclusive - 1;
                string fn = $"Execute{start}to{end}";

                var mi = _autogenType.GetMethod(fn, BindingFlags.Public | BindingFlags.Static)
                         ?? throw new MissingMethodException($"Method {fn} not found in generated code.");

                var del = (ArrayCommandChunkDelegate)Delegate.CreateDelegate(
                    typeof(ArrayCommandChunkDelegate), mi);

                _compiledDelegates[chunk] = del;
            }

            int count = _scheduled.Count;
            _scheduled.Clear();

            sw.Stop();
            TabbedText.WriteLine($"[ROS‑COMPILE] methods={count}  UseCheckpoints={_useCheckpoints}");
            TabbedText.WriteLine($"...Code autogeneration complete after {sw.ElapsedMilliseconds} ms");
        }

        public override void Execute(
            ArrayCommandChunk chunk,
            double[] vs,
            double[] os,
            double[] od,
            ref int cosi,
            ref int codi,
            ref bool condition)
        {
            if (!_compiledDelegates.TryGetValue(chunk, out var del))
                throw new MissingMethodException($"No compiled delegate for chunk {chunk.ID}");

            del(vs, os, od, ref cosi, ref codi, ref condition);

            // Sync pointers back into the chunk
            chunk.StartSourceIndices = cosi;
            chunk.StartDestinationIndices = codi;
        }

        /// <summary>
        /// Fully‑rewritten GenerateSourceTextForChunk that produces a single
        ///   if (condition) { … } else { cosi += n; codi += m; }
        /// block for every outer‑level If/EndIf pair and makes pointer bumps
        /// unconditional.  Drop‑in replacement for RoslynChunkExecutor.
        /// </summary>
        private void GenerateSourceTextForChunk(ArrayCommandChunk c)
        {
            /* ------------------------------------------------------------------
             * basic info + helpers
             * ----------------------------------------------------------------*/
            int start = c.StartCommandRange;
            int end = c.EndCommandRangeExclusive - 1;       // inclusive
            string fn = $"Execute{start}to{end}";

            // Emit with two‑space indent inside method body
            void Emit(string line) => _codeGen.AppendLine("      " + line);

            string Read(int slot) => _localPlan != null && _localPlan.SlotToLocal.TryGetValue(slot, out var l)
                                        ? $"l{l}" : $"vs[{slot}]";
            string Write(int slot) => _localPlan != null && _localPlan.SlotToLocal.TryGetValue(slot, out var l)
                                        ? $"l{l}" : $"vs[{slot}]";

            _codeGen.AppendLine($"    public static void {fn}(");
            _codeGen.AppendLine("      double[] vs, double[] os, double[] od,");
            _codeGen.AppendLine("      ref int cosi, ref int codi, ref bool condition)");
            _codeGen.AppendLine("    {");

            /* ---------- locals prologue (optional) ------------------------- */
            if (_localPlan != null && _localPlan.LocalCount > 0)
            {
                string localsDecl = string.Join(", ", Enumerable.Range(0, _localPlan.LocalCount).Select(i => $"l{i}"));
                Emit($"double {localsDecl};");

                foreach (var kv in _localPlan.SlotToLocal)
                    Emit($"l{kv.Value} = vs[{kv.Key}];");

                _codeGen.AppendLine();
            }

            /* ---------- state for If/EndIf handling ------------------------ */
            var srcIncr = new Stack<int>();   // per‑depth NextSource count
            var dstIncr = new Stack<int>();   // per‑depth NextDestination count

            int tmpId = 0;                   // unique temp names

            foreach (var cmd in Commands)
            {
                switch (cmd.CommandType)
                {
                    /* ------------------------------------------------------ */
                    case ArrayCommandType.If:
                        Emit("if (condition)");
                        Emit("{");
                        srcIncr.Push(0);
                        dstIncr.Push(0);
                        break;

                    case ArrayCommandType.EndIf:
                        {
                            int s = srcIncr.Pop();
                            int d = dstIncr.Pop();
                            Emit("}");
                            if (s != 0 || d != 0)
                            {
                                string elseLine = "else { ";
                                if (s != 0) elseLine += $"cosi += {s}; ";
                                if (d != 0) elseLine += $"codi += {d}; ";
                                elseLine += "}";
                                Emit(elseLine);
                            }
                            break;
                        }

                    /* ------------------------------------------------------ */
                    case ArrayCommandType.NextSource:
                        {
                            string tmp = $"__src{tmpId++}";
                            Emit($"var {tmp} = os[cosi++];");          // unconditional bump
                            Emit($"{Write(cmd.Index)} = {tmp};");
                            if (srcIncr.Count > 0)
                            {
                                int top = srcIncr.Pop();
                                srcIncr.Push(top + 1);
                            }
                            break;
                        }

                    case ArrayCommandType.NextDestination:
                        {
                            string val = $"__val{tmpId++}";
                            Emit($"var {val} = {Read(cmd.SourceIndex)};");
                            string dstVar = $"__dst{tmpId++}";
                            Emit($"var {dstVar} = codi++;");
                            Emit($"od[{dstVar}] = {val};");
                            if (dstIncr.Count > 0)
                            {
                                int top = dstIncr.Pop();
                                dstIncr.Push(top + 1);
                            }
                            break;
                        }

                    case ArrayCommandType.ReusedDestination:
                        Emit($"od[{cmd.Index}] += {Read(cmd.SourceIndex)};");
                        break;

                    /* -------- write commands (no additional branching) ---- */
                    case ArrayCommandType.Zero:
                        Emit($"{Write(cmd.Index)} = 0;");
                        break;

                    case ArrayCommandType.CopyTo:
                        if (_useCheckpoints && cmd.Index == CheckpointTrigger)
                            Emit($"Checkpoints.Add({Read(cmd.SourceIndex)});");
                        else
                            Emit($"{Write(cmd.Index)} = {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.MultiplyBy:
                        Emit($"{Write(cmd.Index)} *= {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.IncrementBy:
                        Emit($"{Write(cmd.Index)} += {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.DecrementBy:
                        Emit($"{Write(cmd.Index)} -= {Read(cmd.SourceIndex)};");
                        break;

                    /* -------- comparisons update the shared flag ---------- */
                    case ArrayCommandType.EqualsOtherArrayIndex:
                        Emit($"condition = {Read(cmd.Index)} == {Read(cmd.SourceIndex)};");
                        break;
                    case ArrayCommandType.NotEqualsOtherArrayIndex:
                        Emit($"condition = {Read(cmd.Index)} != {Read(cmd.SourceIndex)};");
                        break;
                    case ArrayCommandType.GreaterThanOtherArrayIndex:
                        Emit($"condition = {Read(cmd.Index)} >  {Read(cmd.SourceIndex)};");
                        break;
                    case ArrayCommandType.LessThanOtherArrayIndex:
                        Emit($"condition = {Read(cmd.Index)} <  {Read(cmd.SourceIndex)};");
                        break;
                    case ArrayCommandType.EqualsValue:
                        Emit($"condition = {Read(cmd.Index)} == (double){cmd.SourceIndex};");
                        break;
                    case ArrayCommandType.NotEqualsValue:
                        Emit($"condition = {Read(cmd.Index)} != (double){cmd.SourceIndex};");
                        break;

                    /* -------- no‑ops ------------------------------------- */
                    case ArrayCommandType.Comment:
                        Emit($"// Comment #{cmd.SourceIndex}");
                        break;
                    case ArrayCommandType.Blank:
                        /* nothing */
                        break;

                    default:
                        throw new NotImplementedException($"Unhandled command {cmd.CommandType}");
                }
            }

            /* -------- epilogue: write modified locals back to VS -------- */
            if (_localPlan != null && _localPlan.LocalCount > 0)
            {
                foreach (var kv in _localPlan.SlotToLocal)
                    Emit($"vs[{kv.Key}] = l{kv.Value};");
            }

            _codeGen.AppendLine("    }");  // end of method
        }







    }
}
