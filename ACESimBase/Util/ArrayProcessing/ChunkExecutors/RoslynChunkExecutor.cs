// File: ChunkExecutors/RoslynChunkExecutor.cs

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using ACESimBase.Util.Debugging;         // for TabbedText
using ACESimBase.Util.ArrayProcessing;   // for ArrayCommandChunk, ArrayCommandChunkDelegate
using ACESimBase.Util.NWayTreeStorage;
using static ACESimBase.Util.ArrayProcessing.ArrayCommandList; // for Commands, CheckpointTrigger
using ACESimBase.Util.CodeGen;           // for StringToCode
using ACESimBase.Util.ArrayProcessing.ChunkExecutors; // for LocalAllocationPlan

namespace ACESimBase.Util.ArrayProcessing.ChunkExecutors
{
    public class RoslynChunkExecutor : ChunkExecutorBase
    {
        private readonly bool _useCheckpoints;
        private readonly LocalAllocationPlan _localPlan;
        private readonly StringBuilder _codeGen = new StringBuilder();
        private readonly List<ArrayCommandChunk> _scheduled = new List<ArrayCommandChunk>();
        private readonly Dictionary<ArrayCommandChunk, ArrayCommandChunkDelegate> _compiledDelegates
            = new Dictionary<ArrayCommandChunk, ArrayCommandChunkDelegate>();
        private Type _autogenType;

        // old constructor: no locals
        public RoslynChunkExecutor(
            ArrayCommand[] underlyingCommands,
            int startIndex,
            int endIndexExclusive,
            bool useCheckpoints
        ) : this(underlyingCommands, startIndex, endIndexExclusive, useCheckpoints, null)
        { }

        // new constructor: optional LocalAllocationPlan
        public RoslynChunkExecutor(
            ArrayCommand[] underlyingCommands,
            int startIndex,
            int endIndexExclusive,
            bool useCheckpoints,
            LocalAllocationPlan localPlan
        ) : base(underlyingCommands, startIndex, endIndexExclusive)
        {
            _useCheckpoints = useCheckpoints;
            _localPlan = localPlan;
        }

        public override void AddToGeneration(ArrayCommandChunk chunk)
        {
            if (!_compiledDelegates.ContainsKey(chunk) && !_scheduled.Contains(chunk))
                _scheduled.Add(chunk);
        }

        public override void PerformGeneration()
        {
            if (_scheduled.Count == 0)
                return;

            var sw = Stopwatch.StartNew();
            TabbedText.WriteLine("Autogenerating and compiling code...");

            // 1) Header + optional checkpoints
            string checkpoints = "";
            if (_useCheckpoints)
                checkpoints = @"
        public static List<double> Checkpoints = new List<double>();
        public static void ResetCheckpoints()
        {
            Checkpoints = new List<double>();
        }";

            _codeGen.AppendLine("using System;");
            _codeGen.AppendLine("using System.Collections.Generic;");
            _codeGen.AppendLine();
            _codeGen.AppendLine("namespace CommandTreeCodegen");
            _codeGen.AppendLine("{");
            _codeGen.AppendLine("  public static class AutogeneratedCode");
            _codeGen.AppendLine("  {");
            _codeGen.AppendLine(checkpoints);
            _codeGen.AppendLine();

            // 2) One method per scheduled chunk
            foreach (var chunk in _scheduled)
                GenerateSourceTextForChunk(chunk);

            // 3) Close class & namespace
            _codeGen.AppendLine("  }");
            _codeGen.AppendLine("}");

            // 4) Compile via StringToCode
            string code = _codeGen.ToString();
            _codeGen.Clear();
            _autogenType = StringToCode.LoadCode(code, "CommandTreeCodegen.AutogeneratedCode");

            // 5) Create and cache delegates
            foreach (var chunk in _scheduled)
            {
                int start = chunk.StartCommandRange;
                int end = chunk.EndCommandRangeExclusive - 1;
                string fn = $"Execute{start}to{end}";

                var mi = _autogenType.GetMethod(fn, BindingFlags.Public | BindingFlags.Static)
                         ?? throw new MissingMethodException($"Method {fn} not found in generated code.");

                var del = (ArrayCommandChunkDelegate)Delegate.CreateDelegate(
                    typeof(ArrayCommandChunkDelegate), mi);

                _compiledDelegates[chunk] = del;
            }

            int count = _scheduled.Count;
            _scheduled.Clear();

            sw.Stop();
            TabbedText.WriteLine($"[ROS‑COMPILE] methods={count}  UseCheckpoints={_useCheckpoints}");
            TabbedText.WriteLine($"...Code autogeneration complete after {sw.ElapsedMilliseconds} ms");
        }

        public override void Execute(
            ArrayCommandChunk chunk,
            double[] vs,
            double[] os,
            double[] od,
            ref int cosi,
            ref int codi,
            ref bool condition)
        {
            if (!_compiledDelegates.TryGetValue(chunk, out var del))
                throw new MissingMethodException($"No compiled delegate for chunk {chunk.ID}");

            del(vs, os, od, ref cosi, ref codi, ref condition);

            // Sync pointers back into the chunk
            chunk.StartSourceIndices = cosi;
            chunk.StartDestinationIndices = codi;
        }

        /// <summary>
        /// Generates a single static method for the given chunk, emitting:
        ///  • optional local declarations + prologue
        ///  • per-command logic (using locals where mapped)
        ///  • epilogue writing locals back to vs[]
        /// </summary>
        private void GenerateSourceTextForChunk(ArrayCommandChunk c)
        {
            var plan = _localPlan;
            int start = c.StartCommandRange;
            int end = c.EndCommandRangeExclusive - 1;
            string fn = $"Execute{start}to{end}";

            // Method signature
            _codeGen.AppendLine($@"    public static void {fn}(
      double[] vs, double[] os, double[] od,
      ref int cosi, ref int codi, ref bool condition)
    {{");

            // 1) Declare and load locals from vs[]
            if (plan != null && plan.LocalCount > 0)
            {
                // declare locals
                _codeGen.Append("      ");
                for (int i = 0; i < plan.LocalCount; i++)
                {
                    _codeGen.Append($"double l{i}");
                    _codeGen.Append(i + 1 < plan.LocalCount ? ", " : ";");
                }
                _codeGen.AppendLine();

                // prologue: copy vs[] → locals
                foreach (var kv in plan.SlotToLocal)
                {
                    int slot = kv.Key, loc = kv.Value;
                    _codeGen.AppendLine($"      l{loc} = vs[{slot}];");
                }
                _codeGen.AppendLine();
            }

            // 2) Emit each command, replacing vs[...] with locals when appropriate
            foreach (var cmd in Commands)
            {
                // helpers to choose between local or direct vs access
                string Read(int slot) =>
                    (plan != null && plan.SlotToLocal.TryGetValue(slot, out var L))
                        ? $"l{L}"
                        : $"vs[{slot}]";
                string Write(int slot) =>
                    (plan != null && plan.SlotToLocal.TryGetValue(slot, out var L2))
                        ? $"l{L2}"
                        : $"vs[{slot}]";

                switch (cmd.CommandType)
                {
                    case ArrayCommandType.Zero:
                        _codeGen.AppendLine($"      {Write(cmd.Index)} = 0;");
                        break;

                    case ArrayCommandType.CopyTo:
                        if (_useCheckpoints && cmd.Index == CheckpointTrigger)
                            _codeGen.AppendLine($"      Checkpoints.Add({Read(cmd.SourceIndex)});");
                        else
                            _codeGen.AppendLine($"      {Write(cmd.Index)} = {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.NextSource:
                        _codeGen.AppendLine($"      {Write(cmd.Index)} = os[cosi++];");
                        break;

                    case ArrayCommandType.NextDestination:
                        _codeGen.AppendLine($"      od[codi++] = {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.ReusedDestination:
                        _codeGen.AppendLine($"      od[{cmd.Index}] += {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.MultiplyBy:
                        _codeGen.AppendLine($"      {Write(cmd.Index)} *= {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.IncrementBy:
                        _codeGen.AppendLine($"      {Write(cmd.Index)} += {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.DecrementBy:
                        _codeGen.AppendLine($"      {Write(cmd.Index)} -= {Read(cmd.SourceIndex)};");
                        break;

                    // ── Comparisons ─────────────────────────────────────────────────
                    case ArrayCommandType.EqualsOtherArrayIndex:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} == {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.NotEqualsOtherArrayIndex:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} != {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.GreaterThanOtherArrayIndex:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} >  {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.LessThanOtherArrayIndex:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} <  {Read(cmd.SourceIndex)};");
                        break;

                    case ArrayCommandType.EqualsValue:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} == {cmd.SourceIndex};");
                        break;

                    case ArrayCommandType.NotEqualsValue:
                        _codeGen.AppendLine($"      condition = {Read(cmd.Index)} != {cmd.SourceIndex};");
                        break;

                    // ── Flow control ────────────────────────────────────────────────
                    case ArrayCommandType.If:
                        _codeGen.AppendLine("      if (condition)");
                        _codeGen.AppendLine("      {");
                        break;

                    case ArrayCommandType.EndIf:
                        _codeGen.AppendLine("      }");
                        break;

                    // ── No‑ops ───────────────────────────────────────────────────────
                    case ArrayCommandType.Comment:
                        _codeGen.AppendLine("      // Comment");
                        break;

                    case ArrayCommandType.Blank:
                        _codeGen.AppendLine("      // Blank");
                        break;

                    default:
                        throw new NotImplementedException(
                            $"RoslynChunkExecutor: unimplemented command {cmd.CommandType}");
                }
            }

            // 3) Epilogue: write locals back to vs[]
            if (plan != null && plan.LocalCount > 0)
            {
                _codeGen.AppendLine();
                foreach (var kv in plan.SlotToLocal)
                {
                    int slot = kv.Key, loc = kv.Value;
                    _codeGen.AppendLine($"      vs[{slot}] = l{loc};");
                }
            }

            // 4) Close method
            _codeGen.AppendLine("    }");
            _codeGen.AppendLine();
        }
    }
}
