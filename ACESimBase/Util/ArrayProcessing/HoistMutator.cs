using ACESimBase.Util.Debugging;
using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;
using System.Linq;
using Tensorflow;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilAsBalancedAsPossible(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerSplittableChunk == int.MaxValue)
                return;           // hoisting disabled


#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"── before mutation ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("───────────────");
#endif

            int round = 0;
            while (true)
            {
                round++;
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerSplittableChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

#if OUTPUT_HOISTING_INFO
                    TabbedText.WriteLine($"── after round {round} ──");
                    TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
                    TabbedText.WriteLine("───────────────");
#endif

                if (plan.Count == 0)
                {
                    break;        // tree already balanced
                }

                ApplyPlan(acl, plan);
            }
        }


        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine(
                    $"[APPLY] leafId={entry.LeafId} kind={entry.Kind} span=[{entry.StartIdx},{entry.EndIdxExclusive})");
#endif
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // node is no longer a leaf


                Split(acl, leaf, entry.StartIdx, entry.EndIdxExclusive, entry.Kind == HoistPlanner.SplitKind.Conditional);
            }

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine("── tree after ApplyPlan ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("─────────────────────────");
#endif
        }

        private static void Split(ArrayCommandList acl,
                                       NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                       int spanStart,
                                       int spanEndEx,
                                       bool isConditionalSplit)
        {
            var info = leaf.StoredValue;
            int originalStart = info.StartCommandRange;
            int originalEnd = info.EndCommandRangeExclusive;
            int prefixEnd = spanStart;
            int bodyStart = spanStart + 1;
            int bodyEnd = spanEndEx - 1;
            int suffixStart = spanEndEx;

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"[SPLIT] leaf ID{info.ID} body=[{bodyStart},{bodyEnd})");
#endif
            List<(int start, int endEx, bool isConditional)> branches = new();
            if (originalStart <= prefixEnd)
                branches.Add((originalStart, prefixEnd, false));
            branches.Add((bodyStart, bodyEnd, isConditionalSplit)); // the body is the only part that runs conditionally (along with its children)
            if (suffixStart <= originalEnd)
                branches.Add((suffixStart, originalEnd, false));
            var branchesNodes = branches.Select(x => new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, x.start, x.endEx, x.isConditional)
            }).ToArray();
            for (byte b = 1; b <= branches.Count; b++)
            {
                NWayTreeStorageInternal<ArrayCommandChunk> branchNode = branchesNodes[b - 1];
                leaf.SetBranch(b, branchNode);
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"       ↳ [SLICE] ID{branchNode.StoredValue.ID} cmds=[{branches[b - 1].start},{branches[b - 1].endEx})");
#endif
            }

            info.LastChild = (byte) branches.Count;
        }

        /* Helpers */

        private static NWayTreeStorageInternal<ArrayCommandChunk> FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk> target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"[FIND] visit ID{n.StoredValue.ID} children={(n.Branches?.Length ?? 0)}");
#endif
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx, bool isConditional)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
                IsConditional = isConditional,
            };
        }

    }
}
