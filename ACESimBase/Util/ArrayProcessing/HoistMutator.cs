using ACESimBase.Util.Debugging;
using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilAsBalancedAsPossible(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerSplittableChunk == int.MaxValue)
                return;           // hoisting disabled

            int round = 0;
            while (true)
            {
                round++;
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerSplittableChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

#if DEBUG
                if (round == 1)
                {
                    TabbedText.WriteLine($"[MUTATE] max={acl.MaxCommandsPerSplittableChunk} round={round}  planCount={plan.Count}");
                    TabbedText.WriteLine("Commands:");
                    TabbedText.WriteLine(acl.CommandListString());
                    TabbedText.WriteLine($"Before mutation");
                    TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
                }
#endif

                ApplyPlan(acl, plan);

#if DEBUG
                TabbedText.WriteLine($"After round {round}");
                TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
#endif

                if (plan.Count == 0)
                    break;        // tree already balanced
            }
        }


        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
#if DEBUG
                TabbedText.WriteLine(
                    $"[APPLY] leafId={entry.LeafId} kind={entry.Kind} span=[{entry.StartIdx},{entry.EndIdxExclusive})");
#endif
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // node is no longer a leaf

                switch (entry.Kind)
                {
                    case HoistPlanner.SplitKind.Conditional:
                        SplitAtConditional(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    case HoistPlanner.SplitKind.Depth:
                        SplitAtDepthRegion(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            acl.CommandTree.WalkTree(
                n => acl.SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)n),
                n => acl.SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)n));

#if DEBUG
            TabbedText.WriteLine("── tree after ApplyPlan ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("─────────────────────────");
#endif
        }


        // ───────────────────────────────────────────── helpers ──
        private static NWayTreeStorageInternal<ArrayCommandChunk> FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk> target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
#if DEBUG
                TabbedText.WriteLine($"[FIND] visit ID{n.StoredValue.ID} children={(n.Branches?.Length ?? 0)}");
#endif
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static void SplitAtConditional(
    ArrayCommandList acl,
    NWayTreeStorageInternal<ArrayCommandChunk> leaf,
    int spanStart,
    int spanEndEx)
        {
            var info = leaf.StoredValue;

#if DEBUG
            TabbedText.WriteLine($"[COND-SPLIT] leaf ID{info.ID} span=[{spanStart},{spanEndEx})");
#endif

            int prefixEnd = spanStart;
            int postfixStart = spanEndEx;
            int postfixEnd = info.EndCommandRangeExclusive;

            // Prefix becomes the truncated range of the original leaf.
            info.EndCommandRangeExclusive = prefixEnd;

            // Gate node holds the entire [If … EndIf] pair.
            var gateNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };

            // Optional suffix node for commands after the EndIf.
            NWayTreeStorageInternal<ArrayCommandChunk>? postNode = null;
            if (postfixStart < postfixEnd)
            {
                postNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = CloneMeta(info, postfixStart, postfixEnd)
                };
            }

            // Attach children: branch-0 is the (wrapped) prefix leaf that will be added
            // later by WrapCommandsIntoLeaf; branch-1 is the gate; branch-2 is the suffix.
            leaf.SetBranch(1, gateNode);
            if (postNode != null)
                leaf.SetBranch(2, postNode);

            leaf.StoredValue.LastChild = (byte)(postNode == null ? 1 : 2);

            // Ensure any remaining prefix commands are wrapped into a dedicated leaf.
            WrapCommandsIntoLeaf(acl, leaf);

            // Deliberately DO NOT slice the gate body here. The gate remains a leaf,
            // so the planner will revisit it on the next pass and apply the usual
            // Conditional/Depth logic, preserving balanced If/EndIf pairs.
        }

        private static void SplitAtDepthRegion(
    ArrayCommandList acl,
    NWayTreeStorageInternal<ArrayCommandChunk> leaf,
    int spanStart,
    int spanEndEx)
        {
            var info = leaf.StoredValue;
            int prefixEnd = spanStart;
            int bodyStart = spanStart + 1;
            int bodyEnd = spanEndEx - 1;
            int max = acl.MaxCommandsPerSplittableChunk;

#if DEBUG
            TabbedText.WriteLine($"[DEPTH-SPLIT] leaf ID{info.ID} body=[{bodyStart},{bodyEnd}) max={max}");
#endif

            // Do NOT change parent's StartCommandRange or EndCommandRangeExclusive!

            var region = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };
            leaf.SetBranch(1, region);
            leaf.StoredValue.LastChild = 1;

            byte branch = 1;
            for (int pos = bodyStart; pos < bodyEnd;)
            {
                int sliceEnd = Math.Min(pos + max, bodyEnd);
                var slice = new NWayTreeStorageInternal<ArrayCommandChunk>(region)
                {
                    StoredValue = CloneMeta(info, pos, sliceEnd)
                };
                region.SetBranch(branch++, slice);
#if DEBUG
                TabbedText.WriteLine($"       ↳ [SLICE] ID{slice.StoredValue.ID} cmds=[{pos},{sliceEnd})");
#endif
                pos = sliceEnd;
            }

            region.StoredValue.LastChild = (byte)(branch - 1);

#if DEBUG
            TabbedText.WriteLine($"[DEPTH-SPLIT-END] region ID{region.StoredValue.ID} children={branch - 1} branchesArray={(region.Branches?.Length ?? 0)}");
#endif

            WrapCommandsIntoLeaf(acl, leaf);
#if DEBUG
            TabbedText.WriteLine($"[DBG-DEPTH] container ID{leaf.StoredValue.ID} range=[{leaf.StoredValue.StartCommandRange},{leaf.StoredValue.EndCommandRangeExclusive})");
#endif
        }


        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
                StartDestinationIndices = src.StartDestinationIndices,
                EndDestinationIndicesExclusive = src.EndDestinationIndicesExclusive,
                ChildrenParallelizable = false
            };
        }

        private static void WrapCommandsIntoLeaf(ArrayCommandList acl,
                                             NWayTreeStorageInternal<ArrayCommandChunk> container)
        {
            var meta = container.StoredValue;
#if DEBUG
            TabbedText.WriteLine($"[WRAP-CHECK] ID{meta.ID} start={meta.StartCommandRange} end={meta.EndCommandRangeExclusive}");
#endif
            if (meta.StartCommandRange >= meta.EndCommandRangeExclusive)
                return;

            var leaf = new NWayTreeStorageInternal<ArrayCommandChunk>(container)
            {
                StoredValue = CloneMeta(meta, meta.StartCommandRange, meta.EndCommandRangeExclusive)
            };

            for (int b = meta.LastChild; b >= 1; b--)
                container.SetBranch((byte)(b + 1), container.GetBranch((byte)b));

            container.SetBranch(1, leaf);
            meta.LastChild += 1;
            meta.StartCommandRange = meta.EndCommandRangeExclusive;

#if DEBUG
            TabbedText.WriteLine($"[WRAP] container ID{meta.ID} → leaf ID{leaf.StoredValue.ID}");
#endif
        }

        // DEBUG -- not used now
        private static void SliceConditionalBody(ArrayCommandList acl,
                                                 NWayTreeStorageInternal<ArrayCommandChunk> gate)
        {
            var gInfo = gate.StoredValue;
            int depth = 0;
            int ifIdx = -1;
            for (int i = gInfo.StartCommandRange; i < gInfo.EndCommandRangeExclusive; i++)
            {
                var ct = acl.UnderlyingCommands[i].CommandType;
                if (ct == ArrayCommandType.If)
                {
                    if (depth == 0) ifIdx = i;
                    depth++;
                }
                else if (ct == ArrayCommandType.EndIf)
                {
                    depth--;
                    if (depth == 0)
                    {
#if DEBUG
                        TabbedText.WriteLine($"[CONDBODY] gate ID{gInfo.ID} body=[{ifIdx + 1},{i})");
#endif
                        CreateSlices(acl, gate, ifIdx + 1, i);
                        break;
                    }
                }
            }
        }

        private static void CreateSlices(ArrayCommandList acl,
                                         NWayTreeStorageInternal<ArrayCommandChunk> gate,
                                         int bodyStart,
                                         int bodyEnd)
        {
            var gInfo = gate.StoredValue;
            int max = acl.MaxCommandsPerSplittableChunk;
            int sliceStart = bodyStart;
            byte branch = 1;
            while (sliceStart < bodyEnd)
            {
                int sliceEnd = Math.Min(sliceStart + max, bodyEnd);
                var slice = new NWayTreeStorageInternal<ArrayCommandChunk>(gate)
                {
                    StoredValue = CloneMeta(gInfo, sliceStart, sliceEnd)
                };
                gate.SetBranch(branch++, slice);
#if DEBUG
                TabbedText.WriteLine($"       ↳ [GATE-SLICE] ID{slice.StoredValue.ID} cmds=[{sliceStart},{sliceEnd})");
#endif
                sliceStart = sliceEnd;
            }
            gInfo.LastChild = (byte)(branch - 1);
        }
    }
}
