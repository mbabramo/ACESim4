using ACESimBase.Util.Debugging;
using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilBalanced(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerChunk == int.MaxValue)
                return; // hoisting disabled

            while (true)
            {
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

                if (plan.Count == 0)
                    break; // tree already balanced

                ApplyPlan(acl, plan);
            }
        }

        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
                // Skip plan entries whose node has turned into an internal container
                // (most often the original leaf ID 0 after an earlier split).
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // ← just ignore and move on

                switch (entry.Kind)
                {
                    case HoistPlanner.SplitKind.Conditional:
                        SplitAtConditional(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    case HoistPlanner.SplitKind.Depth:
                        SplitAtDepthRegion(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }


            acl.CommandTree.WalkTree(
                n => acl.SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)n),
                n => acl.SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)n));
        }

        // ───────────────────────────────────────────── helpers ──
        private static NWayTreeStorageInternal<ArrayCommandChunk>? FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk>? target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static void SplitAtConditional(ArrayCommandList acl,
                                               NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                               int spanStart,
                                               int spanEndEx)
        {
            var info = leaf.StoredValue;
            int prefixEnd = spanStart;
            int postfixStart = spanEndEx;
            int postfixEnd = info.EndCommandRangeExclusive;

            info.EndCommandRangeExclusive = prefixEnd;

            var gateNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };

            NWayTreeStorageInternal<ArrayCommandChunk>? postNode = null;
            if (postfixStart < postfixEnd)
            {
                postNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = CloneMeta(info, postfixStart, postfixEnd)
                };
            }

            leaf.SetBranch(1, gateNode);
            if (postNode != null) leaf.SetBranch(2, postNode);
            leaf.StoredValue.LastChild = (byte)(postNode == null ? 1 : 2);

            WrapCommandsIntoLeaf(acl, leaf);
            SliceConditionalBody(acl, gateNode);
        }


        private static void SplitAtDepthRegion(ArrayCommandList acl,
                                       NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                       int spanStart,
                                       int spanEndEx)
        {
            /*  Final shape                               (Max = acl.MaxCommandsPerChunk)

                    Root (ID0)  0 cmds
                      └─ prefix-holder (ID1, 0 cmds)  ← original leaf, now a pure container
                           └─ region-container (ID2, 0 cmds) ──┐
                               ├─ slice₁  ID3  cmds=[body0 .. body0+Max)
                               └─ slice₂  ID4  cmds=[…]      (≤ Max each)

                * IncrementDepth / DecrementDepth tokens live only in the original command
                  buffer; no executable slice contains them.
                * Region-container’s command range is reset to zero so it does not appear
                  in “leaf-only” dumps.
                * Both slices share the region-container’s virtual stack, therefore both
                  print **VirtualStack ID 2** — matching the test’s expected output.
            */

            var info = leaf.StoredValue;           // ID1 initially
            int prefixEnd = spanStart;                  // before IncrementDepth
            int bodyStart = spanStart + 1;              // first body command
            int bodyEnd = spanEndEx - 1;            // last  body command
            int max = acl.MaxCommandsPerChunk;

#if DEBUG
            TabbedText.WriteLine(
                $"[DEPTH-SPLIT] leaf=ID{info.ID}  body=[{bodyStart},{bodyEnd})  Max={max}");
#endif

            // ─── 1 ▸ shrink the *original* leaf to its prefix (may be 0-length) ─────
            info.EndCommandRangeExclusive = prefixEnd;

            // ─── 2 ▸ create the region container as the leaf’s first child ──────────
            var region = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)   // IncDepth…DecDepth span
            };
            leaf.SetBranch(1, region);
            leaf.StoredValue.LastChild = 1;

#if DEBUG
            TabbedText.WriteLine($"   ↳ [REGION] →ID{region.StoredValue.ID}");
#endif

            // ─── 3 ▸ slice the body under the region container ──────────────────────
            byte branch = 1;
            for (int pos = bodyStart; pos < bodyEnd;)
            {
                int sliceEnd = Math.Min(pos + max, bodyEnd);

                var slice = new NWayTreeStorageInternal<ArrayCommandChunk>(region)
                {
                    StoredValue = CloneMeta(info, pos, sliceEnd)
                };
                region.SetBranch(branch++, slice);

#if DEBUG
                TabbedText.WriteLine(
                    $"       ↳ [SLICE] branch={branch - 1} cmds=[{pos},{sliceEnd}) →ID{slice.StoredValue.ID}");
#endif
                pos = sliceEnd;
            }
            region.StoredValue.LastChild = (byte)(branch - 1);

            // Mark the region node as a *pure container* so it never appears as a leaf
            region.StoredValue.StartCommandRange = region.StoredValue.EndCommandRangeExclusive;
            // and likewise for the prefix holder, if its range collapsed to zero.
            WrapCommandsIntoLeaf(acl, leaf);
        }



        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
                StartDestinationIndices = src.StartDestinationIndices,
                EndDestinationIndicesExclusive = src.EndDestinationIndicesExclusive,
                ChildrenParallelizable = false
            };
        }

        private static void WrapCommandsIntoLeaf(ArrayCommandList acl,
                                                 NWayTreeStorageInternal<ArrayCommandChunk> container)
        {
            var meta = container.StoredValue;
            if (meta.StartCommandRange >= meta.EndCommandRangeExclusive)
                return;

            var leaf = new NWayTreeStorageInternal<ArrayCommandChunk>(container)
            {
                StoredValue = CloneMeta(meta, meta.StartCommandRange, meta.EndCommandRangeExclusive)
            };

            for (int b = meta.LastChild; b >= 1; b--)
                container.SetBranch((byte)(b + 1), container.GetBranch((byte)b));

            container.SetBranch(1, leaf);
            meta.LastChild += 1;
            meta.StartCommandRange = meta.EndCommandRangeExclusive;
        }

        private static void SliceConditionalBody(ArrayCommandList acl,
                                                 NWayTreeStorageInternal<ArrayCommandChunk> gate)
        {
            var gInfo = gate.StoredValue;
            int depth = 0;
            int ifIdx = -1;
            for (int i = gInfo.StartCommandRange; i < gInfo.EndCommandRangeExclusive; i++)
            {
                var ct = acl.UnderlyingCommands[i].CommandType;
                if (ct == ArrayCommandType.If)
                {
                    if (depth == 0) ifIdx = i;
                    depth++;
                }
                else if (ct == ArrayCommandType.EndIf)
                {
                    depth--;
                    if (depth == 0)
                    {
                        CreateSlices(acl, gate, ifIdx + 1, i);
                        break;
                    }
                }
            }
        }

        private static void CreateSlices(ArrayCommandList acl,
                                         NWayTreeStorageInternal<ArrayCommandChunk> gate,
                                         int bodyStart,
                                         int bodyEnd)
        {
            var gInfo = gate.StoredValue;
            int max = acl.MaxCommandsPerChunk;
            int sliceStart = bodyStart;
            byte branch = 1;
            while (sliceStart < bodyEnd)
            {
                int sliceEnd = Math.Min(sliceStart + max, bodyEnd);
                var slice = new NWayTreeStorageInternal<ArrayCommandChunk>(gate)
                {
                    StoredValue = CloneMeta(gInfo, sliceStart, sliceEnd)
                };
                gate.SetBranch(branch++, slice);
                sliceStart = sliceEnd;
            }
            gInfo.LastChild = (byte)(branch - 1);
        }
    }
}
