using ACESimBase.Util.Debugging;
using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;
using System.Linq;
using Tensorflow;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilAsBalancedAsPossible(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerSplittableChunk == int.MaxValue)
                return;           // hoisting disabled


#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"── before mutation ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("───────────────");
#endif

            int round = 0;
            while (true)
            {
                round++;
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerSplittableChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

#if OUTPUT_HOISTING_INFO
                    TabbedText.WriteLine($"── after round {round} ──");
                    TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
                    TabbedText.WriteLine("───────────────");
#endif

                if (plan.Count == 0)
                {
                    break;        // tree already balanced
                }

                ApplyPlan(acl, plan);
            }
        }


        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine(
                    $"[APPLY] leafId={entry.LeafId} kind={entry.Kind} span=[{entry.StartIdx},{entry.EndIdxExclusive})");
#endif
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // node is no longer a leaf

                switch (entry.Kind)
                {
                    case HoistPlanner.SplitKind.Conditional:
                        SplitAtConditional(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    case HoistPlanner.SplitKind.Depth:
                        SplitAtIncrementDepth(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine("── tree after ApplyPlan ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("─────────────────────────");
#endif
        }

        private static void SplitAtConditional(
            ArrayCommandList acl,
            NWayTreeStorageInternal<ArrayCommandChunk> leaf,
            int spanStart,
            int spanEndEx)
        {
            var info = leaf.StoredValue;

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"[COND-SPLIT] leaf ID{info.ID} span=[{spanStart},{spanEndEx})");
#endif

            int prefixEnd = spanStart;
            int postfixStart = spanEndEx;
            int postfixEnd = info.EndCommandRangeExclusive;

            // Prefix becomes the truncated range of the original leaf.
            info.EndCommandRangeExclusive = prefixEnd;

            // Gate node holds the entire [If … EndIf] pair.
            var gateNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };

            // Optional suffix node for commands after the EndIf.
            NWayTreeStorageInternal<ArrayCommandChunk> postNode = null;
            if (postfixStart < postfixEnd)
            {
                postNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = CloneMeta(info, postfixStart, postfixEnd)
                };
            }

            // Attach children: branch-0 is the (wrapped) prefix leaf that will be added
            // later by WrapCommandsIntoLeaf; branch-1 is the gate; branch-2 is the suffix.
            leaf.SetBranch(1, gateNode);
            if (postNode != null)
                leaf.SetBranch(2, postNode);

            leaf.StoredValue.LastChild = (byte)(postNode == null ? 1 : 2);

            // Ensure any remaining prefix commands are wrapped into a dedicated leaf.
            WrapCommandsIntoLeaf(acl, leaf);

            // Deliberately DO NOT slice the gate body here. The gate remains a leaf,
            // so the planner will revisit it on the next pass and apply the usual
            // Conditional/Depth logic, preserving balanced If/EndIf pairs.
        }

        private static void SplitAtIncrementDepth(ArrayCommandList acl,
                                       NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                       int spanStart,
                                       int spanEndEx)
        {
            var info = leaf.StoredValue;
            int originalStart = info.StartCommandRange;
            int originalEnd = info.EndCommandRangeExclusive;
            int prefixEnd = spanStart;
            int bodyStart = spanStart + 1;
            int bodyEnd = spanEndEx - 1;
            int suffixStart = spanEndEx;

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"[DEPTH-SPLIT] leaf ID{info.ID} body=[{bodyStart},{bodyEnd})");
#endif
            List<(int start, int endEx)> branches = new();
            if (originalStart <= prefixEnd)
                branches.Add((originalStart, prefixEnd));
            branches.Add((bodyStart, bodyEnd));
            if (suffixStart <= originalEnd)
                branches.Add((suffixStart, originalEnd));
            var branchesNodes = branches.Select(x => new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, x.start, x.endEx)
            }).ToArray();
            for (byte b = 1; b <= branches.Count; b++)
            {
                NWayTreeStorageInternal<ArrayCommandChunk> branchNode = branchesNodes[b - 1];
                leaf.SetBranch(b, branchNode);
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"       ↳ [SLICE] ID{branchNode.StoredValue.ID} cmds=[{branches[b - 1].start},{branches[b - 1].endEx})");
#endif
            }

            info.StartCommandRange = info.EndCommandRangeExclusive = originalEnd;
            info.LastChild = (byte) branches.Count;
        }

        /* Helpers */

        private static NWayTreeStorageInternal<ArrayCommandChunk> FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk> target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"[FIND] visit ID{n.StoredValue.ID} children={(n.Branches?.Length ?? 0)}");
#endif
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
            };
        }

        /// <summary>
        /// Creates a leaf that becomes the first branch of the container and contains the container's commands.
        /// Other children are moved to later branches.
        /// The container's commands then change to be an empty set.
        /// </summary>
        /// <param name="acl"></param>
        /// <param name="container"></param>
        private static void WrapCommandsIntoLeaf(ArrayCommandList acl,
                                             NWayTreeStorageInternal<ArrayCommandChunk> container)
        {
            var meta = container.StoredValue;
#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"[WRAP-CHECK] ID{meta.ID} start={meta.StartCommandRange} end={meta.EndCommandRangeExclusive}");
#endif
            if (meta.StartCommandRange >= meta.EndCommandRangeExclusive)
                return;

            var leaf = new NWayTreeStorageInternal<ArrayCommandChunk>(container)
            {
                StoredValue = CloneMeta(meta, meta.StartCommandRange, meta.EndCommandRangeExclusive)
            };

            for (int b = meta.LastChild; b >= 1; b--)
                container.SetBranch((byte)(b + 1), container.GetBranch((byte)b));

            container.SetBranch(1, leaf);
            meta.LastChild += 1;
            meta.StartCommandRange = meta.EndCommandRangeExclusive;

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"[WRAP] container ID{meta.ID} → leaf ID{leaf.StoredValue.ID}");
#endif
        }

    }
}
