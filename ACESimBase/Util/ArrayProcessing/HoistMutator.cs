using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilBalanced(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerChunk == int.MaxValue)
                return; // hoisting disabled

            while (true)
            {
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

                if (plan.Count == 0)
                    break; // tree already balanced

                ApplyPlan(acl, plan);
            }
        }

        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
                // Skip plan entries whose node has turned into an internal container
                // (most often the original leaf ID 0 after an earlier split).
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // ← just ignore and move on

                switch (entry.Kind)
                {
                    case HoistPlanner.SplitKind.Conditional:
                        SplitAtConditional(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    case HoistPlanner.SplitKind.Depth:
                        SplitAtDepthRegion(acl, leaf, entry.StartIdx, entry.EndIdxExclusive);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }


            acl.CommandTree.WalkTree(
                n => acl.SetupVirtualStack((NWayTreeStorageInternal<ArrayCommandChunk>)n),
                n => acl.SetupVirtualStackRelationships((NWayTreeStorageInternal<ArrayCommandChunk>)n));
        }

        // ───────────────────────────────────────────── helpers ──
        private static NWayTreeStorageInternal<ArrayCommandChunk>? FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk>? target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static void SplitAtConditional(ArrayCommandList acl,
                                               NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                               int spanStart,
                                               int spanEndEx)
        {
            var info = leaf.StoredValue;
            int prefixEnd = spanStart;
            int postfixStart = spanEndEx;
            int postfixEnd = info.EndCommandRangeExclusive;

            info.EndCommandRangeExclusive = prefixEnd;

            var gateNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };

            NWayTreeStorageInternal<ArrayCommandChunk>? postNode = null;
            if (postfixStart < postfixEnd)
            {
                postNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = CloneMeta(info, postfixStart, postfixEnd)
                };
            }

            leaf.SetBranch(1, gateNode);
            if (postNode != null) leaf.SetBranch(2, postNode);
            leaf.StoredValue.LastChild = (byte)(postNode == null ? 1 : 2);

            WrapCommandsIntoLeaf(acl, leaf);
            SliceConditionalBody(acl, gateNode);
        }

        private static void SplitAtDepthRegion(ArrayCommandList acl,
                                               NWayTreeStorageInternal<ArrayCommandChunk> leaf,
                                               int spanStart,
                                               int spanEndEx)
        {
            var info = leaf.StoredValue;
            int postfixEnd = info.EndCommandRangeExclusive;

            info.EndCommandRangeExclusive = spanStart;

            var regionNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
            {
                StoredValue = CloneMeta(info, spanStart, spanEndEx)
            };

            NWayTreeStorageInternal<ArrayCommandChunk>? postNode = null;
            if (spanEndEx < postfixEnd)
            {
                postNode = new NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = CloneMeta(info, spanEndEx, postfixEnd)
                };
            }

            leaf.SetBranch(1, regionNode);
            if (postNode != null) leaf.SetBranch(2, postNode);
            leaf.StoredValue.LastChild = (byte)(postNode == null ? 1 : 2);

            WrapCommandsIntoLeaf(acl, leaf);
        }

        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
                StartDestinationIndices = src.StartDestinationIndices,
                EndDestinationIndicesExclusive = src.EndDestinationIndicesExclusive,
                ChildrenParallelizable = false
            };
        }

        private static void WrapCommandsIntoLeaf(ArrayCommandList acl,
                                                 NWayTreeStorageInternal<ArrayCommandChunk> container)
        {
            var meta = container.StoredValue;
            if (meta.StartCommandRange >= meta.EndCommandRangeExclusive)
                return;

            var leaf = new NWayTreeStorageInternal<ArrayCommandChunk>(container)
            {
                StoredValue = CloneMeta(meta, meta.StartCommandRange, meta.EndCommandRangeExclusive)
            };

            for (int b = meta.LastChild; b >= 1; b--)
                container.SetBranch((byte)(b + 1), container.GetBranch((byte)b));

            container.SetBranch(1, leaf);
            meta.LastChild += 1;
            meta.StartCommandRange = meta.EndCommandRangeExclusive;
        }

        private static void SliceConditionalBody(ArrayCommandList acl,
                                                 NWayTreeStorageInternal<ArrayCommandChunk> gate)
        {
            var gInfo = gate.StoredValue;
            int depth = 0;
            int ifIdx = -1;
            for (int i = gInfo.StartCommandRange; i < gInfo.EndCommandRangeExclusive; i++)
            {
                var ct = acl.UnderlyingCommands[i].CommandType;
                if (ct == ArrayCommandType.If)
                {
                    if (depth == 0) ifIdx = i;
                    depth++;
                }
                else if (ct == ArrayCommandType.EndIf)
                {
                    depth--;
                    if (depth == 0)
                    {
                        CreateSlices(acl, gate, ifIdx + 1, i);
                        break;
                    }
                }
            }
        }

        private static void CreateSlices(ArrayCommandList acl,
                                         NWayTreeStorageInternal<ArrayCommandChunk> gate,
                                         int bodyStart,
                                         int bodyEnd)
        {
            var gInfo = gate.StoredValue;
            int max = acl.MaxCommandsPerChunk;
            int sliceStart = bodyStart;
            byte branch = 1;
            while (sliceStart < bodyEnd)
            {
                int sliceEnd = Math.Min(sliceStart + max, bodyEnd);
                var slice = new NWayTreeStorageInternal<ArrayCommandChunk>(gate)
                {
                    StoredValue = CloneMeta(gInfo, sliceStart, sliceEnd)
                };
                gate.SetBranch(branch++, slice);
                sliceStart = sliceEnd;
            }
            gInfo.LastChild = (byte)(branch - 1);
        }
    }
}
