using ACESimBase.Util.Debugging;
using ACESimBase.Util.NWayTreeStorage;
using System;
using System.Collections.Generic;
using System.Linq;
using Tensorflow;

namespace ACESimBase.Util.ArrayProcessing
{
    /// <summary>
    /// Applies the split plan generated by <see cref="HoistPlanner"/> to the
    /// command tree in <see cref="ArrayCommandList"/>.
    /// </summary>
    public static class HoistMutator
    {
        /// <summary>
        /// Repeatedly plans and applies splits until every executable leaf is
        /// within the maximum command limit configured in <paramref name="acl"/>.
        /// </summary>
        public static void MutateUntilAsBalancedAsPossible(ArrayCommandList acl)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (acl.MaxCommandsPerSplittableChunk == int.MaxValue)
                return;           // hoisting disabled


#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine($"── before mutation ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("───────────────");
#endif

            int round = 0;
            while (true)
            {
                round++;
                var planner = new HoistPlanner(acl.UnderlyingCommands, acl.MaxCommandsPerSplittableChunk);
                var plan = planner.BuildPlan(acl.CommandTree);

                if (plan.Count == 0)
                {
                    break;        // tree already balanced
                }

                ApplyPlan(acl, plan);

#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"── after round {round} ──");
                TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
                TabbedText.WriteLine("───────────────");
#endif
            }
        }


        /// <summary>
        /// Applies a single split plan to the command tree.
        /// </summary>
        public static void ApplyPlan(ArrayCommandList acl, IList<HoistPlanner.PlanEntry> plan)
        {
            if (acl == null) throw new ArgumentNullException(nameof(acl));
            if (plan == null || plan.Count == 0) return;

            foreach (var entry in plan)
            {
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine(
                    $"[APPLY] leafId={entry.LeafId} kind={entry.Kind} span=[{entry.StartIdx},{entry.EndIdxExclusive})");
#endif
                var leaf = FindLeaf(acl.CommandTree, entry.LeafId);
                if (leaf == null || (leaf.Branches?.Length ?? 0) > 0)
                    continue;                           // node is no longer a leaf


                Split(acl, leaf, entry.StartIdx, entry.EndIdxExclusive, entry.Kind == HoistPlanner.SplitKind.Conditional);
            }

#if OUTPUT_HOISTING_INFO
            TabbedText.WriteLine("── tree after ApplyPlan ──");
            TabbedText.WriteLine(acl.CommandTree.ToTreeString(_ => "Leaf"));
            TabbedText.WriteLine("─────────────────────────");
#endif
        }

        private static void Split(
            ArrayCommandList acl,
            ACESimBase.Util.NWayTreeStorage.NWayTreeStorageInternal<ArrayCommandChunk> leaf,
            int spanStart,
            int spanEndEx,
            bool isConditionalSplit)
        {
            var info = leaf.StoredValue;
            var cmds = acl.UnderlyingCommands;

            int originalStart = info.StartCommandRange;
            int originalEnd   = info.EndCommandRangeExclusive;

            int prefixEnd   = spanStart;        // [originalStart, prefixEnd)
            int bodyStart   = spanStart + 1;    // [bodyStart, bodyEnd)
            int bodyEnd     = spanEndEx - 1;
            int suffixStart = spanEndEx;        // [suffixStart, originalEnd)

            static int CountOps(ArrayCommand[] c, int s, int e, ArrayCommandType t)
            {
                int count = 0;
                for (int i = s; i < e; i++)
                    if (c[i].CommandType == t) count++;
                return count;
            }

            ArrayCommandChunk MakeSlice(int sliceStart, int sliceEndEx, bool isConditional)
            {
                int beforeSrc = CountOps(cmds, originalStart, sliceStart, ArrayCommandType.NextSource);
                int sliceSrc  = CountOps(cmds, sliceStart, sliceEndEx, ArrayCommandType.NextSource);

                int beforeDst = CountOps(cmds, originalStart, sliceStart, ArrayCommandType.NextDestination);
                int sliceDst  = CountOps(cmds, sliceStart, sliceEndEx, ArrayCommandType.NextDestination);

                return new ArrayCommandChunk
                {
                    StartCommandRange = sliceStart,
                    EndCommandRangeExclusive = sliceEndEx,

                    StartSourceIndices = info.StartSourceIndices + beforeSrc,
                    EndSourceIndicesExclusive = info.StartSourceIndices + beforeSrc + sliceSrc,

                    StartDestinationIndices = info.StartDestinationIndices + beforeDst,
                    EndDestinationIndicesExclusive = info.StartDestinationIndices + beforeDst + sliceDst,

                    IsConditional = isConditional
                };
            }

            var branches = new List<(int start, int endEx, bool cond)>();
            if (originalStart <= prefixEnd)
                branches.Add((originalStart, prefixEnd, false));
            branches.Add((bodyStart, bodyEnd, isConditionalSplit));
            if (suffixStart <= originalEnd)
                branches.Add((suffixStart, originalEnd, false));

            var branchNodes = branches.Select(b =>
                new ACESimBase.Util.NWayTreeStorage.NWayTreeStorageInternal<ArrayCommandChunk>(leaf)
                {
                    StoredValue = MakeSlice(b.start, b.endEx, b.cond)
                }
            ).ToArray();

            for (byte i = 1; i <= branchNodes.Length; i++)
                leaf.SetBranch(i, branchNodes[i - 1]);

            info.LastChild = (byte)branchNodes.Length;
        }

        /* Helpers */

        private static NWayTreeStorageInternal<ArrayCommandChunk> FindLeaf(
            NWayTreeStorageInternal<ArrayCommandChunk> root, int id)
        {
            NWayTreeStorageInternal<ArrayCommandChunk> target = null;
            root.WalkTree(nObj =>
            {
                var n = (NWayTreeStorageInternal<ArrayCommandChunk>)nObj;
#if OUTPUT_HOISTING_INFO
                TabbedText.WriteLine($"[FIND] visit ID{n.StoredValue.ID} children={(n.Branches?.Length ?? 0)}");
#endif
                if (n.Branches is { Length: > 0 }) return;
                if (n.StoredValue.ID == id) target = n;
            });
            return target;
        }

        private static ArrayCommandChunk CloneMeta(ArrayCommandChunk src, int start, int endEx, bool isConditional)
        {
            return new ArrayCommandChunk
            {
                StartCommandRange = start,
                EndCommandRangeExclusive = endEx,
                StartSourceIndices = src.StartSourceIndices,
                EndSourceIndicesExclusive = src.EndSourceIndicesExclusive,
                StartDestinationIndices = src.StartDestinationIndices,
                EndDestinationIndicesExclusive = src.EndDestinationIndicesExclusive,
                IsConditional = isConditional,
            };
        }

    }
}
