using ACESim;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static ACESimBase.Util.CPrint;

namespace ACESimBase.GameSolvingAlgorithms.ECTAAlgorithm
{
	/// <summary>
	/// A fairly literal conversion of the column printing routines from the ECTA code. It takes advantage of the CPrint static class to emulate C printing functions. These ultimately call Console.Write.
	/// </summary>
    public static class ColumnPrinter
    {
		private static int COLBUFSIZE = 3_000_000;

		/* contains in succession all strings generated by  colpr,
		 * each terminated by '\0'
		 */
		internal static char[] buf = new char[COLBUFSIZE];

		internal static int posinbuf; // first free byte is  buf[posinbuf]
		internal static int ncols; // number of columns
		internal static int[] colwidth; // [0..ncols-1]  output widths
		internal static int[] widthsign; // -1 for left, 1 for right adjustment
		internal static int currlines; // no of fully printed lines
		internal static int currcol; // current column, modulo  ncols

		public class ColumnPrintException : Exception
        {
			public ColumnPrintException(string message): base(message) { }
        }

		public static void colset(int c)
		{
			int j;
			if (c < 1)
			{
				throw new ColumnPrintException("Colset requires positive no of calls");
			}
			colwidth = new int[c]; // init to  0
			widthsign = new int[c];
			for (j = 0; j < c; j++)
			{
				widthsign[j] = 1;
			}
			ncols = c;
			posinbuf = 0;
			currcol = 0;
			currlines = 0;
		}

		/* print integer i  into the current column                     */
		public static void colipr(int i)
		{
			string s = sprintf("%d", i);
			colpr(s);
		}

		/* making column  c  in  0..ncols-1  left-adjusted              */
		public static void colleft(int c)
		{
			widthsign[c] = -1;
		}

		/* terminate current line early.  blank line if in col  0       */
		public static void colnl()
		{
			int j;
			for (j = currcol; j < ncols; j++)
			{
				colpr("");
			}
		}

		/* print out the current buffer, without flushing               */
		public static void colout()
		{
			int i;
			int posinbuf = 0;
			for (i = 0; i < currlines; i++)
			{
				posinbuf = prline(buf, posinbuf, ncols);
			}
			prline(buf, posinbuf, currcol);
		}

		public static void colpr(char[] c) => colpr(new string(c));

		/* store string  s  into the current column,
		 * updating column width
		 */
		public static void colpr(string s)
		{
			int j;
			int w = s.Length;

			if (posinbuf + w + 1 > COLBUFSIZE)
			/* not enough space in current buffer, flush                */
			/* require  w < COLBUFSIZE,  otherwise undefined behavior   */
			{
				int cc = currcol;
				colout();
				Console.Write("\n-----output reset-----\n\n");
				colset(ncols);
				for (j = 0; j < cc; j++)
				{
					/* print blank columns to continue in the correct column  */
					buf[posinbuf++] = '\0'; // string terminator
				}
				currcol = cc;
			}
			if (colwidth[currcol] < w)
			{
				colwidth[currcol] = w;
			}
			strcpy(buf, posinbuf, s);
			posinbuf += w + 1;
			currcol++;
			if (currcol == ncols) // this requires  ncols > 0
			{ // wrap around to column 0
				currcol = 0;
				currlines++;
			}
		}

		/* print the first  cols  strings starting at  s  
		 * followed by "\n".  Print nothing if  cols==0. 
		 * return pointer to the next position. 
		 */
		internal static int prline(char[] buf, int sindex, int cols)
		{
			int j;
			for (j = 0; j < cols; j++)
			{
				string s = getstring(buf, sindex);
				int totalWidth = colwidth[j] * widthsign[j];
				bool leftJustify = totalWidth < 0;
				if (leftJustify)
                {
					totalWidth = 0 - totalWidth;
                }
				else
					for (int i = 0; i < totalWidth - s.Length; i++)
						TabbedText.Write(" ");
				TabbedText.Write(s);
				if (leftJustify)
					for (int i = 0; i < totalWidth - s.Length; i++)
						TabbedText.Write(" ");
				sindex += s.Length + 1;
				if (j < cols - 1) // avoid trailing blanks in line
				{
					TabbedText.Write(" "); // more sophisticated spacing possible
				}
				else
				{
					TabbedText.Write("\n"); // in loop to prevent newline if 0 cols
				}
			}
			return sindex;
		}
	}
}
