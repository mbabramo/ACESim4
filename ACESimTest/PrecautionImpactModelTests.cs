using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using FluentAssertions;
using ACESimBase.Games.LitigGame.PrecautionModel;
using System.Linq;

namespace ACESimTest
{
    /// <summary>
    /// MSTest + FluentAssertions checks for PrecautionImpactModel.
    /// Hidden 0 ⇒ factor 0.8 ; Hidden 1 ⇒ factor 0.6.
    /// Two real precaution levels (0,1) plus hypothetical 2.
    /// </summary>
    [TestClass]
    public sealed class PrecautionImpactModelTests
    {
        PrecautionImpactModel impact;

        [TestInitialize]
        public void Init()
        {
            impact = new PrecautionImpactModel(
                precautionPowerLevels: 2,
                precautionLevels: 2,
                pAccidentNoActivity: 0.01,
                pAccidentNoPrecaution: 0.25,
                marginalPrecautionCost: 0.04,
                harmCost: 1.0,
                precautionPowerFactorLeastEffective: 0.8, // hidden 0
                precautionPowerFactorMostEffective: 0.6, // hidden 1
                liabilityThreshold: 1.0);
        }

        [TestMethod]
        public void AccidentProbabilitiesExact()
        {
            double[,] expected =
            {
                { 0.25, 0.20, 0.16 },   // hidden 0 (factor 0.8)
                { 0.25, 0.15, 0.09 }    // hidden 1 (factor 0.6)
            };

            for (int h = 0; h < 2; h++)
                for (int k = 0; k <= 2; k++)
                    impact.GetAccidentProbability(h, k)
                          .Should().BeApproximately(expected[h, k], 1e-6);
        }

        [TestMethod]
        public void MarginalAccidentProbabilities()
        {
            impact.GetAccidentProbabilityMarginal(0).Should().BeApproximately(0.25, 1e-6);
            impact.GetAccidentProbabilityMarginal(1).Should().BeApproximately(0.175, 1e-6);
        }

        [TestMethod]
        public void RiskReductionMonotone()
        {
            for (int h = 0; h < 2; h++)
            {
                double prev = double.MaxValue;
                for (int k = 0; k < 2; k++)
                {
                    double delta = impact.GetRiskReduction(h, k);
                    delta.Should().BeGreaterOrEqualTo(0);
                    delta.Should().BeLessOrEqualTo(prev + 1e-9);
                    prev = delta;
                }
            }
        }

        [TestMethod]
        public void GroundTruthNegligence()
        {
            // hidden 0 (factor 0.8)
            impact.IsTrulyLiable(0, 0).Should().BeTrue();
            impact.IsTrulyLiable(0, 1).Should().BeFalse();

            // hidden 1 (factor 0.6)
            impact.IsTrulyLiable(1, 0).Should().BeTrue();
            impact.IsTrulyLiable(1, 1).Should().BeTrue();

            impact.GetTrueLiabilityProbability(0).Should().BeApproximately(1.0, 1e-6);
            impact.GetTrueLiabilityProbability(1).Should().BeApproximately(0.5, 1e-6);
        }

        [TestMethod]
        public void AccidentRiskAboveBaseline()
        {
            double baseline = impact.PAccidentNoActivity;
            for (int h = 0; h < 2; h++)
                for (int k = 0; k <= 2; k++)
                    impact.GetAccidentProbability(h, k)
                          .Should().BeGreaterOrEqualTo(baseline - 1e-9);
        }

        // -------------------------------------------------------------------
        // Additional tests
        // -------------------------------------------------------------------

        [TestMethod]
        public void AutoGeneratedPrecautionPowerFactors()
        {
            var autoImpact = new PrecautionImpactModel(
                precautionPowerLevels: 3,
                precautionLevels: 2,
                pAccidentNoActivity: 0.01,
                pAccidentNoPrecaution: 0.3,
                marginalPrecautionCost: 0.04,
                harmCost: 1.0);

            // Should build 3 descending factors between 0.9 and 0.5
            autoImpact.GetAccidentProbability(0, 0).Should().BeApproximately(0.3, 1e-6);
            autoImpact.GetAccidentProbability(2, 1).Should().BeLessThan(0.3);
        }

        [TestMethod]
        public void CustomAccidentProbabilityOverride()
        {
            var overrideImpact = new PrecautionImpactModel(
                precautionPowerLevels: 2,
                precautionLevels: 2,
                pAccidentNoActivity: 0.01,
                pAccidentNoPrecaution: 0.5,
                marginalPrecautionCost: 0.1,
                harmCost: 1.0,
                precautionPowerFactors: new[] { 0.9, 0.8 },
                accidentProbabilityOverride: (h, k) => 0.5 - 0.1 * k);

            overrideImpact.GetAccidentProbability(0, 0).Should().BeApproximately(0.5, 1e-6);
            overrideImpact.GetAccidentProbability(0, 1).Should().BeApproximately(0.4, 1e-6);
        }

        [TestMethod]
        public void AccidentProbabilityGivenSignalsMatchesBayesMix()
        {
            var signalModel = new PrecautionSignalModel(
                numPrecautionPowerLevels: 2,
                numPlaintiffSignals: 2,
                numDefendantSignals: 2,
                numCourtSignals: 2,
                sigmaPlaintiff: 0.0,
                sigmaDefendant: 0.0,
                sigmaCourt: 0.0);

            const int dSig = 0;
            const int pSig = 0;
            const int k = 1;

            double numer = 0.0, denom = 0.0;
            double prior = 0.5;                         // uniform prior

            for (int h = 0; h < 2; h++)
            {
                double like =
                    prior *
                    signalModel.GetDefendantSignalProbability(h, dSig) *
                    signalModel.GetPlaintiffSignalProbability(h, pSig);

                numer += like * impact.GetAccidentProbability(h, k);
                denom += like;
            }

            double expected = numer / denom;
            double actual = impact.GetAccidentProbabilityGivenBothSignalsAndPrecautionLevel(dSig, pSig, k, signalModel);

            actual.Should().BeApproximately(expected, 1e-9);
        }

        [TestMethod]
        public void WrongfulAttributionProbabilityMatchesBayesMix()
        {
            var signalModel = new PrecautionSignalModel(
                numPrecautionPowerLevels: 2,
                numPlaintiffSignals: 2,
                numDefendantSignals: 2,
                numCourtSignals: 2,
                sigmaPlaintiff: 0.0,
                sigmaDefendant: 0.0,
                sigmaCourt: 0.0);

            const int dSig = 1;
            const int pSig = 1;
            const int k = 0;

            double numer = 0.0, denom = 0.0;
            double prior = 0.5;

            for (int h = 0; h < 2; h++)
            {
                double like =
                    prior *
                    signalModel.GetDefendantSignalProbability(h, dSig) *
                    signalModel.GetPlaintiffSignalProbability(h, pSig);

                double pAcc = impact.GetAccidentProbability(h, k);
                double pCaus = impact.GetRiskReduction(h, k) < 1e-12
                               ? 0.0
                               : pAcc - impact.PAccidentWrongfulAttribution *
                                        (1.0 - impact.GetRiskReduction(h, k));

                double pWrongful = pAcc - pCaus;   // portion due to wrongful attribution

                numer += like * pWrongful;
                denom += like * pAcc;              // condition on accident happened
            }

            double expected = numer / denom;
            double actual = impact.GetWrongfulAttributionProbabilityGivenSignals(dSig, pSig, k, signalModel);

            actual.Should().BeApproximately(expected, 1e-9);
        }


        [TestMethod]
        public void InvalidConfigurationThrows()
        {
            Action act = () => new PrecautionImpactModel(
                precautionPowerLevels: 2,
                precautionLevels: 0,
                pAccidentNoActivity: 0.01,
                pAccidentNoPrecaution: 0.25,
                marginalPrecautionCost: 0.04,
                harmCost: 1.0,
                precautionPowerFactors: new[] { 0.8, 0.6 });

            act.Should().Throw<ArgumentException>();
        }

        [TestMethod]
        public void OutOfBoundsAccessThrows()
        {
            Action bad = () => impact.GetAccidentProbability(99, 0);
            bad.Should().Throw<ArgumentOutOfRangeException>();

            Action bad2 = () => impact.IsTrulyLiable(0, 99);
            bad2.Should().Throw<ArgumentOutOfRangeException>();
        }

        [TestMethod]
        public void AccidentProbabilityGivenDefendantSignalMatchesBayesMix()
        {
            // Fresh model so the calculation is independent of the shared fixture.
            var localImpact = new PrecautionImpactModel(
                precautionPowerLevels: 2,
                precautionLevels: 2,
                pAccidentNoActivity: 0.01,
                pAccidentNoPrecaution: 0.25,
                marginalPrecautionCost: 0.04,
                harmCost: 1.0,
                precautionPowerFactorLeastEffective: 0.8,
                precautionPowerFactorMostEffective: 0.6,
                liabilityThreshold: 1.0);

            var signalModel = new PrecautionSignalModel(
                numPrecautionPowerLevels: 2,
                numPlaintiffSignals: 2,
                numDefendantSignals: 2,
                numCourtSignals: 2,
                sigmaPlaintiff: 0.0,
                sigmaDefendant: 0.0,
                sigmaCourt: 0.0);

            const int defendantSignal = 0;
            const int precautionLevel = 1;

            double prior = 0.5;          // uniform prior over hidden states
            double numer = 0.0, denom = 0.0;

            for (int h = 0; h < 2; h++)
            {
                double likelihood =
                    prior *
                    signalModel.GetDefendantSignalProbability(h, defendantSignal);

                numer += likelihood *
                         localImpact.GetAccidentProbability(h, precautionLevel);
                denom += likelihood;
            }

            double expected = numer / denom;
            double actual = localImpact.GetAccidentProbabilityGivenDSignalAndPrecautionLevel(
                                defendantSignal,
                                precautionLevel,
                                signalModel);

            actual.Should().BeApproximately(expected, 1e-9);
        }

        [TestMethod]
        public void AccidentProbabilityGivenDefendantSignalOutOfRangeThrows()
        {
            var signalModel = new PrecautionSignalModel(
                numPrecautionPowerLevels: 2,
                numPlaintiffSignals: 2,
                numDefendantSignals: 1,  // only index 0 is valid
                numCourtSignals: 2,
                sigmaPlaintiff: 0.0,
                sigmaDefendant: 0.0,
                sigmaCourt: 0.0);

            Action act = () => impact.GetAccidentProbabilityGivenDSignalAndPrecautionLevel(
                                    defendantSignal: 99,
                                    precautionLevel: 0,
                                    signalModel);

            act.Should().Throw<ArgumentOutOfRangeException>();
        }

        [TestMethod]
        public void PlaintiffSignalDistributionGivenDefendantSignalAndAccidentMatchesEnumeration()
        {
            var impact = new PrecautionImpactModel(2, 2, 0.01, 0.25, 0.04, 1.0);
            var signals = new PrecautionSignalModel(2, 2, 2, 2, 0.0, 0.0, 0.0);

            const int dSig = 1;
            const int k = 0;

            double[] expected = new double[signals.NumPSignals];
            double prior = 0.5;

            for (int h = 0; h < 2; h++)
            {
                double weight = prior *
                                signals.GetDefendantSignalProbability(h, dSig) *
                                impact.GetAccidentProbability(h, k);

                for (int p = 0; p < expected.Length; p++)
                    expected[p] += weight * signals.model.GetSignalDistributionGivenHidden(PrecautionSignalModel.PlaintiffIndex, h)[p];
            }

            double total = expected.Sum();
            for (int p = 0; p < expected.Length; p++) expected[p] /= total;

            double[] actual = signals.GetPlaintiffSignalDistributionGivenDefendantSignalAndAccident(dSig, k, impact);

            actual.Should().BeEquivalentTo(expected, opts => opts.WithStrictOrdering());
        }

        [TestMethod]
        public void PlaintiffSignalDistributionGivenDefendantSignalAndAccidentThrowsOnOutOfRange()
        {
            var impact = new PrecautionImpactModel(2, 1, 0.01, 0.25, 0.04, 1.0);
            var signals = new PrecautionSignalModel(2, 2, 1, 1, 0.0, 0.0, 0.0);

            Action act = () => signals.GetPlaintiffSignalDistributionGivenDefendantSignalAndAccident(
                                    defendantSignal: 99, precautionLevel: 0, impact);

            act.Should().Throw<ArgumentOutOfRangeException>();
        }


    }
}
