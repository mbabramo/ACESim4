== ACESim.!BargainingGame2 ==
A dummy Game subclass to show a basic Game implementation.
=== Methods ===
 '''!MakeCurrentDecision''':: 
            If game play is completed, then gameSettings.gameComplete should be set to true. 
            



== ACESim.Command ==
Base class for all commands, which are always contained in multipart commands
=== Fields ===
 '''!MultiPartCommand''':: 
            The !MultiPartCommand in which this Command is contained.
            

=== Methods ===
 '''Execute(ACESim.!SimulationInteraction)'''::  1. simulationInteraction: 



== ACESim.!CommandSet ==
The top-level container for Commands. Contains !CommandSets, which in turn contain Commands.


== ACESim.Decision ==
This provides information on one decision to be made in a simulation.
=== Fields ===
 '''Abbreviation''':: 
            An abbreviation for this name (e.g., “ps”).
            

 '''Bipolar''':: 
            If the decision can only take the value -1 or 1.
            

 '''!DummyDecisionRequiringNoOptimization''':: 
            If true, then the Calculate method will always return 0, but oversampling analysis and development of cumulative distributions will still take place.
            

 '''!DynamicNumberOfInputs''':: 
            If this is set, the input names and abbreviations, as well as the input groups, are ignored. 
            

 '''!EvolveThisDecisionEvenWhenSkippingByDefault''':: 
            This is useful in development when, after evolving a number of decisions, we want to focus on one.
            We should set !DoNotEvolveByDefault in !EvolutionSettings.
            

 '''!ExecutionOrder''':: 
            This controls the order of execution (but NOT the order of evolution) within the game. 
            

 '''!HighestIsBest''':: 
            Are high scores best for this decision?
            

 '''!InputAbbreviations''':: 
            Abbreviations for the inputs (e.g., “x”). This will be used when we print out the strategy.
            

 '''!InputGroups''':: 
            Groups of inputs, so that separate strategies will be developed for each group. If omitted,
            then single strategy with all inputs will be developed.
            

 '''!InputNames''':: 
            The names of the inputs (e.g., “litigation costs,” etc.)
            

 '''!InputsAndOccurrencesAlwaysSameAsPreviousDecision''':: 
            If the following is true, information from optimization of the last decision will be copied rather than recreated.
            

 '''!MaxEvolveRepetitions''':: 
            The maximum number of times to evolve this. This is useful when some decisions must be evolved repeatedly, while others are evolved only once.
            Set it to a very high number if we don't want to limit repetitions.
            

 '''!MustBeInEquilibriumWithNextDecision''':: 
            This can be used to pair two decisions, each taking zero inputs, where the goal is to find an equilibrium between the decisions.
            

 '''!MustBeInEquilibriumWithPreviousAndNextDecision''':: 
            If more than two decisions must be in equilibrium with one another, this setting can be used.
            

 '''!MustBeInEquilibriumWithPreviousDecision''':: 
            This can be used to pair two decisions, each taking zero inputs, where the goal is to find an equilibrium between the decisions.
            

 '''Name''':: 
            The name of the decision (e.g., “Plaintiff settlement decision”).
            

 '''!PhaseOutDefaultBehaviorOverRepetitions''':: 
            Use of this feature is not currently recommended. It phases out default behavior of a module over repetitions of a module.
            The better feature to implement might be to phase out default behavior over evolution steps.
            If greater than 1, then the default behavior will receive some weight over the remaining specified repetitions of the module.
            For example, if 3, then first time, default behavior will receive weight of 1.0, second time weight of 0.67, third time 0.33, and thereafter 0.0.
            

 '''!PreservePreviousVersionWhenOptimizing''':: 
            When this is set to true, the previous version of the strategy corresponding to the decision will be saved when the decision is
            being optimized. This is useful if there are multiple agents using the same strategy, if we are not copying the decision a 
            separate time into the game definition for each agent. For example, we can evolve the optimal strategy for one player in an
            auction, while having all other players use the old strategy, hoping eventually to have convergence.
            

 '''!RepetitionsAfterFirst''':: 
            When this is set to more than 1, the decision will be copied multiple times into the game definition, and each
            version of the decision will be evolved separately. (Note: This 
            

 '''!ScoreRepresentsCorrectAnswer''':: 
            This indicates whether the score is not really an indication of how good the decision is, but instead represents the best decision.
            If the decision is a forecast, and the variable that is being forecast is known to the simulation (at least some of the time), then this should be true.
            Then, instead of a score being the error in the forecast, the score should simply be the the correct forecast. This will save time in
            the optimization of the decision, because we can simply average the scores, instead of trying a range of different values until we get
            the closest one.
            

 '''!SkipThisDecisionWhenEvolvingIfAlreadyEvolved''':: 
            This is useful in development when, after evolving a number of decisions, we want to keep the evolved version of one
            while exploring the evolution of others.
            

 '''!StrategyBounds''':: 
            The bounds for the decision.
            

 '''!StrategyGraphInfos''':: 
            Information on graphs to produce based on the strategy as it is evolving or has already evolved.
            

 '''!SuccessReplicationIfSuccessAttemptRatioIsBelowThis''':: 
            When using oversampling, we may also use success replication. This is when we find (using oversampling) a sample of decisions that successfully
            reach the decision being optimized. We figure out which input seeds can be changed without affecting success. Then, when generating new
            iterations, we copy the input seeds from this sample that guaranteed success, but replace the ones that can be changed without affecting
            success. Once success replication is triggered for one strategy, it will automatically be used for any subsequent strategy that is a subset.
            

 '''!TestInputs''':: 
            In development, you can specify a set of inputs where you would like information about what score is produced for each
            of one or more outputs. The test is based on the smoothing point closest to the test input.
            

 '''!TestOutputs''':: 
            The outputs to test separately using the set of inputs in !TestInputs.
            

 '''!UseAlternativeGameInputs''':: 
            Setting this to true ensures that the game inputs will be different for this decision than for other decisions for which it is not true.
            

 '''!UseOversampling''':: 
            If true, an !OversamplingPlan will be developed so that we concentrate only on the portions of the input seeds range that tend to lead to this decision occurring. Weights will be produced so that oversampled observations can be devalued relative to those that produce the decision without oversampling.
            



== ACESim.!EvolveCommand ==
A Command containing all the information to perform evolution.


== ACESim.!FilterAnd ==
This filter returns true only if all contained filters contain true. This is normally not necessary because this is the default behavior when there are multiple filters for a table cell. However, it may be useful as a subset of !FilterOr.


== ACESim.Forecast ==
This is a helper class to simplify programming in games where one or more strategies to be evolved are simply forecasting some number, where the correct number is known to the game being evolved. It also contains support for simultaneously evolving a forecast of a number and an assessment of the accuracy of the forecast.
=== Methods ===
 '''Score(ACESim.Strategy,ACESim.Strategy,System.Boolean,System.Double[],System.Double,System.Double@)''':: 
            This is used to score two strategies forecasting some number; one represents the underlying prediction, 
            and the other represents the average absolute error. The underlyingPredictionStrategy and 
            errorPredictionStrategy are from two different populations – one of which is supposed to be making a 
            forecast of the correctAnswer based on the inputs, and the other of which is forecasting the average 
            absolute error of the first. If scoreUnderlyingPrediction, this returns 
            Score(underlyingPredictionStrategy, inputs, correctAnswer). Otherwise, it calls 
            Score(underlyingPredictionStrategy, inputs, correctAnswer, out decision) and then returns 
            Score(errorPredictionStrategy, inputs, abs(decision – correctAnswer)).
            
 1. underlyingPredictionStrategy: 
 1. errorPredictionStrategy: 
 1. scoreUnderlyingPrediction: 
 1. inputs: 
 1. correctAnswer: 
 * Returns: 

 '''Score(ACESim.Strategy,System.Double[],System.Double)''':: 
            Makes a decision based on the strategy, with the inputs specified, and returns the 
            squared difference between this decision and the correct answer. 
            
 1. strategy: 
 1. inputs: 
 1. correctAnswer: 

 '''Score(ACESim.Strategy,System.Double[],System.Double,System.Double@)''':: 
            Same as Score(Strategy, List, double), but also sets the decision parameter to the decision 
            returned by the strategy.
            
 1. strategy: 
 1. inputs: 
 1. correctAnswer: 
 1. decision: 
 * Returns: 



== ACESim.Game ==
This class provides the base methods for playing a game.
=== Methods ===
 '''Calculate(System.Double[])''':: 
            Calls Calculate method on the strategy corresponding to the decisionNumber. 
            

 '''!GetDecisionInputs''':: 
            The subclass will create the inputs based on the gameSettings.
            
            This is game subclass-specific. These are the numbers that will be
            passed into the strategy. So, in a litigation-subclass, the inputs that
            getDecisionInputs returns might be the litigant's estimate of the
            probability of winning, the litigant's wealth, etc. 
            

 '''!MakeCurrentDecision''':: 
            This should be handled entirely by the subclass if !PrepareForOrMakeCurrentDecision is not overridden.
            In this method, the subclass makes the decision indicated by !CurrentDecisionNumber.
            

 '''!MakeDecision(System.Double[])''':: 
            Calls !GetDecisionInputs and Calculate, and it updates the 
            decisionCompleted field of !GameSettings 
            

 '''!PlayUntilComplete(System.Nullable<System.Int32>,System.Nullable<System.Int32>)''':: 
            Continue to make decisions until the game is complete.
            

 '''!PlayUpTo(System.Int32,System.Nullable<System.Int32>)''':: 
            Repeatedly play the game up to the decision number, calling the Game subclass to prepare for or play each decision.
            
 1. decisionNumber: 

 '''!PrepareForOrMakeCurrentDecision''':: 
            This calls either the method that allows preparation for a particular decision or requires execution of that decision.
            The subclass can either override this method, or it can override !PrepareForCurrentDecision and !CompleteCurrentDecision,
            depending on whether the code is best organized by separating the prepartion steps from the execution steps.
            If game play is completed, then Progress.Complete should be set to true. 
            

 '''Score(System.Int32,System.Double)''':: 
            Scores the strategy represented by decisionNumber.
            
 1. decisionNumber: 



== ACESim.!LitigationGame ==
A dummy Game subclass to show a basic Game implementation.


== ACESim.!MultiPartCommand ==
Contains Commands and contained in !CommandSets.


== ACESim.!MyGame ==
A dummy Game subclass to show a basic Game implementation.
=== Methods ===
 '''!PrepareForOrMakeCurrentDecision''':: 
            If game play is completed, then gameSettings.gameComplete should be set to true. 
            



== ACESim.!ObfuscationGame ==
A dummy Game subclass to show a basic Game implementation.
=== Methods ===
 '''!MakeCurrentDecision''':: 
            If game play is completed, then gameSettings.gameComplete should be set to true. 
            



== ACESim.!ObjectCopier ==
http://stackoverflow.com/questions/78536/cloning-objects-in-c Reference Article http://www.codeproject.com/KB/tips/!SerializedObjectCloner.aspx Provides a method for performing a deep copy of an object. Binary Serialization is used to perform the copy.
=== Methods ===
 '''Clone``1(``0)'''::  
            Perform a deep Copy of the object. 
            
 1. source: The object instance to copy.
 1. Type Param: T: The type of object being copied.
 * Returns: The copied object.



== ACESim.Properties.Resources ==
A strongly-typed resource class, for looking up localized strings, etc.
=== Properties ===
 '''Culture''':: 
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            

 '''!ResourceManager''':: 
              Returns the cached !ResourceManager instance used by this class.
            



== ACESim.!SimulationCoordinator ==
Manages a List of Populations for one Game, where each Population corresponds to a Decision in the Game. Called by commands to effect simulation, e.g. !PlayCommand and !EvolveCommand. Uses !DecisionEvolver and !GamePlayer as helpers.
=== Fields ===
 '''!SimulationInteraction''':: 
            A reference to interact with the simulation host
            

=== Methods ===
 '''!ExecuteEvolveStep(ACESim.!EvolutionSettings,System.Boolean,System.String,System.Int32,System.Int32,System.Boolean,System.Int32@,System.Collections.Generic.List<System.Double>@,System.Collections.Generic.List<System.Double>@,System.Boolean@)''':: 
            Executes evolve steps for all decisions except those in skip decisions.
            

 '''!GetStrategies''':: 
            Returns the current best strategy for each decision, eliminating zero terms where possible.
            
 * Returns: 



== ACESim.!StrategyBounds ==



== ACESim.Util.!MapDelegate`1 ==
A delegate to use with IList.Map.


== ACESim.Util.!RangeFinder.!SearchStage ==
The current mode of an exponential search process.
=== Fields ===
 '''Growth''':: 
            The search is in the growth stage, where the current guess increases in magnitude from some reference value
            (default 0.0) in either a negative or positive direction, depending on the context.
            

 '''!InwardShrink''':: 
            The search has passed the target value and is now shrinking towards the reference value, but within
            the boundaries established by previous growth or shrinkage.  The search should update the boundaries based upon 
            the new guess.
            

 '''!OutwardShrink''':: 
            The search has passed the target value and is now shrinking away from the reference value, but within
            the boundaries established by previous growth or shrinkage.  The search should update the boundaries based upon 
            the new guess.
            



== Encog.Neural.Networks.Training.Anneal.!NeuralSimulatedAnnealingGoffe ==
This class implements a simulated annealing training algorithm for neural networks. It is based on the generic !SimulatedAnnealingGoffe class. It is used in the same manner as any other training class that implements the Train interface. There are essentially two ways you can make use of this class. Either way, you will need a score object. The score object tells the simulated annealing algorithm how well suited a neural network is. If you would like to use simulated annealing with a training set you should make use !TrainingSetScore class. This score object uses a training set to score your neural network. If you would like to be more abstract, and not use a training set, you can create your own implementation of the !CalculateScore method. This class can then score the networks any way that you like.
=== Fields ===
 '''_anneal''':: 
             This class actually performs the training.
             

 '''_calculateScore''':: 
             Used to calculate the score.
             

 '''_network''':: 
             The neural network that is to be trained.
             

 '''Cut''':: 
             The cutoff for random data.
             

=== Properties ===
 '''Array''':: 
            Get the network as an array of doubles.
            

 '''!ArrayCopy''':: 
 '''!CalculateScore''':: 
 '''!CanContinue''':: 
 '''Method''':: 
=== Methods ===
 '''#ctor(Encog.ML.IMLRegression,Encog.Neural.Networks.Training.ICalculateScore,System.Double,System.Double,System.Int32)''':: 
            Construct a simulated annleaing trainer for a feedforward neural network.
            

 '''Iteration''':: 
             Perform one iteration of simulated annealing.
             

 '''Pause''':: 
 '''!PutArray(System.Double[])''':: 
             Convert an array of doubles to the current best network.
             
 1. array: An array.

 '''Randomize(System.Int32,System.Double,System.Double)''':: 
             Randomize the weights and bias values. This function does most of the
             work of the class. Each call to this class will randomize the data
             according to the current temperature. The higher the temperature the more
             randomness.
             

 '''Resume(Encog.Neural.Networks.Training.Propagation.!TrainingContinuation)''':: 


== Encog.Neural.Networks.Training.Anneal.!NeuralSimulatedAnnealingGoffeHelper ==
Simple class used by the neural simulated annealing. This class is a subclass of the basic !SimulatedAnnealingGoffe class. The It is used by the actual !NeuralSimulatedAnnealingGoffe class, which subclasses !BasicTraining. This class is mostly necessary due to the fact that !NeuralSimulatedAnnealingGoffe can't subclass BOTH !SimulatedAnnealingGoffe and Train, because multiple inheritance is not supported.
=== Fields ===
 '''_owner''':: 
             The class that this class should report to.
             

=== Properties ===
 '''Array''':: 
            Used to pass the getArray call on to the parent object.
            

 '''!ArrayCopy''':: 
             Used to pass the getArrayCopy call on to the parent object.
             

=== Methods ===
 '''#ctor(Encog.Neural.Networks.Training.Anneal.!NeuralSimulatedAnnealingGoffe)''':: 
             Constructs this object.
             
 1. owner: The owner of this class, that recieves all messages.

 '''!PutArray(System.Double[])''':: 
             Used to pass the putArray call on to the parent object.
             
 1. array: The array.

 '''Randomize(System.Int32,System.Double,System.Double)''':: 
             Call the owner's randomize method.
             



== Encog.Neural.Networks.Training.Anneal.!SimulatedAnnealingGoffe`1 ==
Simulated annealing is a common training method. This class implements a simulated annealing algorithm that can be used both for neural networks, as well as more general cases. This class is abstract, so a more specialized simulated annealing subclass will need to be created for each intended use. This book demonstrates how to use the simulated annealing algorithm to train feedforward neural networks, as well as find a solution to the traveling salesman problem. The name and inspiration come from annealing in metallurgy, a technique involving heating and controlled cooling of a material to increase the size of its crystals and reduce their defects. The heat causes the atoms to become unstuck from their initial positions (a local minimum of the internal energy) and wander randomly through states of higher energy; the slow cooling gives them more chances of finding configurations with lower internal energy than the initial one.
=== Fields ===
 '''_cycles''':: 
             The number of cycles that will be used.
             

 '''_shouldMinimize''':: 
             Should the score be minimized.
             

 '''_temperature''':: 
             The current temperature.
             

=== Properties ===
 '''Array''':: 
            Subclasses must provide access to an array that makes up the solution.
            

 '''!ArrayCopy''':: 
            Get a copy of the array.
            

 '''Cycles''':: 
 '''!ShouldMinimize''':: 
            Should the score be minimized.
            

 '''!StartMoveSize''':: 
            Only relevant if dynamically adjusting move size. 
            

 '''!StartTemperature''':: 
 '''Temperature''':: 
 '''!TemperatureReductionFactor''':: 
=== Methods ===
 '''#ctor''':: 
            Construct the object.  Default !ShouldMinimize to true.
            

 '''!PutArray(`0[])''':: 
             Store the array.
             
 1. array: The array to be stored.

 '''Randomize(System.Int32,System.Double,System.Double)''':: 
             Randomize a particular index in the weight matrix.
             



== !PriorityQueue.!PriorityQueue`2 ==
Priority queue based on binary heap, Elements with minimum priority dequeued first
=== Properties ===
 '''Count''':: 
            Gets number of elements in the priority queue
            

 '''!IsEmpty''':: 
            Gets whether priority queue is empty
            

 '''!IsReadOnly''':: 
            Gets a value indicating whether the collection is read-only. 
            
 * Remarks: 
            For priority queue this property returns `false`.
            

=== Methods ===
 '''#ctor''':: 
            Initializes a new instance of priority queue with default initial capacity and default priority comparer
            

 '''#ctor(System.Collections.Generic.IComparer<`0>)''':: 
            Initializes a new instance of priority queue with default initial capacity and specified priority comparer
            
 1. comparer: priority comparer

 '''#ctor(System.Collections.Generic.IEnumerable<System.Collections.Generic.!KeyValuePair<`0,`1>>)''':: 
            Initializes a new instance of priority queue with specified data and default priority comparer
            
 1. data: data to be inserted into priority queue

 '''#ctor(System.Collections.Generic.IEnumerable<System.Collections.Generic.!KeyValuePair<`0,`1>>,System.Collections.Generic.IComparer<`0>)''':: 
            Initializes a new instance of priority queue with specified data and specified priority comparer
            
 1. data: data to be inserted into priority queue
 1. comparer: priority comparer

 '''#ctor(System.Int32,System.Boolean)''':: 
            Initializes a new instance of priority queue with specified initial capacity and default priority comparer
            
 1. capacity: initial capacity

 '''#ctor(System.Int32,System.Collections.Generic.IComparer<`0>,System.Boolean)''':: 
            Initializes a new instance of priority queue with specified initial capacity and specified priority comparer
            
 1. capacity: initial capacity
 1. comparer: priority comparer

 '''Add(System.Collections.Generic.!KeyValuePair<`0,`1>)''':: 
            Enqueus element into priority queue
            
 1. item: element to add

 '''Clear''':: 
            Clears the collection
            

 '''Contains(System.Collections.Generic.!KeyValuePair<`0,`1>)''':: 
            Determines whether the priority queue contains a specific element
            
 1. item: The object to locate in the priority queue
 * Returns: `true` if item is found in the priority queue; otherwise, `false.` 

 '''!CopyTo(System.Collections.Generic.!KeyValuePair<`0,`1>[],System.Int32)''':: 
            Copies the elements of the priority queue to an Array, starting at a particular Array index. 
            
 * Remarks: 
            It is not guaranteed that items will be copied in the sorted order.
            
 1. array: The one-dimensional Array that is the destination of the elements copied from the priority queue. The Array must have zero-based indexing. 
 1. arrayIndex: The zero-based index in array at which copying begins.

 '''Dequeue''':: 
            Dequeues element with minimum priority and return its priority and value as See:  
            
 * Remarks: 
            Method throws See:  if priority queue is empty
            
 * Returns: priority and value of the dequeued element

 '''!DequeueValue''':: 
            Dequeues element with minimum priority and return its value
            
 * Remarks: 
            Method throws See:  if priority queue is empty
            
 * Returns: value of the dequeued element

 '''Enqueue(`0,`1)''':: 
            Enqueues element into priority queue. Returns the lowest priority item if the queue is full, or null.
            
 1. priority: element priority
 1. value: element value

 '''!GetEnumerator''':: 
            Returns an enumerator that iterates through the collection.
            
 * Remarks: 
            Returned enumerator does not iterate elements in sorted order.
 * Returns: Enumerator

 '''!MergeQueues(!PriorityQueue.!PriorityQueue<`0,`1>,!PriorityQueue.!PriorityQueue<`0,`1>)''':: 
            Merges two priority queues
            
 * Remarks: 
            source priority queues must have equal comparers,
            otherwise See:  will be thrown
            
 1. pq1: first priority queue
 1. pq2: second priority queue
 * Returns: resultant priority queue

 '''!MergeQueues(!PriorityQueue.!PriorityQueue<`0,`1>,!PriorityQueue.!PriorityQueue<`0,`1>,System.Collections.Generic.IComparer<`0>)''':: 
            Merges two priority queues and sets specified comparer for resultant priority queue
            
 1. pq1: first priority queue
 1. pq2: second priority queue
 1. comparer: comparer for resultant priority queue
 * Returns: resultant priority queue

 '''Peek''':: 
            Returns priority and value of the element with minimun priority, without removing it from the queue
            
 * Remarks: 
            Method throws See:  if priority queue is empty
            
 * Returns: priority and value of the element with minimum priority

 '''!PeekValue''':: 
            Returns value of the element with minimun priority, without removing it from the queue
            
 * Remarks: 
            Method throws See:  if priority queue is empty
            
 * Returns: value of the element with minimum priority

 '''Remove(System.Collections.Generic.!KeyValuePair<`0,`1>)''':: 
            Removes the first occurrence of a specific object from the priority queue. 
            
 1. item: The object to remove from the ICollection. 
 * Returns: `true` if item was successfully removed from the priority queue.
            This method returns false if item is not found in the collection. 

 '''System#Collections#IEnumerable#!GetEnumerator''':: 
            Returns an enumerator that iterates through the collection.
            
 * Remarks: 
            Returned enumerator does not iterate elements in sorted order.
 * Returns: Enumerator



== !ProfileSimple ==
Summary description for !ProfileSimple


